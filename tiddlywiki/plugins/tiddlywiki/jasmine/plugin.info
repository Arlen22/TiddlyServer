{"title":"$:/plugins/tiddlywiki/jasmine","description":"Jasmine: testing framework","author":"JeremyRuston","core-version":">=5.0.0","list":"readme","version":"5.1.18-prerelease","plugin-type":"plugin","dependents":"","type":"application/json","tiddlers":{"$:/plugins/tiddlywiki/jasmine/jasmine-html.js":{"text":"jasmine.HtmlReporterHelpers = {};\r\n\r\njasmine.HtmlReporterHelpers.createDom = function(type, attrs, childrenVarArgs) {\r\n  var el = document.createElement(type);\r\n\r\n  for (var i = 2; i < arguments.length; i++) {\r\n    var child = arguments[i];\r\n\r\n    if (typeof child === 'string') {\r\n      el.appendChild(document.createTextNode(child));\r\n    } else {\r\n      if (child) {\r\n        el.appendChild(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var attr in attrs) {\r\n    if (attr == \"className\") {\r\n      el[attr] = attrs[attr];\r\n    } else {\r\n      el.setAttribute(attr, attrs[attr]);\r\n    }\r\n  }\r\n\r\n  return el;\r\n};\r\n\r\njasmine.HtmlReporterHelpers.getSpecStatus = function(child) {\r\n  var results = child.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.skipped) {\r\n    status = 'skipped';\r\n  }\r\n\r\n  return status;\r\n};\r\n\r\njasmine.HtmlReporterHelpers.appendToSummary = function(child, childElement) {\r\n  var parentDiv = this.dom.summary;\r\n  var parentSuite = (typeof child.parentSuite == 'undefined') ? 'suite' : 'parentSuite';\r\n  var parent = child[parentSuite];\r\n\r\n  if (parent) {\r\n    if (typeof this.views.suites[parent.id] == 'undefined') {\r\n      this.views.suites[parent.id] = new jasmine.HtmlReporter.SuiteView(parent, this.dom, this.views);\r\n    }\r\n    parentDiv = this.views.suites[parent.id].element;\r\n  }\r\n\r\n  parentDiv.appendChild(childElement);\r\n};\r\n\r\n\r\njasmine.HtmlReporterHelpers.addHelpers = function(ctor) {\r\n  for(var fn in jasmine.HtmlReporterHelpers) {\r\n    ctor.prototype[fn] = jasmine.HtmlReporterHelpers[fn];\r\n  }\r\n};\r\n\r\njasmine.HtmlReporter = function(_doc) {\r\n  var self = this;\r\n  var doc = _doc || window.document;\r\n\r\n  var reporterView;\r\n\r\n  var dom = {};\r\n\r\n  // Jasmine Reporter Public Interface\r\n  self.logRunningSpecs = false;\r\n\r\n  self.reportRunnerStarting = function(runner) {\r\n    var specs = runner.specs() || [];\r\n\r\n    if (specs.length == 0) {\r\n      return;\r\n    }\r\n\r\n    createReporterDom(runner.env.versionString());\r\n    doc.body.appendChild(dom.reporter);\r\n    setExceptionHandling();\r\n\r\n    reporterView = new jasmine.HtmlReporter.ReporterView(dom);\r\n    reporterView.addSpecs(specs, self.specFilter);\r\n  };\r\n\r\n  self.reportRunnerResults = function(runner) {\r\n    reporterView && reporterView.complete();\r\n  };\r\n\r\n  self.reportSuiteResults = function(suite) {\r\n    reporterView.suiteComplete(suite);\r\n  };\r\n\r\n  self.reportSpecStarting = function(spec) {\r\n    if (self.logRunningSpecs) {\r\n      self.log('>> Jasmine Running ' + spec.suite.description + ' ' + spec.description + '...');\r\n    }\r\n  };\r\n\r\n  self.reportSpecResults = function(spec) {\r\n    reporterView.specComplete(spec);\r\n  };\r\n\r\n  self.log = function() {\r\n    var console = jasmine.getGlobal().console;\r\n    if (console && console.log) {\r\n      if (console.log.apply) {\r\n        console.log.apply(console, arguments);\r\n      } else {\r\n        console.log(arguments); // ie fix: console.log.apply doesn't exist on ie\r\n      }\r\n    }\r\n  };\r\n\r\n  self.specFilter = function(spec) {\r\n    if (!focusedSpecName()) {\r\n      return true;\r\n    }\r\n\r\n    return spec.getFullName().indexOf(focusedSpecName()) === 0;\r\n  };\r\n\r\n  return self;\r\n\r\n  function focusedSpecName() {\r\n    var specName;\r\n\r\n    (function memoizeFocusedSpec() {\r\n      if (specName) {\r\n        return;\r\n      }\r\n\r\n      var paramMap = [];\r\n      var params = jasmine.HtmlReporter.parameters(doc);\r\n\r\n      for (var i = 0; i < params.length; i++) {\r\n        var p = params[i].split('=');\r\n        paramMap[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n      }\r\n\r\n      specName = paramMap.spec;\r\n    })();\r\n\r\n    return specName;\r\n  }\r\n\r\n  function createReporterDom(version) {\r\n    dom.reporter = self.createDom('div', { id: 'HTMLReporter', className: 'jasmine_reporter' },\r\n      dom.banner = self.createDom('div', { className: 'banner' },\r\n        self.createDom('span', { className: 'title' }, \"Jasmine \"),\r\n        self.createDom('span', { className: 'version' }, version)),\r\n\r\n      dom.symbolSummary = self.createDom('ul', {className: 'symbolSummary'}),\r\n      dom.alert = self.createDom('div', {className: 'alert'},\r\n        self.createDom('span', { className: 'exceptions' },\r\n          self.createDom('label', { className: 'label', 'for': 'no_try_catch' }, 'No try/catch'),\r\n          self.createDom('input', { id: 'no_try_catch', type: 'checkbox' }))),\r\n      dom.results = self.createDom('div', {className: 'results'},\r\n        dom.summary = self.createDom('div', { className: 'summary' }),\r\n        dom.details = self.createDom('div', { id: 'details' }))\r\n    );\r\n  }\r\n\r\n  function noTryCatch() {\r\n    return window.location.search.match(/catch=false/);\r\n  }\r\n\r\n  function searchWithCatch() {\r\n    var params = jasmine.HtmlReporter.parameters(window.document);\r\n    var removed = false;\r\n    var i = 0;\r\n\r\n    while (!removed && i < params.length) {\r\n      if (params[i].match(/catch=/)) {\r\n        params.splice(i, 1);\r\n        removed = true;\r\n      }\r\n      i++;\r\n    }\r\n    if (jasmine.CATCH_EXCEPTIONS) {\r\n      params.push(\"catch=false\");\r\n    }\r\n\r\n    return params.join(\"&\");\r\n  }\r\n\r\n  function setExceptionHandling() {\r\n    var chxCatch = document.getElementById('no_try_catch');\r\n\r\n    if (noTryCatch()) {\r\n      chxCatch.setAttribute('checked', true);\r\n      jasmine.CATCH_EXCEPTIONS = false;\r\n    }\r\n    chxCatch.onclick = function() {\r\n      window.location.search = searchWithCatch();\r\n    };\r\n  }\r\n};\r\njasmine.HtmlReporter.parameters = function(doc) {\r\n  var paramStr = doc.location.search.substring(1);\r\n  var params = [];\r\n\r\n  if (paramStr.length > 0) {\r\n    params = paramStr.split('&');\r\n  }\r\n  return params;\r\n}\r\njasmine.HtmlReporter.sectionLink = function(sectionName) {\r\n  var link = '?';\r\n  var params = [];\r\n\r\n  if (sectionName) {\r\n    params.push('spec=' + encodeURIComponent(sectionName));\r\n  }\r\n  if (!jasmine.CATCH_EXCEPTIONS) {\r\n    params.push(\"catch=false\");\r\n  }\r\n  if (params.length > 0) {\r\n    link += params.join(\"&\");\r\n  }\r\n\r\n  return link;\r\n};\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter);\r\njasmine.HtmlReporter.ReporterView = function(dom) {\r\n  this.startedAt = new Date();\r\n  this.runningSpecCount = 0;\r\n  this.completeSpecCount = 0;\r\n  this.passedCount = 0;\r\n  this.failedCount = 0;\r\n  this.skippedCount = 0;\r\n\r\n  this.createResultsMenu = function() {\r\n    this.resultsMenu = this.createDom('span', {className: 'resultsMenu bar'},\r\n      this.summaryMenuItem = this.createDom('a', {className: 'summaryMenuItem', href: \"#\"}, '0 specs'),\r\n      ' | ',\r\n      this.detailsMenuItem = this.createDom('a', {className: 'detailsMenuItem', href: \"#\"}, '0 failing'));\r\n\r\n    this.summaryMenuItem.onclick = function() {\r\n      dom.reporter.className = dom.reporter.className.replace(/ showDetails/g, '');\r\n    };\r\n\r\n    this.detailsMenuItem.onclick = function() {\r\n      showDetails();\r\n    };\r\n  };\r\n\r\n  this.addSpecs = function(specs, specFilter) {\r\n    this.totalSpecCount = specs.length;\r\n\r\n    this.views = {\r\n      specs: {},\r\n      suites: {}\r\n    };\r\n\r\n    for (var i = 0; i < specs.length; i++) {\r\n      var spec = specs[i];\r\n      this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom, this.views);\r\n      if (specFilter(spec)) {\r\n        this.runningSpecCount++;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.specComplete = function(spec) {\r\n    this.completeSpecCount++;\r\n\r\n    if (isUndefined(this.views.specs[spec.id])) {\r\n      this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom);\r\n    }\r\n\r\n    var specView = this.views.specs[spec.id];\r\n\r\n    switch (specView.status()) {\r\n      case 'passed':\r\n        this.passedCount++;\r\n        break;\r\n\r\n      case 'failed':\r\n        this.failedCount++;\r\n        break;\r\n\r\n      case 'skipped':\r\n        this.skippedCount++;\r\n        break;\r\n    }\r\n\r\n    specView.refresh();\r\n    this.refresh();\r\n  };\r\n\r\n  this.suiteComplete = function(suite) {\r\n    var suiteView = this.views.suites[suite.id];\r\n    if (isUndefined(suiteView)) {\r\n      return;\r\n    }\r\n    suiteView.refresh();\r\n  };\r\n\r\n  this.refresh = function() {\r\n\r\n    if (isUndefined(this.resultsMenu)) {\r\n      this.createResultsMenu();\r\n    }\r\n\r\n    // currently running UI\r\n    if (isUndefined(this.runningAlert)) {\r\n      this.runningAlert = this.createDom('a', { href: jasmine.HtmlReporter.sectionLink(), className: \"runningAlert bar\" });\r\n      dom.alert.appendChild(this.runningAlert);\r\n    }\r\n    this.runningAlert.innerHTML = \"Running \" + this.completeSpecCount + \" of \" + specPluralizedFor(this.totalSpecCount);\r\n\r\n    // skipped specs UI\r\n    if (isUndefined(this.skippedAlert)) {\r\n      this.skippedAlert = this.createDom('a', { href: jasmine.HtmlReporter.sectionLink(), className: \"skippedAlert bar\" });\r\n    }\r\n\r\n    this.skippedAlert.innerHTML = \"Skipping \" + this.skippedCount + \" of \" + specPluralizedFor(this.totalSpecCount) + \" - run all\";\r\n\r\n    if (this.skippedCount === 1 && isDefined(dom.alert)) {\r\n      dom.alert.appendChild(this.skippedAlert);\r\n    }\r\n\r\n    // passing specs UI\r\n    if (isUndefined(this.passedAlert)) {\r\n      this.passedAlert = this.createDom('span', { href: jasmine.HtmlReporter.sectionLink(), className: \"passingAlert bar\" });\r\n    }\r\n    this.passedAlert.innerHTML = \"Passing \" + specPluralizedFor(this.passedCount);\r\n\r\n    // failing specs UI\r\n    if (isUndefined(this.failedAlert)) {\r\n      this.failedAlert = this.createDom('span', {href: \"?\", className: \"failingAlert bar\"});\r\n    }\r\n    this.failedAlert.innerHTML = \"Failing \" + specPluralizedFor(this.failedCount);\r\n\r\n    if (this.failedCount === 1 && isDefined(dom.alert)) {\r\n      dom.alert.appendChild(this.failedAlert);\r\n      dom.alert.appendChild(this.resultsMenu);\r\n    }\r\n\r\n    // summary info\r\n    this.summaryMenuItem.innerHTML = \"\" + specPluralizedFor(this.runningSpecCount);\r\n    this.detailsMenuItem.innerHTML = \"\" + this.failedCount + \" failing\";\r\n  };\r\n\r\n  this.complete = function() {\r\n    dom.alert.removeChild(this.runningAlert);\r\n\r\n    this.skippedAlert.innerHTML = \"Ran \" + this.runningSpecCount + \" of \" + specPluralizedFor(this.totalSpecCount) + \" - run all\";\r\n\r\n    if (this.failedCount === 0) {\r\n      dom.alert.appendChild(this.createDom('span', {className: 'passingAlert bar'}, \"Passing \" + specPluralizedFor(this.passedCount)));\r\n    } else {\r\n      showDetails();\r\n    }\r\n\r\n    dom.banner.appendChild(this.createDom('span', {className: 'duration'}, \"finished in \" + ((new Date().getTime() - this.startedAt.getTime()) / 1000) + \"s\"));\r\n  };\r\n\r\n  return this;\r\n\r\n  function showDetails() {\r\n    if (dom.reporter.className.search(/showDetails/) === -1) {\r\n      dom.reporter.className += \" showDetails\";\r\n    }\r\n  }\r\n\r\n  function isUndefined(obj) {\r\n    return typeof obj === 'undefined';\r\n  }\r\n\r\n  function isDefined(obj) {\r\n    return !isUndefined(obj);\r\n  }\r\n\r\n  function specPluralizedFor(count) {\r\n    var str = count + \" spec\";\r\n    if (count > 1) {\r\n      str += \"s\"\r\n    }\r\n    return str;\r\n  }\r\n\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.ReporterView);\r\n\r\n\r\njasmine.HtmlReporter.SpecView = function(spec, dom, views) {\r\n  this.spec = spec;\r\n  this.dom = dom;\r\n  this.views = views;\r\n\r\n  this.symbol = this.createDom('li', { className: 'pending' });\r\n  this.dom.symbolSummary.appendChild(this.symbol);\r\n\r\n  this.summary = this.createDom('div', { className: 'specSummary' },\r\n    this.createDom('a', {\r\n      className: 'description',\r\n      href: jasmine.HtmlReporter.sectionLink(this.spec.getFullName()),\r\n      title: this.spec.getFullName()\r\n    }, this.spec.description)\r\n  );\r\n\r\n  this.detail = this.createDom('div', { className: 'specDetail' },\r\n      this.createDom('a', {\r\n        className: 'description',\r\n        href: '?spec=' + encodeURIComponent(this.spec.getFullName()),\r\n        title: this.spec.getFullName()\r\n      }, this.spec.getFullName())\r\n  );\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.status = function() {\r\n  return this.getSpecStatus(this.spec);\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.refresh = function() {\r\n  this.symbol.className = this.status();\r\n\r\n  switch (this.status()) {\r\n    case 'skipped':\r\n      break;\r\n\r\n    case 'passed':\r\n      this.appendSummaryToSuiteDiv();\r\n      break;\r\n\r\n    case 'failed':\r\n      this.appendSummaryToSuiteDiv();\r\n      this.appendFailureDetail();\r\n      break;\r\n  }\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.appendSummaryToSuiteDiv = function() {\r\n  this.summary.className += ' ' + this.status();\r\n  this.appendToSummary(this.spec, this.summary);\r\n};\r\n\r\njasmine.HtmlReporter.SpecView.prototype.appendFailureDetail = function() {\r\n  this.detail.className += ' ' + this.status();\r\n\r\n  var resultItems = this.spec.results().getItems();\r\n  var messagesDiv = this.createDom('div', { className: 'messages' });\r\n\r\n  for (var i = 0; i < resultItems.length; i++) {\r\n    var result = resultItems[i];\r\n\r\n    if (result.type == 'log') {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage log'}, result.toString()));\r\n    } else if (result.type == 'expect' && result.passed && !result.passed()) {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage fail'}, result.message));\r\n\r\n      if (result.trace.stack) {\r\n        messagesDiv.appendChild(this.createDom('div', {className: 'stackTrace'}, result.trace.stack));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (messagesDiv.childNodes.length > 0) {\r\n    this.detail.appendChild(messagesDiv);\r\n    this.dom.details.appendChild(this.detail);\r\n  }\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.SpecView);jasmine.HtmlReporter.SuiteView = function(suite, dom, views) {\r\n  this.suite = suite;\r\n  this.dom = dom;\r\n  this.views = views;\r\n\r\n  this.element = this.createDom('div', { className: 'suite' },\r\n    this.createDom('a', { className: 'description', href: jasmine.HtmlReporter.sectionLink(this.suite.getFullName()) }, this.suite.description)\r\n  );\r\n\r\n  this.appendToSummary(this.suite, this.element);\r\n};\r\n\r\njasmine.HtmlReporter.SuiteView.prototype.status = function() {\r\n  return this.getSpecStatus(this.suite);\r\n};\r\n\r\njasmine.HtmlReporter.SuiteView.prototype.refresh = function() {\r\n  this.element.className += \" \" + this.status();\r\n};\r\n\r\njasmine.HtmlReporterHelpers.addHelpers(jasmine.HtmlReporter.SuiteView);\r\n\r\n/* @deprecated Use jasmine.HtmlReporter instead\r\n */\r\njasmine.TrivialReporter = function(doc) {\r\n  this.document = doc || document;\r\n  this.suiteDivs = {};\r\n  this.logRunningSpecs = false;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.createDom = function(type, attrs, childrenVarArgs) {\r\n  var el = document.createElement(type);\r\n\r\n  for (var i = 2; i < arguments.length; i++) {\r\n    var child = arguments[i];\r\n\r\n    if (typeof child === 'string') {\r\n      el.appendChild(document.createTextNode(child));\r\n    } else {\r\n      if (child) { el.appendChild(child); }\r\n    }\r\n  }\r\n\r\n  for (var attr in attrs) {\r\n    if (attr == \"className\") {\r\n      el[attr] = attrs[attr];\r\n    } else {\r\n      el.setAttribute(attr, attrs[attr]);\r\n    }\r\n  }\r\n\r\n  return el;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportRunnerStarting = function(runner) {\r\n  var showPassed, showSkipped;\r\n\r\n  this.outerDiv = this.createDom('div', { id: 'TrivialReporter', className: 'jasmine_reporter' },\r\n      this.createDom('div', { className: 'banner' },\r\n        this.createDom('div', { className: 'logo' },\r\n            this.createDom('span', { className: 'title' }, \"Jasmine\"),\r\n            this.createDom('span', { className: 'version' }, runner.env.versionString())),\r\n        this.createDom('div', { className: 'options' },\r\n            \"Show \",\r\n            showPassed = this.createDom('input', { id: \"__jasmine_TrivialReporter_showPassed__\", type: 'checkbox' }),\r\n            this.createDom('label', { \"for\": \"__jasmine_TrivialReporter_showPassed__\" }, \" passed \"),\r\n            showSkipped = this.createDom('input', { id: \"__jasmine_TrivialReporter_showSkipped__\", type: 'checkbox' }),\r\n            this.createDom('label', { \"for\": \"__jasmine_TrivialReporter_showSkipped__\" }, \" skipped\")\r\n            )\r\n          ),\r\n\r\n      this.runnerDiv = this.createDom('div', { className: 'runner running' },\r\n          this.createDom('a', { className: 'run_spec', href: '?' }, \"run all\"),\r\n          this.runnerMessageSpan = this.createDom('span', {}, \"Running...\"),\r\n          this.finishedAtSpan = this.createDom('span', { className: 'finished-at' }, \"\"))\r\n      );\r\n\r\n  this.document.body.appendChild(this.outerDiv);\r\n\r\n  var suites = runner.suites();\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var suite = suites[i];\r\n    var suiteDiv = this.createDom('div', { className: 'suite' },\r\n        this.createDom('a', { className: 'run_spec', href: '?spec=' + encodeURIComponent(suite.getFullName()) }, \"run\"),\r\n        this.createDom('a', { className: 'description', href: '?spec=' + encodeURIComponent(suite.getFullName()) }, suite.description));\r\n    this.suiteDivs[suite.id] = suiteDiv;\r\n    var parentDiv = this.outerDiv;\r\n    if (suite.parentSuite) {\r\n      parentDiv = this.suiteDivs[suite.parentSuite.id];\r\n    }\r\n    parentDiv.appendChild(suiteDiv);\r\n  }\r\n\r\n  this.startedAt = new Date();\r\n\r\n  var self = this;\r\n  showPassed.onclick = function(evt) {\r\n    if (showPassed.checked) {\r\n      self.outerDiv.className += ' show-passed';\r\n    } else {\r\n      self.outerDiv.className = self.outerDiv.className.replace(/ show-passed/, '');\r\n    }\r\n  };\r\n\r\n  showSkipped.onclick = function(evt) {\r\n    if (showSkipped.checked) {\r\n      self.outerDiv.className += ' show-skipped';\r\n    } else {\r\n      self.outerDiv.className = self.outerDiv.className.replace(/ show-skipped/, '');\r\n    }\r\n  };\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportRunnerResults = function(runner) {\r\n  var results = runner.results();\r\n  var className = (results.failedCount > 0) ? \"runner failed\" : \"runner passed\";\r\n  this.runnerDiv.setAttribute(\"class\", className);\r\n  //do it twice for IE\r\n  this.runnerDiv.setAttribute(\"className\", className);\r\n  var specs = runner.specs();\r\n  var specCount = 0;\r\n  for (var i = 0; i < specs.length; i++) {\r\n    if (this.specFilter(specs[i])) {\r\n      specCount++;\r\n    }\r\n  }\r\n  var message = \"\" + specCount + \" spec\" + (specCount == 1 ? \"\" : \"s\" ) + \", \" + results.failedCount + \" failure\" + ((results.failedCount == 1) ? \"\" : \"s\");\r\n  message += \" in \" + ((new Date().getTime() - this.startedAt.getTime()) / 1000) + \"s\";\r\n  this.runnerMessageSpan.replaceChild(this.createDom('a', { className: 'description', href: '?'}, message), this.runnerMessageSpan.firstChild);\r\n\r\n  this.finishedAtSpan.appendChild(document.createTextNode(\"Finished at \" + new Date().toString()));\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSuiteResults = function(suite) {\r\n  var results = suite.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.totalCount === 0) { // todo: change this to check results.skipped\r\n    status = 'skipped';\r\n  }\r\n  this.suiteDivs[suite.id].className += \" \" + status;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSpecStarting = function(spec) {\r\n  if (this.logRunningSpecs) {\r\n    this.log('>> Jasmine Running ' + spec.suite.description + ' ' + spec.description + '...');\r\n  }\r\n};\r\n\r\njasmine.TrivialReporter.prototype.reportSpecResults = function(spec) {\r\n  var results = spec.results();\r\n  var status = results.passed() ? 'passed' : 'failed';\r\n  if (results.skipped) {\r\n    status = 'skipped';\r\n  }\r\n  var specDiv = this.createDom('div', { className: 'spec '  + status },\r\n      this.createDom('a', { className: 'run_spec', href: '?spec=' + encodeURIComponent(spec.getFullName()) }, \"run\"),\r\n      this.createDom('a', {\r\n        className: 'description',\r\n        href: '?spec=' + encodeURIComponent(spec.getFullName()),\r\n        title: spec.getFullName()\r\n      }, spec.description));\r\n\r\n\r\n  var resultItems = results.getItems();\r\n  var messagesDiv = this.createDom('div', { className: 'messages' });\r\n  for (var i = 0; i < resultItems.length; i++) {\r\n    var result = resultItems[i];\r\n\r\n    if (result.type == 'log') {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage log'}, result.toString()));\r\n    } else if (result.type == 'expect' && result.passed && !result.passed()) {\r\n      messagesDiv.appendChild(this.createDom('div', {className: 'resultMessage fail'}, result.message));\r\n\r\n      if (result.trace.stack) {\r\n        messagesDiv.appendChild(this.createDom('div', {className: 'stackTrace'}, result.trace.stack));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (messagesDiv.childNodes.length > 0) {\r\n    specDiv.appendChild(messagesDiv);\r\n  }\r\n\r\n  this.suiteDivs[spec.suite.id].appendChild(specDiv);\r\n};\r\n\r\njasmine.TrivialReporter.prototype.log = function() {\r\n  var console = jasmine.getGlobal().console;\r\n  if (console && console.log) {\r\n    if (console.log.apply) {\r\n      console.log.apply(console, arguments);\r\n    } else {\r\n      console.log(arguments); // ie fix: console.log.apply doesn't exist on ie\r\n    }\r\n  }\r\n};\r\n\r\njasmine.TrivialReporter.prototype.getLocation = function() {\r\n  return this.document.location;\r\n};\r\n\r\njasmine.TrivialReporter.prototype.specFilter = function(spec) {\r\n  var paramMap = {};\r\n  var params = this.getLocation().search.substring(1).split('&');\r\n  for (var i = 0; i < params.length; i++) {\r\n    var p = params[i].split('=');\r\n    paramMap[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n  }\r\n\r\n  if (!paramMap.spec) {\r\n    return true;\r\n  }\r\n  return spec.getFullName().indexOf(paramMap.spec) === 0;\r\n};\r\n","type":"application/javascript","title":"$:/plugins/tiddlywiki/jasmine/jasmine-html.js","module-type":"library","global-module":"true"},"$:/plugins/tiddlywiki/jasmine/jasmine.css":{"text":"body { background-color: #eeeeee; padding: 0; margin: 5px; overflow-y: scroll; }\r\n\r\n#HTMLReporter { font-size: 11px; font-family: Monaco, \"Lucida Console\", monospace; line-height: 14px; color: #333333; }\r\n#HTMLReporter a { text-decoration: none; }\r\n#HTMLReporter a:hover { text-decoration: underline; }\r\n#HTMLReporter p, #HTMLReporter h1, #HTMLReporter h2, #HTMLReporter h3, #HTMLReporter h4, #HTMLReporter h5, #HTMLReporter h6 { margin: 0; line-height: 14px; }\r\n#HTMLReporter .banner, #HTMLReporter .symbolSummary, #HTMLReporter .summary, #HTMLReporter .resultMessage, #HTMLReporter .specDetail .description, #HTMLReporter .alert .bar, #HTMLReporter .stackTrace { padding-left: 9px; padding-right: 9px; }\r\n#HTMLReporter #jasmine_content { position: fixed; right: 100%; }\r\n#HTMLReporter .version { color: #aaaaaa; }\r\n#HTMLReporter .banner { margin-top: 14px; }\r\n#HTMLReporter .duration { color: #aaaaaa; float: right; }\r\n#HTMLReporter .symbolSummary { overflow: hidden; *zoom: 1; margin: 14px 0; }\r\n#HTMLReporter .symbolSummary li { display: block; float: left; height: 7px; width: 14px; margin-bottom: 7px; font-size: 16px; }\r\n#HTMLReporter .symbolSummary li.passed { font-size: 14px; }\r\n#HTMLReporter .symbolSummary li.passed:before { color: #5e7d00; content: \"\\02022\"; }\r\n#HTMLReporter .symbolSummary li.failed { line-height: 9px; }\r\n#HTMLReporter .symbolSummary li.failed:before { color: #b03911; content: \"x\"; font-weight: bold; margin-left: -1px; }\r\n#HTMLReporter .symbolSummary li.skipped { font-size: 14px; }\r\n#HTMLReporter .symbolSummary li.skipped:before { color: #bababa; content: \"\\02022\"; }\r\n#HTMLReporter .symbolSummary li.pending { line-height: 11px; }\r\n#HTMLReporter .symbolSummary li.pending:before { color: #aaaaaa; content: \"-\"; }\r\n#HTMLReporter .exceptions { color: #fff; float: right; margin-top: 5px; margin-right: 5px; }\r\n#HTMLReporter .bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }\r\n#HTMLReporter .runningAlert { background-color: #666666; }\r\n#HTMLReporter .skippedAlert { background-color: #aaaaaa; }\r\n#HTMLReporter .skippedAlert:first-child { background-color: #333333; }\r\n#HTMLReporter .skippedAlert:hover { text-decoration: none; color: white; text-decoration: underline; }\r\n#HTMLReporter .passingAlert { background-color: #a6b779; }\r\n#HTMLReporter .passingAlert:first-child { background-color: #5e7d00; }\r\n#HTMLReporter .failingAlert { background-color: #cf867e; }\r\n#HTMLReporter .failingAlert:first-child { background-color: #b03911; }\r\n#HTMLReporter .results { margin-top: 14px; }\r\n#HTMLReporter #details { display: none; }\r\n#HTMLReporter .resultsMenu, #HTMLReporter .resultsMenu a { background-color: #fff; color: #333333; }\r\n#HTMLReporter.showDetails .summaryMenuItem { font-weight: normal; text-decoration: inherit; }\r\n#HTMLReporter.showDetails .summaryMenuItem:hover { text-decoration: underline; }\r\n#HTMLReporter.showDetails .detailsMenuItem { font-weight: bold; text-decoration: underline; }\r\n#HTMLReporter.showDetails .summary { display: none; }\r\n#HTMLReporter.showDetails #details { display: block; }\r\n#HTMLReporter .summaryMenuItem { font-weight: bold; text-decoration: underline; }\r\n#HTMLReporter .summary { margin-top: 14px; }\r\n#HTMLReporter .summary .suite .suite, #HTMLReporter .summary .specSummary { margin-left: 14px; }\r\n#HTMLReporter .summary .specSummary.passed a { color: #5e7d00; }\r\n#HTMLReporter .summary .specSummary.failed a { color: #b03911; }\r\n#HTMLReporter .description + .suite { margin-top: 0; }\r\n#HTMLReporter .suite { margin-top: 14px; }\r\n#HTMLReporter .suite a { color: #333333; }\r\n#HTMLReporter #details .specDetail { margin-bottom: 28px; }\r\n#HTMLReporter #details .specDetail .description { display: block; color: white; background-color: #b03911; }\r\n#HTMLReporter .resultMessage { padding-top: 14px; color: #333333; }\r\n#HTMLReporter .resultMessage span.result { display: block; }\r\n#HTMLReporter .stackTrace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666666; border: 1px solid #ddd; background: white; white-space: pre; }\r\n\r\n#TrivialReporter { padding: 8px 13px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; overflow-y: scroll; background-color: white; font-family: \"Helvetica Neue Light\", \"Lucida Grande\", \"Calibri\", \"Arial\", sans-serif; /*.resultMessage {*/ /*white-space: pre;*/ /*}*/ }\r\n#TrivialReporter a:visited, #TrivialReporter a { color: #303; }\r\n#TrivialReporter a:hover, #TrivialReporter a:active { color: blue; }\r\n#TrivialReporter .run_spec { float: right; padding-right: 5px; font-size: .8em; text-decoration: none; }\r\n#TrivialReporter .banner { color: #303; background-color: #fef; padding: 5px; }\r\n#TrivialReporter .logo { float: left; font-size: 1.1em; padding-left: 5px; }\r\n#TrivialReporter .logo .version { font-size: .6em; padding-left: 1em; }\r\n#TrivialReporter .runner.running { background-color: yellow; }\r\n#TrivialReporter .options { text-align: right; font-size: .8em; }\r\n#TrivialReporter .suite { border: 1px outset gray; margin: 5px 0; padding-left: 1em; }\r\n#TrivialReporter .suite .suite { margin: 5px; }\r\n#TrivialReporter .suite.passed { background-color: #dfd; }\r\n#TrivialReporter .suite.failed { background-color: #fdd; }\r\n#TrivialReporter .spec { margin: 5px; padding-left: 1em; clear: both; }\r\n#TrivialReporter .spec.failed, #TrivialReporter .spec.passed, #TrivialReporter .spec.skipped { padding-bottom: 5px; border: 1px solid gray; }\r\n#TrivialReporter .spec.failed { background-color: #fbb; border-color: red; }\r\n#TrivialReporter .spec.passed { background-color: #bfb; border-color: green; }\r\n#TrivialReporter .spec.skipped { background-color: #bbb; }\r\n#TrivialReporter .messages { border-left: 1px dashed gray; padding-left: 1em; padding-right: 1em; }\r\n#TrivialReporter .passed { background-color: #cfc; display: none; }\r\n#TrivialReporter .failed { background-color: #fbb; }\r\n#TrivialReporter .skipped { color: #777; background-color: #eee; display: none; }\r\n#TrivialReporter .resultMessage span.result { display: block; line-height: 2em; color: black; }\r\n#TrivialReporter .resultMessage .mismatch { color: black; }\r\n#TrivialReporter .stackTrace { white-space: pre; font-size: .8em; margin-left: 10px; max-height: 5em; overflow: auto; border: 1px inset red; padding: 1em; background: #eef; }\r\n#TrivialReporter .finished-at { padding-left: 1em; font-size: .6em; }\r\n#TrivialReporter.show-passed .passed, #TrivialReporter.show-skipped .skipped { display: block; }\r\n#TrivialReporter #jasmine_content { position: fixed; right: 100%; }\r\n#TrivialReporter .runner { border: 1px solid gray; display: block; margin: 5px 0; padding: 2px 0 2px 10px; }\r\n","type":"text/css","title":"$:/plugins/tiddlywiki/jasmine/jasmine.css","tags":"[[$:/tags/Stylesheet]]"},"$:/plugins/tiddlywiki/jasmine/jasmine.js":{"text":"var window = undefined; /* Prepended to the main jasmine source file to force it into commonjs mode */\nvar isCommonJS = typeof window == \"undefined\" && typeof exports == \"object\";\r\n\r\n/**\r\n * Top level namespace for Jasmine, a lightweight JavaScript BDD/spec/testing framework.\r\n *\r\n * @namespace\r\n */\r\nvar jasmine = {};\r\nif (isCommonJS) exports.jasmine = jasmine;\r\n/**\r\n * @private\r\n */\r\njasmine.unimplementedMethod_ = function() {\r\n  throw new Error(\"unimplemented method\");\r\n};\r\n\r\n/**\r\n * Use <code>jasmine.undefined</code> instead of <code>undefined</code>, since <code>undefined</code> is just\r\n * a plain old variable and may be redefined by somebody else.\r\n *\r\n * @private\r\n */\r\njasmine.undefined = jasmine.___undefined___;\r\n\r\n/**\r\n * Show diagnostic messages in the console if set to true\r\n *\r\n */\r\njasmine.VERBOSE = false;\r\n\r\n/**\r\n * Default interval in milliseconds for event loop yields (e.g. to allow network activity or to refresh the screen with the HTML-based runner). Small values here may result in slow test running. Zero means no updates until all tests have completed.\r\n *\r\n */\r\njasmine.DEFAULT_UPDATE_INTERVAL = 250;\r\n\r\n/**\r\n * Maximum levels of nesting that will be included when an object is pretty-printed\r\n */\r\njasmine.MAX_PRETTY_PRINT_DEPTH = 40;\r\n\r\n/**\r\n * Default timeout interval in milliseconds for waitsFor() blocks.\r\n */\r\njasmine.DEFAULT_TIMEOUT_INTERVAL = 5000;\r\n\r\n/**\r\n * By default exceptions thrown in the context of a test are caught by jasmine so that it can run the remaining tests in the suite.\r\n * Set to false to let the exception bubble up in the browser.\r\n *\r\n */\r\njasmine.CATCH_EXCEPTIONS = true;\r\n\r\njasmine.getGlobal = function() {\r\n  function getGlobal() {\r\n    return this;\r\n  }\r\n\r\n  return getGlobal();\r\n};\r\n\r\n/**\r\n * Allows for bound functions to be compared.  Internal use only.\r\n *\r\n * @ignore\r\n * @private\r\n * @param base {Object} bound 'this' for the function\r\n * @param name {Function} function to find\r\n */\r\njasmine.bindOriginal_ = function(base, name) {\r\n  var original = base[name];\r\n  if (original.apply) {\r\n    return function() {\r\n      return original.apply(base, arguments);\r\n    };\r\n  } else {\r\n    // IE support\r\n    return jasmine.getGlobal()[name];\r\n  }\r\n};\r\n\r\njasmine.setTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), 'setTimeout');\r\njasmine.clearTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), 'clearTimeout');\r\njasmine.setInterval = jasmine.bindOriginal_(jasmine.getGlobal(), 'setInterval');\r\njasmine.clearInterval = jasmine.bindOriginal_(jasmine.getGlobal(), 'clearInterval');\r\n\r\njasmine.MessageResult = function(values) {\r\n  this.type = 'log';\r\n  this.values = values;\r\n  this.trace = new Error(); // todo: test better\r\n};\r\n\r\njasmine.MessageResult.prototype.toString = function() {\r\n  var text = \"\";\r\n  for (var i = 0; i < this.values.length; i++) {\r\n    if (i > 0) text += \" \";\r\n    if (jasmine.isString_(this.values[i])) {\r\n      text += this.values[i];\r\n    } else {\r\n      text += jasmine.pp(this.values[i]);\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\njasmine.ExpectationResult = function(params) {\r\n  this.type = 'expect';\r\n  this.matcherName = params.matcherName;\r\n  this.passed_ = params.passed;\r\n  this.expected = params.expected;\r\n  this.actual = params.actual;\r\n  this.message = this.passed_ ? 'Passed.' : params.message;\r\n\r\n  var trace = (params.trace || new Error(this.message));\r\n  this.trace = this.passed_ ? '' : trace;\r\n};\r\n\r\njasmine.ExpectationResult.prototype.toString = function () {\r\n  return this.message;\r\n};\r\n\r\njasmine.ExpectationResult.prototype.passed = function () {\r\n  return this.passed_;\r\n};\r\n\r\n/**\r\n * Getter for the Jasmine environment. Ensures one gets created\r\n */\r\njasmine.getEnv = function() {\r\n  var env = jasmine.currentEnv_ = jasmine.currentEnv_ || new jasmine.Env();\r\n  return env;\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isArray_ = function(value) {\r\n  return jasmine.isA_(\"Array\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isString_ = function(value) {\r\n  return jasmine.isA_(\"String\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isNumber_ = function(value) {\r\n  return jasmine.isA_(\"Number\", value);\r\n};\r\n\r\n/**\r\n * @ignore\r\n * @private\r\n * @param {String} typeName\r\n * @param value\r\n * @returns {Boolean}\r\n */\r\njasmine.isA_ = function(typeName, value) {\r\n  return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\r\n};\r\n\r\n/**\r\n * Pretty printer for expecations.  Takes any object and turns it into a human-readable string.\r\n *\r\n * @param value {Object} an object to be outputted\r\n * @returns {String}\r\n */\r\njasmine.pp = function(value) {\r\n  var stringPrettyPrinter = new jasmine.StringPrettyPrinter();\r\n  stringPrettyPrinter.format(value);\r\n  return stringPrettyPrinter.string;\r\n};\r\n\r\n/**\r\n * Returns true if the object is a DOM Node.\r\n *\r\n * @param {Object} obj object to check\r\n * @returns {Boolean}\r\n */\r\njasmine.isDomNode = function(obj) {\r\n  return obj.nodeType > 0;\r\n};\r\n\r\n/**\r\n * Returns a matchable 'generic' object of the class type.  For use in expecations of type when values don't matter.\r\n *\r\n * @example\r\n * // don't care about which function is passed in, as long as it's a function\r\n * expect(mySpy).toHaveBeenCalledWith(jasmine.any(Function));\r\n *\r\n * @param {Class} clazz\r\n * @returns matchable object of the type clazz\r\n */\r\njasmine.any = function(clazz) {\r\n  return new jasmine.Matchers.Any(clazz);\r\n};\r\n\r\n/**\r\n * Returns a matchable subset of a JSON object. For use in expectations when you don't care about all of the\r\n * attributes on the object.\r\n *\r\n * @example\r\n * // don't care about any other attributes than foo.\r\n * expect(mySpy).toHaveBeenCalledWith(jasmine.objectContaining({foo: \"bar\"});\r\n *\r\n * @param sample {Object} sample\r\n * @returns matchable object for the sample\r\n */\r\njasmine.objectContaining = function (sample) {\r\n    return new jasmine.Matchers.ObjectContaining(sample);\r\n};\r\n\r\n/**\r\n * Jasmine Spies are test doubles that can act as stubs, spies, fakes or when used in an expecation, mocks.\r\n *\r\n * Spies should be created in test setup, before expectations.  They can then be checked, using the standard Jasmine\r\n * expectation syntax. Spies can be checked if they were called or not and what the calling params were.\r\n *\r\n * A Spy has the following fields: wasCalled, callCount, mostRecentCall, and argsForCall (see docs).\r\n *\r\n * Spies are torn down at the end of every spec.\r\n *\r\n * Note: Do <b>not</b> call new jasmine.Spy() directly - a spy must be created using spyOn, jasmine.createSpy or jasmine.createSpyObj.\r\n *\r\n * @example\r\n * // a stub\r\n * var myStub = jasmine.createSpy('myStub');  // can be used anywhere\r\n *\r\n * // spy example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n *\r\n * // actual foo.not will not be called, execution stops\r\n * spyOn(foo, 'not');\r\n\r\n // foo.not spied upon, execution will continue to implementation\r\n * spyOn(foo, 'not').andCallThrough();\r\n *\r\n * // fake example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n *\r\n * // foo.not(val) will return val\r\n * spyOn(foo, 'not').andCallFake(function(value) {return value;});\r\n *\r\n * // mock example\r\n * foo.not(7 == 7);\r\n * expect(foo.not).toHaveBeenCalled();\r\n * expect(foo.not).toHaveBeenCalledWith(true);\r\n *\r\n * @constructor\r\n * @see spyOn, jasmine.createSpy, jasmine.createSpyObj\r\n * @param {String} name\r\n */\r\njasmine.Spy = function(name) {\r\n  /**\r\n   * The name of the spy, if provided.\r\n   */\r\n  this.identity = name || 'unknown';\r\n  /**\r\n   *  Is this Object a spy?\r\n   */\r\n  this.isSpy = true;\r\n  /**\r\n   * The actual function this spy stubs.\r\n   */\r\n  this.plan = function() {\r\n  };\r\n  /**\r\n   * Tracking of the most recent call to the spy.\r\n   * @example\r\n   * var mySpy = jasmine.createSpy('foo');\r\n   * mySpy(1, 2);\r\n   * mySpy.mostRecentCall.args = [1, 2];\r\n   */\r\n  this.mostRecentCall = {};\r\n\r\n  /**\r\n   * Holds arguments for each call to the spy, indexed by call count\r\n   * @example\r\n   * var mySpy = jasmine.createSpy('foo');\r\n   * mySpy(1, 2);\r\n   * mySpy(7, 8);\r\n   * mySpy.mostRecentCall.args = [7, 8];\r\n   * mySpy.argsForCall[0] = [1, 2];\r\n   * mySpy.argsForCall[1] = [7, 8];\r\n   */\r\n  this.argsForCall = [];\r\n  this.calls = [];\r\n};\r\n\r\n/**\r\n * Tells a spy to call through to the actual implemenatation.\r\n *\r\n * @example\r\n * var foo = {\r\n *   bar: function() { // do some stuff }\r\n * }\r\n *\r\n * // defining a spy on an existing property: foo.bar\r\n * spyOn(foo, 'bar').andCallThrough();\r\n */\r\njasmine.Spy.prototype.andCallThrough = function() {\r\n  this.plan = this.originalValue;\r\n  return this;\r\n};\r\n\r\n/**\r\n * For setting the return value of a spy.\r\n *\r\n * @example\r\n * // defining a spy from scratch: foo() returns 'baz'\r\n * var foo = jasmine.createSpy('spy on foo').andReturn('baz');\r\n *\r\n * // defining a spy on an existing property: foo.bar() returns 'baz'\r\n * spyOn(foo, 'bar').andReturn('baz');\r\n *\r\n * @param {Object} value\r\n */\r\njasmine.Spy.prototype.andReturn = function(value) {\r\n  this.plan = function() {\r\n    return value;\r\n  };\r\n  return this;\r\n};\r\n\r\n/**\r\n * For throwing an exception when a spy is called.\r\n *\r\n * @example\r\n * // defining a spy from scratch: foo() throws an exception w/ message 'ouch'\r\n * var foo = jasmine.createSpy('spy on foo').andThrow('baz');\r\n *\r\n * // defining a spy on an existing property: foo.bar() throws an exception w/ message 'ouch'\r\n * spyOn(foo, 'bar').andThrow('baz');\r\n *\r\n * @param {String} exceptionMsg\r\n */\r\njasmine.Spy.prototype.andThrow = function(exceptionMsg) {\r\n  this.plan = function() {\r\n    throw exceptionMsg;\r\n  };\r\n  return this;\r\n};\r\n\r\n/**\r\n * Calls an alternate implementation when a spy is called.\r\n *\r\n * @example\r\n * var baz = function() {\r\n *   // do some stuff, return something\r\n * }\r\n * // defining a spy from scratch: foo() calls the function baz\r\n * var foo = jasmine.createSpy('spy on foo').andCall(baz);\r\n *\r\n * // defining a spy on an existing property: foo.bar() calls an anonymnous function\r\n * spyOn(foo, 'bar').andCall(function() { return 'baz';} );\r\n *\r\n * @param {Function} fakeFunc\r\n */\r\njasmine.Spy.prototype.andCallFake = function(fakeFunc) {\r\n  this.plan = fakeFunc;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Resets all of a spy's the tracking variables so that it can be used again.\r\n *\r\n * @example\r\n * spyOn(foo, 'bar');\r\n *\r\n * foo.bar();\r\n *\r\n * expect(foo.bar.callCount).toEqual(1);\r\n *\r\n * foo.bar.reset();\r\n *\r\n * expect(foo.bar.callCount).toEqual(0);\r\n */\r\njasmine.Spy.prototype.reset = function() {\r\n  this.wasCalled = false;\r\n  this.callCount = 0;\r\n  this.argsForCall = [];\r\n  this.calls = [];\r\n  this.mostRecentCall = {};\r\n};\r\n\r\njasmine.createSpy = function(name) {\r\n\r\n  var spyObj = function() {\r\n    spyObj.wasCalled = true;\r\n    spyObj.callCount++;\r\n    var args = jasmine.util.argsToArray(arguments);\r\n    spyObj.mostRecentCall.object = this;\r\n    spyObj.mostRecentCall.args = args;\r\n    spyObj.argsForCall.push(args);\r\n    spyObj.calls.push({object: this, args: args});\r\n    return spyObj.plan.apply(this, arguments);\r\n  };\r\n\r\n  var spy = new jasmine.Spy(name);\r\n\r\n  for (var prop in spy) {\r\n    spyObj[prop] = spy[prop];\r\n  }\r\n\r\n  spyObj.reset();\r\n\r\n  return spyObj;\r\n};\r\n\r\n/**\r\n * Determines whether an object is a spy.\r\n *\r\n * @param {jasmine.Spy|Object} putativeSpy\r\n * @returns {Boolean}\r\n */\r\njasmine.isSpy = function(putativeSpy) {\r\n  return putativeSpy && putativeSpy.isSpy;\r\n};\r\n\r\n/**\r\n * Creates a more complicated spy: an Object that has every property a function that is a spy.  Used for stubbing something\r\n * large in one call.\r\n *\r\n * @param {String} baseName name of spy class\r\n * @param {Array} methodNames array of names of methods to make spies\r\n */\r\njasmine.createSpyObj = function(baseName, methodNames) {\r\n  if (!jasmine.isArray_(methodNames) || methodNames.length === 0) {\r\n    throw new Error('createSpyObj requires a non-empty array of method names to create spies for');\r\n  }\r\n  var obj = {};\r\n  for (var i = 0; i < methodNames.length; i++) {\r\n    obj[methodNames[i]] = jasmine.createSpy(baseName + '.' + methodNames[i]);\r\n  }\r\n  return obj;\r\n};\r\n\r\n/**\r\n * All parameters are pretty-printed and concatenated together, then written to the current spec's output.\r\n *\r\n * Be careful not to leave calls to <code>jasmine.log</code> in production code.\r\n */\r\njasmine.log = function() {\r\n  var spec = jasmine.getEnv().currentSpec;\r\n  spec.log.apply(spec, arguments);\r\n};\r\n\r\n/**\r\n * Function that installs a spy on an existing object's method name.  Used within a Spec to create a spy.\r\n *\r\n * @example\r\n * // spy example\r\n * var foo = {\r\n *   not: function(bool) { return !bool; }\r\n * }\r\n * spyOn(foo, 'not'); // actual foo.not will not be called, execution stops\r\n *\r\n * @see jasmine.createSpy\r\n * @param obj\r\n * @param methodName\r\n * @return {jasmine.Spy} a Jasmine spy that can be chained with all spy methods\r\n */\r\nvar spyOn = function(obj, methodName) {\r\n  return jasmine.getEnv().currentSpec.spyOn(obj, methodName);\r\n};\r\nif (isCommonJS) exports.spyOn = spyOn;\r\n\r\n/**\r\n * Creates a Jasmine spec that will be added to the current suite.\r\n *\r\n * // TODO: pending tests\r\n *\r\n * @example\r\n * it('should be true', function() {\r\n *   expect(true).toEqual(true);\r\n * });\r\n *\r\n * @param {String} desc description of this specification\r\n * @param {Function} func defines the preconditions and expectations of the spec\r\n */\r\nvar it = function(desc, func) {\r\n  return jasmine.getEnv().it(desc, func);\r\n};\r\nif (isCommonJS) exports.it = it;\r\n\r\n/**\r\n * Creates a <em>disabled</em> Jasmine spec.\r\n *\r\n * A convenience method that allows existing specs to be disabled temporarily during development.\r\n *\r\n * @param {String} desc description of this specification\r\n * @param {Function} func defines the preconditions and expectations of the spec\r\n */\r\nvar xit = function(desc, func) {\r\n  return jasmine.getEnv().xit(desc, func);\r\n};\r\nif (isCommonJS) exports.xit = xit;\r\n\r\n/**\r\n * Starts a chain for a Jasmine expectation.\r\n *\r\n * It is passed an Object that is the actual value and should chain to one of the many\r\n * jasmine.Matchers functions.\r\n *\r\n * @param {Object} actual Actual value to test against and expected value\r\n * @return {jasmine.Matchers}\r\n */\r\nvar expect = function(actual) {\r\n  return jasmine.getEnv().currentSpec.expect(actual);\r\n};\r\nif (isCommonJS) exports.expect = expect;\r\n\r\n/**\r\n * Defines part of a jasmine spec.  Used in cominbination with waits or waitsFor in asynchrnous specs.\r\n *\r\n * @param {Function} func Function that defines part of a jasmine spec.\r\n */\r\nvar runs = function(func) {\r\n  jasmine.getEnv().currentSpec.runs(func);\r\n};\r\nif (isCommonJS) exports.runs = runs;\r\n\r\n/**\r\n * Waits a fixed time period before moving to the next block.\r\n *\r\n * @deprecated Use waitsFor() instead\r\n * @param {Number} timeout milliseconds to wait\r\n */\r\nvar waits = function(timeout) {\r\n  jasmine.getEnv().currentSpec.waits(timeout);\r\n};\r\nif (isCommonJS) exports.waits = waits;\r\n\r\n/**\r\n * Waits for the latchFunction to return true before proceeding to the next block.\r\n *\r\n * @param {Function} latchFunction\r\n * @param {String} optional_timeoutMessage\r\n * @param {Number} optional_timeout\r\n */\r\nvar waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout) {\r\n  jasmine.getEnv().currentSpec.waitsFor.apply(jasmine.getEnv().currentSpec, arguments);\r\n};\r\nif (isCommonJS) exports.waitsFor = waitsFor;\r\n\r\n/**\r\n * A function that is called before each spec in a suite.\r\n *\r\n * Used for spec setup, including validating assumptions.\r\n *\r\n * @param {Function} beforeEachFunction\r\n */\r\nvar beforeEach = function(beforeEachFunction) {\r\n  jasmine.getEnv().beforeEach(beforeEachFunction);\r\n};\r\nif (isCommonJS) exports.beforeEach = beforeEach;\r\n\r\n/**\r\n * A function that is called after each spec in a suite.\r\n *\r\n * Used for restoring any state that is hijacked during spec execution.\r\n *\r\n * @param {Function} afterEachFunction\r\n */\r\nvar afterEach = function(afterEachFunction) {\r\n  jasmine.getEnv().afterEach(afterEachFunction);\r\n};\r\nif (isCommonJS) exports.afterEach = afterEach;\r\n\r\n/**\r\n * Defines a suite of specifications.\r\n *\r\n * Stores the description and all defined specs in the Jasmine environment as one suite of specs. Variables declared\r\n * are accessible by calls to beforeEach, it, and afterEach. Describe blocks can be nested, allowing for specialization\r\n * of setup in some tests.\r\n *\r\n * @example\r\n * // TODO: a simple suite\r\n *\r\n * // TODO: a simple suite with a nested describe block\r\n *\r\n * @param {String} description A string, usually the class under test.\r\n * @param {Function} specDefinitions function that defines several specs.\r\n */\r\nvar describe = function(description, specDefinitions) {\r\n  return jasmine.getEnv().describe(description, specDefinitions);\r\n};\r\nif (isCommonJS) exports.describe = describe;\r\n\r\n/**\r\n * Disables a suite of specifications.  Used to disable some suites in a file, or files, temporarily during development.\r\n *\r\n * @param {String} description A string, usually the class under test.\r\n * @param {Function} specDefinitions function that defines several specs.\r\n */\r\nvar xdescribe = function(description, specDefinitions) {\r\n  return jasmine.getEnv().xdescribe(description, specDefinitions);\r\n};\r\nif (isCommonJS) exports.xdescribe = xdescribe;\r\n\r\n\r\n// Provide the XMLHttpRequest class for IE 5.x-6.x:\r\njasmine.XmlHttpRequest = (typeof XMLHttpRequest == \"undefined\") ? function() {\r\n  function tryIt(f) {\r\n    try {\r\n      return f();\r\n    } catch(e) {\r\n    }\r\n    return null;\r\n  }\r\n\r\n  var xhr = tryIt(function() {\r\n    return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\");\r\n  }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\");\r\n    }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Msxml2.XMLHTTP\");\r\n    }) ||\r\n    tryIt(function() {\r\n      return new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n    });\r\n\r\n  if (!xhr) throw new Error(\"This browser does not support XMLHttpRequest.\");\r\n\r\n  return xhr;\r\n} : XMLHttpRequest;\r\n/**\r\n * @namespace\r\n */\r\njasmine.util = {};\r\n\r\n/**\r\n * Declare that a child class inherit it's prototype from the parent class.\r\n *\r\n * @private\r\n * @param {Function} childClass\r\n * @param {Function} parentClass\r\n */\r\njasmine.util.inherit = function(childClass, parentClass) {\r\n  /**\r\n   * @private\r\n   */\r\n  var subclass = function() {\r\n  };\r\n  subclass.prototype = parentClass.prototype;\r\n  childClass.prototype = new subclass();\r\n};\r\n\r\njasmine.util.formatException = function(e) {\r\n  var lineNumber;\r\n  if (e.line) {\r\n    lineNumber = e.line;\r\n  }\r\n  else if (e.lineNumber) {\r\n    lineNumber = e.lineNumber;\r\n  }\r\n\r\n  var file;\r\n\r\n  if (e.sourceURL) {\r\n    file = e.sourceURL;\r\n  }\r\n  else if (e.fileName) {\r\n    file = e.fileName;\r\n  }\r\n\r\n  var message = (e.name && e.message) ? (e.name + ': ' + e.message) : e.toString();\r\n\r\n  if (file && lineNumber) {\r\n    message += ' in ' + file + ' (line ' + lineNumber + ')';\r\n  }\r\n\r\n  return message;\r\n};\r\n\r\njasmine.util.htmlEscape = function(str) {\r\n  if (!str) return str;\r\n  return str.replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n};\r\n\r\njasmine.util.argsToArray = function(args) {\r\n  var arrayOfArgs = [];\r\n  for (var i = 0; i < args.length; i++) arrayOfArgs.push(args[i]);\r\n  return arrayOfArgs;\r\n};\r\n\r\njasmine.util.extend = function(destination, source) {\r\n  for (var property in source) destination[property] = source[property];\r\n  return destination;\r\n};\r\n\r\n/**\r\n * Environment for Jasmine\r\n *\r\n * @constructor\r\n */\r\njasmine.Env = function() {\r\n  this.currentSpec = null;\r\n  this.currentSuite = null;\r\n  this.currentRunner_ = new jasmine.Runner(this);\r\n\r\n  this.reporter = new jasmine.MultiReporter();\r\n\r\n  this.updateInterval = jasmine.DEFAULT_UPDATE_INTERVAL;\r\n  this.defaultTimeoutInterval = jasmine.DEFAULT_TIMEOUT_INTERVAL;\r\n  this.lastUpdate = 0;\r\n  this.specFilter = function() {\r\n    return true;\r\n  };\r\n\r\n  this.nextSpecId_ = 0;\r\n  this.nextSuiteId_ = 0;\r\n  this.equalityTesters_ = [];\r\n\r\n  // wrap matchers\r\n  this.matchersClass = function() {\r\n    jasmine.Matchers.apply(this, arguments);\r\n  };\r\n  jasmine.util.inherit(this.matchersClass, jasmine.Matchers);\r\n\r\n  jasmine.Matchers.wrapInto_(jasmine.Matchers.prototype, this.matchersClass);\r\n};\r\n\r\n\r\njasmine.Env.prototype.setTimeout = jasmine.setTimeout;\r\njasmine.Env.prototype.clearTimeout = jasmine.clearTimeout;\r\njasmine.Env.prototype.setInterval = jasmine.setInterval;\r\njasmine.Env.prototype.clearInterval = jasmine.clearInterval;\r\n\r\n/**\r\n * @returns an object containing jasmine version build info, if set.\r\n */\r\njasmine.Env.prototype.version = function () {\r\n  if (jasmine.version_) {\r\n    return jasmine.version_;\r\n  } else {\r\n    throw new Error('Version not set');\r\n  }\r\n};\r\n\r\n/**\r\n * @returns string containing jasmine version build info, if set.\r\n */\r\njasmine.Env.prototype.versionString = function() {\r\n  if (!jasmine.version_) {\r\n    return \"version unknown\";\r\n  }\r\n\r\n  var version = this.version();\r\n  var versionString = version.major + \".\" + version.minor + \".\" + version.build;\r\n  if (version.release_candidate) {\r\n    versionString += \".rc\" + version.release_candidate;\r\n  }\r\n  versionString += \" revision \" + version.revision;\r\n  return versionString;\r\n};\r\n\r\n/**\r\n * @returns a sequential integer starting at 0\r\n */\r\njasmine.Env.prototype.nextSpecId = function () {\r\n  return this.nextSpecId_++;\r\n};\r\n\r\n/**\r\n * @returns a sequential integer starting at 0\r\n */\r\njasmine.Env.prototype.nextSuiteId = function () {\r\n  return this.nextSuiteId_++;\r\n};\r\n\r\n/**\r\n * Register a reporter to receive status updates from Jasmine.\r\n * @param {jasmine.Reporter} reporter An object which will receive status updates.\r\n */\r\njasmine.Env.prototype.addReporter = function(reporter) {\r\n  this.reporter.addReporter(reporter);\r\n};\r\n\r\njasmine.Env.prototype.execute = function() {\r\n  this.currentRunner_.execute();\r\n};\r\n\r\njasmine.Env.prototype.describe = function(description, specDefinitions) {\r\n  var suite = new jasmine.Suite(this, description, specDefinitions, this.currentSuite);\r\n\r\n  var parentSuite = this.currentSuite;\r\n  if (parentSuite) {\r\n    parentSuite.add(suite);\r\n  } else {\r\n    this.currentRunner_.add(suite);\r\n  }\r\n\r\n  this.currentSuite = suite;\r\n\r\n  var declarationError = null;\r\n  try {\r\n    specDefinitions.call(suite);\r\n  } catch(e) {\r\n    declarationError = e;\r\n  }\r\n\r\n  if (declarationError) {\r\n    this.it(\"encountered a declaration exception\", function() {\r\n      throw declarationError;\r\n    });\r\n  }\r\n\r\n  this.currentSuite = parentSuite;\r\n\r\n  return suite;\r\n};\r\n\r\njasmine.Env.prototype.beforeEach = function(beforeEachFunction) {\r\n  if (this.currentSuite) {\r\n    this.currentSuite.beforeEach(beforeEachFunction);\r\n  } else {\r\n    this.currentRunner_.beforeEach(beforeEachFunction);\r\n  }\r\n};\r\n\r\njasmine.Env.prototype.currentRunner = function () {\r\n  return this.currentRunner_;\r\n};\r\n\r\njasmine.Env.prototype.afterEach = function(afterEachFunction) {\r\n  if (this.currentSuite) {\r\n    this.currentSuite.afterEach(afterEachFunction);\r\n  } else {\r\n    this.currentRunner_.afterEach(afterEachFunction);\r\n  }\r\n\r\n};\r\n\r\njasmine.Env.prototype.xdescribe = function(desc, specDefinitions) {\r\n  return {\r\n    execute: function() {\r\n    }\r\n  };\r\n};\r\n\r\njasmine.Env.prototype.it = function(description, func) {\r\n  var spec = new jasmine.Spec(this, this.currentSuite, description);\r\n  this.currentSuite.add(spec);\r\n  this.currentSpec = spec;\r\n\r\n  if (func) {\r\n    spec.runs(func);\r\n  }\r\n\r\n  return spec;\r\n};\r\n\r\njasmine.Env.prototype.xit = function(desc, func) {\r\n  return {\r\n    id: this.nextSpecId(),\r\n    runs: function() {\r\n    }\r\n  };\r\n};\r\n\r\njasmine.Env.prototype.compareRegExps_ = function(a, b, mismatchKeys, mismatchValues) {\r\n  if (a.source != b.source)\r\n    mismatchValues.push(\"expected pattern /\" + b.source + \"/ is not equal to the pattern /\" + a.source + \"/\");\r\n\r\n  if (a.ignoreCase != b.ignoreCase)\r\n    mismatchValues.push(\"expected modifier i was\" + (b.ignoreCase ? \" \" : \" not \") + \"set and does not equal the origin modifier\");\r\n\r\n  if (a.global != b.global)\r\n    mismatchValues.push(\"expected modifier g was\" + (b.global ? \" \" : \" not \") + \"set and does not equal the origin modifier\");\r\n\r\n  if (a.multiline != b.multiline)\r\n    mismatchValues.push(\"expected modifier m was\" + (b.multiline ? \" \" : \" not \") + \"set and does not equal the origin modifier\");\r\n\r\n  if (a.sticky != b.sticky)\r\n    mismatchValues.push(\"expected modifier y was\" + (b.sticky ? \" \" : \" not \") + \"set and does not equal the origin modifier\");\r\n\r\n  return (mismatchValues.length === 0);\r\n};\r\n\r\njasmine.Env.prototype.compareObjects_ = function(a, b, mismatchKeys, mismatchValues) {\r\n  if (a.__Jasmine_been_here_before__ === b && b.__Jasmine_been_here_before__ === a) {\r\n    return true;\r\n  }\r\n\r\n  a.__Jasmine_been_here_before__ = b;\r\n  b.__Jasmine_been_here_before__ = a;\r\n\r\n  var hasKey = function(obj, keyName) {\r\n    return obj !== null && obj[keyName] !== jasmine.undefined;\r\n  };\r\n\r\n  for (var property in b) {\r\n    if (!hasKey(a, property) && hasKey(b, property)) {\r\n      mismatchKeys.push(\"expected has key '\" + property + \"', but missing from actual.\");\r\n    }\r\n  }\r\n  for (property in a) {\r\n    if (!hasKey(b, property) && hasKey(a, property)) {\r\n      mismatchKeys.push(\"expected missing key '\" + property + \"', but present in actual.\");\r\n    }\r\n  }\r\n  for (property in b) {\r\n    if (property == '__Jasmine_been_here_before__') continue;\r\n    if (!this.equals_(a[property], b[property], mismatchKeys, mismatchValues)) {\r\n      mismatchValues.push(\"'\" + property + \"' was '\" + (b[property] ? jasmine.util.htmlEscape(b[property].toString()) : b[property]) + \"' in expected, but was '\" + (a[property] ? jasmine.util.htmlEscape(a[property].toString()) : a[property]) + \"' in actual.\");\r\n    }\r\n  }\r\n\r\n  if (jasmine.isArray_(a) && jasmine.isArray_(b) && a.length != b.length) {\r\n    mismatchValues.push(\"arrays were not the same length\");\r\n  }\r\n\r\n  delete a.__Jasmine_been_here_before__;\r\n  delete b.__Jasmine_been_here_before__;\r\n  return (mismatchKeys.length === 0 && mismatchValues.length === 0);\r\n};\r\n\r\njasmine.Env.prototype.equals_ = function(a, b, mismatchKeys, mismatchValues) {\r\n  mismatchKeys = mismatchKeys || [];\r\n  mismatchValues = mismatchValues || [];\r\n\r\n  for (var i = 0; i < this.equalityTesters_.length; i++) {\r\n    var equalityTester = this.equalityTesters_[i];\r\n    var result = equalityTester(a, b, this, mismatchKeys, mismatchValues);\r\n    if (result !== jasmine.undefined) return result;\r\n  }\r\n\r\n  if (a === b) return true;\r\n\r\n  if (a === jasmine.undefined || a === null || b === jasmine.undefined || b === null) {\r\n    return (a == jasmine.undefined && b == jasmine.undefined);\r\n  }\r\n\r\n  if (jasmine.isDomNode(a) && jasmine.isDomNode(b)) {\r\n    return a === b;\r\n  }\r\n\r\n  if (a instanceof Date && b instanceof Date) {\r\n    return a.getTime() == b.getTime();\r\n  }\r\n\r\n  if (a.jasmineMatches) {\r\n    return a.jasmineMatches(b);\r\n  }\r\n\r\n  if (b.jasmineMatches) {\r\n    return b.jasmineMatches(a);\r\n  }\r\n\r\n  if (a instanceof jasmine.Matchers.ObjectContaining) {\r\n    return a.matches(b);\r\n  }\r\n\r\n  if (b instanceof jasmine.Matchers.ObjectContaining) {\r\n    return b.matches(a);\r\n  }\r\n\r\n  if (jasmine.isString_(a) && jasmine.isString_(b)) {\r\n    return (a == b);\r\n  }\r\n\r\n  if (jasmine.isNumber_(a) && jasmine.isNumber_(b)) {\r\n    return (a == b);\r\n  }\r\n\r\n  if (a instanceof RegExp && b instanceof RegExp) {\r\n    return this.compareRegExps_(a, b, mismatchKeys, mismatchValues);\r\n  }\r\n\r\n  if (typeof a === \"object\" && typeof b === \"object\") {\r\n    return this.compareObjects_(a, b, mismatchKeys, mismatchValues);\r\n  }\r\n\r\n  //Straight check\r\n  return (a === b);\r\n};\r\n\r\njasmine.Env.prototype.contains_ = function(haystack, needle) {\r\n  if (jasmine.isArray_(haystack)) {\r\n    for (var i = 0; i < haystack.length; i++) {\r\n      if (this.equals_(haystack[i], needle)) return true;\r\n    }\r\n    return false;\r\n  }\r\n  return haystack.indexOf(needle) >= 0;\r\n};\r\n\r\njasmine.Env.prototype.addEqualityTester = function(equalityTester) {\r\n  this.equalityTesters_.push(equalityTester);\r\n};\r\n/** No-op base class for Jasmine reporters.\r\n *\r\n * @constructor\r\n */\r\njasmine.Reporter = function() {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportRunnerStarting = function(runner) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportRunnerResults = function(runner) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSuiteResults = function(suite) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSpecStarting = function(spec) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.reportSpecResults = function(spec) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.Reporter.prototype.log = function(str) {\r\n};\r\n\r\n/**\r\n * Blocks are functions with executable code that make up a spec.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {Function} func\r\n * @param {jasmine.Spec} spec\r\n */\r\njasmine.Block = function(env, func, spec) {\r\n  this.env = env;\r\n  this.func = func;\r\n  this.spec = spec;\r\n};\r\n\r\njasmine.Block.prototype.execute = function(onComplete) {\r\n  if (!jasmine.CATCH_EXCEPTIONS) {\r\n    this.func.apply(this.spec);\r\n  }\r\n  else {\r\n    try {\r\n      this.func.apply(this.spec);\r\n    } catch (e) {\r\n      this.spec.fail(e);\r\n    }\r\n  }\r\n  onComplete();\r\n};\r\n/** JavaScript API reporter.\r\n *\r\n * @constructor\r\n */\r\njasmine.JsApiReporter = function() {\r\n  this.started = false;\r\n  this.finished = false;\r\n  this.suites_ = [];\r\n  this.results_ = {};\r\n};\r\n\r\njasmine.JsApiReporter.prototype.reportRunnerStarting = function(runner) {\r\n  this.started = true;\r\n  var suites = runner.topLevelSuites();\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var suite = suites[i];\r\n    this.suites_.push(this.summarize_(suite));\r\n  }\r\n};\r\n\r\njasmine.JsApiReporter.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.summarize_ = function(suiteOrSpec) {\r\n  var isSuite = suiteOrSpec instanceof jasmine.Suite;\r\n  var summary = {\r\n    id: suiteOrSpec.id,\r\n    name: suiteOrSpec.description,\r\n    type: isSuite ? 'suite' : 'spec',\r\n    children: []\r\n  };\r\n  \r\n  if (isSuite) {\r\n    var children = suiteOrSpec.children();\r\n    for (var i = 0; i < children.length; i++) {\r\n      summary.children.push(this.summarize_(children[i]));\r\n    }\r\n  }\r\n  return summary;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.results = function() {\r\n  return this.results_;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.resultsForSpec = function(specId) {\r\n  return this.results_[specId];\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportRunnerResults = function(runner) {\r\n  this.finished = true;\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportSuiteResults = function(suite) {\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.reportSpecResults = function(spec) {\r\n  this.results_[spec.id] = {\r\n    messages: spec.results().getItems(),\r\n    result: spec.results().failedCount > 0 ? \"failed\" : \"passed\"\r\n  };\r\n};\r\n\r\n//noinspection JSUnusedLocalSymbols\r\njasmine.JsApiReporter.prototype.log = function(str) {\r\n};\r\n\r\njasmine.JsApiReporter.prototype.resultsForSpecs = function(specIds){\r\n  var results = {};\r\n  for (var i = 0; i < specIds.length; i++) {\r\n    var specId = specIds[i];\r\n    results[specId] = this.summarizeResult_(this.results_[specId]);\r\n  }\r\n  return results;\r\n};\r\n\r\njasmine.JsApiReporter.prototype.summarizeResult_ = function(result){\r\n  var summaryMessages = [];\r\n  var messagesLength = result.messages.length;\r\n  for (var messageIndex = 0; messageIndex < messagesLength; messageIndex++) {\r\n    var resultMessage = result.messages[messageIndex];\r\n    summaryMessages.push({\r\n      text: resultMessage.type == 'log' ? resultMessage.toString() : jasmine.undefined,\r\n      passed: resultMessage.passed ? resultMessage.passed() : true,\r\n      type: resultMessage.type,\r\n      message: resultMessage.message,\r\n      trace: {\r\n        stack: resultMessage.passed && !resultMessage.passed() ? resultMessage.trace.stack : jasmine.undefined\r\n      }\r\n    });\r\n  }\r\n\r\n  return {\r\n    result : result.result,\r\n    messages : summaryMessages\r\n  };\r\n};\r\n\r\n/**\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param actual\r\n * @param {jasmine.Spec} spec\r\n */\r\njasmine.Matchers = function(env, actual, spec, opt_isNot) {\r\n  this.env = env;\r\n  this.actual = actual;\r\n  this.spec = spec;\r\n  this.isNot = opt_isNot || false;\r\n  this.reportWasCalled_ = false;\r\n};\r\n\r\n// todo: @deprecated as of Jasmine 0.11, remove soon [xw]\r\njasmine.Matchers.pp = function(str) {\r\n  throw new Error(\"jasmine.Matchers.pp() is no longer supported, please use jasmine.pp() instead!\");\r\n};\r\n\r\n// todo: @deprecated Deprecated as of Jasmine 0.10. Rewrite your custom matchers to return true or false. [xw]\r\njasmine.Matchers.prototype.report = function(result, failing_message, details) {\r\n  throw new Error(\"As of jasmine 0.11, custom matchers must be implemented differently -- please see jasmine docs\");\r\n};\r\n\r\njasmine.Matchers.wrapInto_ = function(prototype, matchersClass) {\r\n  for (var methodName in prototype) {\r\n    if (methodName == 'report') continue;\r\n    var orig = prototype[methodName];\r\n    matchersClass.prototype[methodName] = jasmine.Matchers.matcherFn_(methodName, orig);\r\n  }\r\n};\r\n\r\njasmine.Matchers.matcherFn_ = function(matcherName, matcherFunction) {\r\n  return function() {\r\n    var matcherArgs = jasmine.util.argsToArray(arguments);\r\n    var result = matcherFunction.apply(this, arguments);\r\n\r\n    if (this.isNot) {\r\n      result = !result;\r\n    }\r\n\r\n    if (this.reportWasCalled_) return result;\r\n\r\n    var message;\r\n    if (!result) {\r\n      if (this.message) {\r\n        message = this.message.apply(this, arguments);\r\n        if (jasmine.isArray_(message)) {\r\n          message = message[this.isNot ? 1 : 0];\r\n        }\r\n      } else {\r\n        var englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n        message = \"Expected \" + jasmine.pp(this.actual) + (this.isNot ? \" not \" : \" \") + englishyPredicate;\r\n        if (matcherArgs.length > 0) {\r\n          for (var i = 0; i < matcherArgs.length; i++) {\r\n            if (i > 0) message += \",\";\r\n            message += \" \" + jasmine.pp(matcherArgs[i]);\r\n          }\r\n        }\r\n        message += \".\";\r\n      }\r\n    }\r\n    var expectationResult = new jasmine.ExpectationResult({\r\n      matcherName: matcherName,\r\n      passed: result,\r\n      expected: matcherArgs.length > 1 ? matcherArgs : matcherArgs[0],\r\n      actual: this.actual,\r\n      message: message\r\n    });\r\n    this.spec.addMatcherResult(expectationResult);\r\n    return jasmine.undefined;\r\n  };\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n * toBe: compares the actual to the expected using ===\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toBe = function(expected) {\r\n  return this.actual === expected;\r\n};\r\n\r\n/**\r\n * toNotBe: compares the actual to the expected using !==\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toBe() instead.\r\n */\r\njasmine.Matchers.prototype.toNotBe = function(expected) {\r\n  return this.actual !== expected;\r\n};\r\n\r\n/**\r\n * toEqual: compares the actual to the expected using common sense equality. Handles Objects, Arrays, etc.\r\n *\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toEqual = function(expected) {\r\n  return this.env.equals_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * toNotEqual: compares the actual to the expected using the ! of jasmine.Matchers.toEqual\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toEqual() instead.\r\n */\r\njasmine.Matchers.prototype.toNotEqual = function(expected) {\r\n  return !this.env.equals_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to the expected using a regular expression.  Constructs a RegExp, so takes\r\n * a pattern or a String.\r\n *\r\n * @param expected\r\n */\r\njasmine.Matchers.prototype.toMatch = function(expected) {\r\n  return new RegExp(expected).test(this.actual);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to the expected using the boolean inverse of jasmine.Matchers.toMatch\r\n * @param expected\r\n * @deprecated as of 1.0. Use not.toMatch() instead.\r\n */\r\njasmine.Matchers.prototype.toNotMatch = function(expected) {\r\n  return !(new RegExp(expected).test(this.actual));\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to jasmine.undefined.\r\n */\r\njasmine.Matchers.prototype.toBeDefined = function() {\r\n  return (this.actual !== jasmine.undefined);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to jasmine.undefined.\r\n */\r\njasmine.Matchers.prototype.toBeUndefined = function() {\r\n  return (this.actual === jasmine.undefined);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to null.\r\n */\r\njasmine.Matchers.prototype.toBeNull = function() {\r\n  return (this.actual === null);\r\n};\r\n\r\n/**\r\n * Matcher that compares the actual to NaN.\r\n */\r\njasmine.Matchers.prototype.toBeNaN = function() {\r\n\tthis.message = function() {\r\n\t\treturn [ \"Expected \" + jasmine.pp(this.actual) + \" to be NaN.\" ];\r\n\t};\r\n\r\n\treturn (this.actual !== this.actual);\r\n};\r\n\r\n/**\r\n * Matcher that boolean not-nots the actual.\r\n */\r\njasmine.Matchers.prototype.toBeTruthy = function() {\r\n  return !!this.actual;\r\n};\r\n\r\n\r\n/**\r\n * Matcher that boolean nots the actual.\r\n */\r\njasmine.Matchers.prototype.toBeFalsy = function() {\r\n  return !this.actual;\r\n};\r\n\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was called.\r\n */\r\njasmine.Matchers.prototype.toHaveBeenCalled = function() {\r\n  if (arguments.length > 0) {\r\n    throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\r\n  }\r\n\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy \" + this.actual.identity + \" to have been called.\",\r\n      \"Expected spy \" + this.actual.identity + \" not to have been called.\"\r\n    ];\r\n  };\r\n\r\n  return this.actual.wasCalled;\r\n};\r\n\r\n/** @deprecated Use expect(xxx).toHaveBeenCalled() instead */\r\njasmine.Matchers.prototype.wasCalled = jasmine.Matchers.prototype.toHaveBeenCalled;\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was not called.\r\n *\r\n * @deprecated Use expect(xxx).not.toHaveBeenCalled() instead\r\n */\r\njasmine.Matchers.prototype.wasNotCalled = function() {\r\n  if (arguments.length > 0) {\r\n    throw new Error('wasNotCalled does not take arguments');\r\n  }\r\n\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy \" + this.actual.identity + \" to not have been called.\",\r\n      \"Expected spy \" + this.actual.identity + \" to have been called.\"\r\n    ];\r\n  };\r\n\r\n  return !this.actual.wasCalled;\r\n};\r\n\r\n/**\r\n * Matcher that checks to see if the actual, a Jasmine spy, was called with a set of parameters.\r\n *\r\n * @example\r\n *\r\n */\r\njasmine.Matchers.prototype.toHaveBeenCalledWith = function() {\r\n  var expectedArgs = jasmine.util.argsToArray(arguments);\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n  this.message = function() {\r\n    var invertedMessage = \"Expected spy \" + this.actual.identity + \" not to have been called with \" + jasmine.pp(expectedArgs) + \" but it was.\";\r\n    var positiveMessage = \"\";\r\n    if (this.actual.callCount === 0) {\r\n      positiveMessage = \"Expected spy \" + this.actual.identity + \" to have been called with \" + jasmine.pp(expectedArgs) + \" but it was never called.\";\r\n    } else {\r\n      positiveMessage = \"Expected spy \" + this.actual.identity + \" to have been called with \" + jasmine.pp(expectedArgs) + \" but actual calls were \" + jasmine.pp(this.actual.argsForCall).replace(/^\\[ | \\]$/g, '')\r\n    }\r\n    return [positiveMessage, invertedMessage];\r\n  };\r\n\r\n  return this.env.contains_(this.actual.argsForCall, expectedArgs);\r\n};\r\n\r\n/** @deprecated Use expect(xxx).toHaveBeenCalledWith() instead */\r\njasmine.Matchers.prototype.wasCalledWith = jasmine.Matchers.prototype.toHaveBeenCalledWith;\r\n\r\n/** @deprecated Use expect(xxx).not.toHaveBeenCalledWith() instead */\r\njasmine.Matchers.prototype.wasNotCalledWith = function() {\r\n  var expectedArgs = jasmine.util.argsToArray(arguments);\r\n  if (!jasmine.isSpy(this.actual)) {\r\n    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual) + '.');\r\n  }\r\n\r\n  this.message = function() {\r\n    return [\r\n      \"Expected spy not to have been called with \" + jasmine.pp(expectedArgs) + \" but it was\",\r\n      \"Expected spy to have been called with \" + jasmine.pp(expectedArgs) + \" but it was\"\r\n    ];\r\n  };\r\n\r\n  return !this.env.contains_(this.actual.argsForCall, expectedArgs);\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is an element in the actual Array.\r\n *\r\n * @param {Object} expected\r\n */\r\njasmine.Matchers.prototype.toContain = function(expected) {\r\n  return this.env.contains_(this.actual, expected);\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is NOT an element in the actual Array.\r\n *\r\n * @param {Object} expected\r\n * @deprecated as of 1.0. Use not.toContain() instead.\r\n */\r\njasmine.Matchers.prototype.toNotContain = function(expected) {\r\n  return !this.env.contains_(this.actual, expected);\r\n};\r\n\r\njasmine.Matchers.prototype.toBeLessThan = function(expected) {\r\n  return this.actual < expected;\r\n};\r\n\r\njasmine.Matchers.prototype.toBeGreaterThan = function(expected) {\r\n  return this.actual > expected;\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected item is equal to the actual item\r\n * up to a given level of decimal precision (default 2).\r\n *\r\n * @param {Number} expected\r\n * @param {Number} precision, as number of decimal places\r\n */\r\njasmine.Matchers.prototype.toBeCloseTo = function(expected, precision) {\r\n  if (!(precision === 0)) {\r\n    precision = precision || 2;\r\n  }\r\n  return Math.abs(expected - this.actual) < (Math.pow(10, -precision) / 2);\r\n};\r\n\r\n/**\r\n * Matcher that checks that the expected exception was thrown by the actual.\r\n *\r\n * @param {String} [expected]\r\n */\r\njasmine.Matchers.prototype.toThrow = function(expected) {\r\n  var result = false;\r\n  var exception;\r\n  if (typeof this.actual != 'function') {\r\n    throw new Error('Actual is not a function');\r\n  }\r\n  try {\r\n    this.actual();\r\n  } catch (e) {\r\n    exception = e;\r\n  }\r\n  if (exception) {\r\n    result = (expected === jasmine.undefined || this.env.equals_(exception.message || exception, expected.message || expected));\r\n  }\r\n\r\n  var not = this.isNot ? \"not \" : \"\";\r\n\r\n  this.message = function() {\r\n    if (exception && (expected === jasmine.undefined || !this.env.equals_(exception.message || exception, expected.message || expected))) {\r\n      return [\"Expected function \" + not + \"to throw\", expected ? expected.message || expected : \"an exception\", \", but it threw\", exception.message || exception].join(' ');\r\n    } else {\r\n      return \"Expected function to throw an exception.\";\r\n    }\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\njasmine.Matchers.Any = function(expectedClass) {\r\n  this.expectedClass = expectedClass;\r\n};\r\n\r\njasmine.Matchers.Any.prototype.jasmineMatches = function(other) {\r\n  if (this.expectedClass == String) {\r\n    return typeof other == 'string' || other instanceof String;\r\n  }\r\n\r\n  if (this.expectedClass == Number) {\r\n    return typeof other == 'number' || other instanceof Number;\r\n  }\r\n\r\n  if (this.expectedClass == Function) {\r\n    return typeof other == 'function' || other instanceof Function;\r\n  }\r\n\r\n  if (this.expectedClass == Object) {\r\n    return typeof other == 'object';\r\n  }\r\n\r\n  return other instanceof this.expectedClass;\r\n};\r\n\r\njasmine.Matchers.Any.prototype.jasmineToString = function() {\r\n  return '<jasmine.any(' + this.expectedClass + ')>';\r\n};\r\n\r\njasmine.Matchers.ObjectContaining = function (sample) {\r\n  this.sample = sample;\r\n};\r\n\r\njasmine.Matchers.ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {\r\n  mismatchKeys = mismatchKeys || [];\r\n  mismatchValues = mismatchValues || [];\r\n\r\n  var env = jasmine.getEnv();\r\n\r\n  var hasKey = function(obj, keyName) {\r\n    return obj != null && obj[keyName] !== jasmine.undefined;\r\n  };\r\n\r\n  for (var property in this.sample) {\r\n    if (!hasKey(other, property) && hasKey(this.sample, property)) {\r\n      mismatchKeys.push(\"expected has key '\" + property + \"', but missing from actual.\");\r\n    }\r\n    else if (!env.equals_(this.sample[property], other[property], mismatchKeys, mismatchValues)) {\r\n      mismatchValues.push(\"'\" + property + \"' was '\" + (other[property] ? jasmine.util.htmlEscape(other[property].toString()) : other[property]) + \"' in expected, but was '\" + (this.sample[property] ? jasmine.util.htmlEscape(this.sample[property].toString()) : this.sample[property]) + \"' in actual.\");\r\n    }\r\n  }\r\n\r\n  return (mismatchKeys.length === 0 && mismatchValues.length === 0);\r\n};\r\n\r\njasmine.Matchers.ObjectContaining.prototype.jasmineToString = function () {\r\n  return \"<jasmine.objectContaining(\" + jasmine.pp(this.sample) + \")>\";\r\n};\r\n// Mock setTimeout, clearTimeout\r\n// Contributed by Pivotal Computer Systems, www.pivotalsf.com\r\n\r\njasmine.FakeTimer = function() {\r\n  this.reset();\r\n\r\n  var self = this;\r\n  self.setTimeout = function(funcToCall, millis) {\r\n    self.timeoutsMade++;\r\n    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, false);\r\n    return self.timeoutsMade;\r\n  };\r\n\r\n  self.setInterval = function(funcToCall, millis) {\r\n    self.timeoutsMade++;\r\n    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, true);\r\n    return self.timeoutsMade;\r\n  };\r\n\r\n  self.clearTimeout = function(timeoutKey) {\r\n    self.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n  };\r\n\r\n  self.clearInterval = function(timeoutKey) {\r\n    self.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n  };\r\n\r\n};\r\n\r\njasmine.FakeTimer.prototype.reset = function() {\r\n  this.timeoutsMade = 0;\r\n  this.scheduledFunctions = {};\r\n  this.nowMillis = 0;\r\n};\r\n\r\njasmine.FakeTimer.prototype.tick = function(millis) {\r\n  var oldMillis = this.nowMillis;\r\n  var newMillis = oldMillis + millis;\r\n  this.runFunctionsWithinRange(oldMillis, newMillis);\r\n  this.nowMillis = newMillis;\r\n};\r\n\r\njasmine.FakeTimer.prototype.runFunctionsWithinRange = function(oldMillis, nowMillis) {\r\n  var scheduledFunc;\r\n  var funcsToRun = [];\r\n  for (var timeoutKey in this.scheduledFunctions) {\r\n    scheduledFunc = this.scheduledFunctions[timeoutKey];\r\n    if (scheduledFunc != jasmine.undefined &&\r\n        scheduledFunc.runAtMillis >= oldMillis &&\r\n        scheduledFunc.runAtMillis <= nowMillis) {\r\n      funcsToRun.push(scheduledFunc);\r\n      this.scheduledFunctions[timeoutKey] = jasmine.undefined;\r\n    }\r\n  }\r\n\r\n  if (funcsToRun.length > 0) {\r\n    funcsToRun.sort(function(a, b) {\r\n      return a.runAtMillis - b.runAtMillis;\r\n    });\r\n    for (var i = 0; i < funcsToRun.length; ++i) {\r\n      try {\r\n        var funcToRun = funcsToRun[i];\r\n        this.nowMillis = funcToRun.runAtMillis;\r\n        funcToRun.funcToCall();\r\n        if (funcToRun.recurring) {\r\n          this.scheduleFunction(funcToRun.timeoutKey,\r\n              funcToRun.funcToCall,\r\n              funcToRun.millis,\r\n              true);\r\n        }\r\n      } catch(e) {\r\n      }\r\n    }\r\n    this.runFunctionsWithinRange(oldMillis, nowMillis);\r\n  }\r\n};\r\n\r\njasmine.FakeTimer.prototype.scheduleFunction = function(timeoutKey, funcToCall, millis, recurring) {\r\n  this.scheduledFunctions[timeoutKey] = {\r\n    runAtMillis: this.nowMillis + millis,\r\n    funcToCall: funcToCall,\r\n    recurring: recurring,\r\n    timeoutKey: timeoutKey,\r\n    millis: millis\r\n  };\r\n};\r\n\r\n/**\r\n * @namespace\r\n */\r\njasmine.Clock = {\r\n  defaultFakeTimer: new jasmine.FakeTimer(),\r\n\r\n  reset: function() {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.defaultFakeTimer.reset();\r\n  },\r\n\r\n  tick: function(millis) {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.defaultFakeTimer.tick(millis);\r\n  },\r\n\r\n  runFunctionsWithinRange: function(oldMillis, nowMillis) {\r\n    jasmine.Clock.defaultFakeTimer.runFunctionsWithinRange(oldMillis, nowMillis);\r\n  },\r\n\r\n  scheduleFunction: function(timeoutKey, funcToCall, millis, recurring) {\r\n    jasmine.Clock.defaultFakeTimer.scheduleFunction(timeoutKey, funcToCall, millis, recurring);\r\n  },\r\n\r\n  useMock: function() {\r\n    if (!jasmine.Clock.isInstalled()) {\r\n      var spec = jasmine.getEnv().currentSpec;\r\n      spec.after(jasmine.Clock.uninstallMock);\r\n\r\n      jasmine.Clock.installMock();\r\n    }\r\n  },\r\n\r\n  installMock: function() {\r\n    jasmine.Clock.installed = jasmine.Clock.defaultFakeTimer;\r\n  },\r\n\r\n  uninstallMock: function() {\r\n    jasmine.Clock.assertInstalled();\r\n    jasmine.Clock.installed = jasmine.Clock.real;\r\n  },\r\n\r\n  real: {\r\n    setTimeout: jasmine.getGlobal().setTimeout,\r\n    clearTimeout: jasmine.getGlobal().clearTimeout,\r\n    setInterval: jasmine.getGlobal().setInterval,\r\n    clearInterval: jasmine.getGlobal().clearInterval\r\n  },\r\n\r\n  assertInstalled: function() {\r\n    if (!jasmine.Clock.isInstalled()) {\r\n      throw new Error(\"Mock clock is not installed, use jasmine.Clock.useMock()\");\r\n    }\r\n  },\r\n\r\n  isInstalled: function() {\r\n    return jasmine.Clock.installed == jasmine.Clock.defaultFakeTimer;\r\n  },\r\n\r\n  installed: null\r\n};\r\njasmine.Clock.installed = jasmine.Clock.real;\r\n\r\n//else for IE support\r\njasmine.getGlobal().setTimeout = function(funcToCall, millis) {\r\n  if (jasmine.Clock.installed.setTimeout.apply) {\r\n    return jasmine.Clock.installed.setTimeout.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.setTimeout(funcToCall, millis);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().setInterval = function(funcToCall, millis) {\r\n  if (jasmine.Clock.installed.setInterval.apply) {\r\n    return jasmine.Clock.installed.setInterval.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.setInterval(funcToCall, millis);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().clearTimeout = function(timeoutKey) {\r\n  if (jasmine.Clock.installed.clearTimeout.apply) {\r\n    return jasmine.Clock.installed.clearTimeout.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.clearTimeout(timeoutKey);\r\n  }\r\n};\r\n\r\njasmine.getGlobal().clearInterval = function(timeoutKey) {\r\n  if (jasmine.Clock.installed.clearTimeout.apply) {\r\n    return jasmine.Clock.installed.clearInterval.apply(this, arguments);\r\n  } else {\r\n    return jasmine.Clock.installed.clearInterval(timeoutKey);\r\n  }\r\n};\r\n\r\n/**\r\n * @constructor\r\n */\r\njasmine.MultiReporter = function() {\r\n  this.subReporters_ = [];\r\n};\r\njasmine.util.inherit(jasmine.MultiReporter, jasmine.Reporter);\r\n\r\njasmine.MultiReporter.prototype.addReporter = function(reporter) {\r\n  this.subReporters_.push(reporter);\r\n};\r\n\r\n(function() {\r\n  var functionNames = [\r\n    \"reportRunnerStarting\",\r\n    \"reportRunnerResults\",\r\n    \"reportSuiteResults\",\r\n    \"reportSpecStarting\",\r\n    \"reportSpecResults\",\r\n    \"log\"\r\n  ];\r\n  for (var i = 0; i < functionNames.length; i++) {\r\n    var functionName = functionNames[i];\r\n    jasmine.MultiReporter.prototype[functionName] = (function(functionName) {\r\n      return function() {\r\n        for (var j = 0; j < this.subReporters_.length; j++) {\r\n          var subReporter = this.subReporters_[j];\r\n          if (subReporter[functionName]) {\r\n            subReporter[functionName].apply(subReporter, arguments);\r\n          }\r\n        }\r\n      };\r\n    })(functionName);\r\n  }\r\n})();\r\n/**\r\n * Holds results for a set of Jasmine spec. Allows for the results array to hold another jasmine.NestedResults\r\n *\r\n * @constructor\r\n */\r\njasmine.NestedResults = function() {\r\n  /**\r\n   * The total count of results\r\n   */\r\n  this.totalCount = 0;\r\n  /**\r\n   * Number of passed results\r\n   */\r\n  this.passedCount = 0;\r\n  /**\r\n   * Number of failed results\r\n   */\r\n  this.failedCount = 0;\r\n  /**\r\n   * Was this suite/spec skipped?\r\n   */\r\n  this.skipped = false;\r\n  /**\r\n   * @ignore\r\n   */\r\n  this.items_ = [];\r\n};\r\n\r\n/**\r\n * Roll up the result counts.\r\n *\r\n * @param result\r\n */\r\njasmine.NestedResults.prototype.rollupCounts = function(result) {\r\n  this.totalCount += result.totalCount;\r\n  this.passedCount += result.passedCount;\r\n  this.failedCount += result.failedCount;\r\n};\r\n\r\n/**\r\n * Adds a log message.\r\n * @param values Array of message parts which will be concatenated later.\r\n */\r\njasmine.NestedResults.prototype.log = function(values) {\r\n  this.items_.push(new jasmine.MessageResult(values));\r\n};\r\n\r\n/**\r\n * Getter for the results: message & results.\r\n */\r\njasmine.NestedResults.prototype.getItems = function() {\r\n  return this.items_;\r\n};\r\n\r\n/**\r\n * Adds a result, tracking counts (total, passed, & failed)\r\n * @param {jasmine.ExpectationResult|jasmine.NestedResults} result\r\n */\r\njasmine.NestedResults.prototype.addResult = function(result) {\r\n  if (result.type != 'log') {\r\n    if (result.items_) {\r\n      this.rollupCounts(result);\r\n    } else {\r\n      this.totalCount++;\r\n      if (result.passed()) {\r\n        this.passedCount++;\r\n      } else {\r\n        this.failedCount++;\r\n      }\r\n    }\r\n  }\r\n  this.items_.push(result);\r\n};\r\n\r\n/**\r\n * @returns {Boolean} True if <b>everything</b> below passed\r\n */\r\njasmine.NestedResults.prototype.passed = function() {\r\n  return this.passedCount === this.totalCount;\r\n};\r\n/**\r\n * Base class for pretty printing for expectation results.\r\n */\r\njasmine.PrettyPrinter = function() {\r\n  this.ppNestLevel_ = 0;\r\n};\r\n\r\n/**\r\n * Formats a value in a nice, human-readable string.\r\n *\r\n * @param value\r\n */\r\njasmine.PrettyPrinter.prototype.format = function(value) {\r\n  this.ppNestLevel_++;\r\n  try {\r\n    if (value === jasmine.undefined) {\r\n      this.emitScalar('undefined');\r\n    } else if (value === null) {\r\n      this.emitScalar('null');\r\n    } else if (value === jasmine.getGlobal()) {\r\n      this.emitScalar('<global>');\r\n    } else if (value.jasmineToString) {\r\n      this.emitScalar(value.jasmineToString());\r\n    } else if (typeof value === 'string') {\r\n      this.emitString(value);\r\n    } else if (jasmine.isSpy(value)) {\r\n      this.emitScalar(\"spy on \" + value.identity);\r\n    } else if (value instanceof RegExp) {\r\n      this.emitScalar(value.toString());\r\n    } else if (typeof value === 'function') {\r\n      this.emitScalar('Function');\r\n    } else if (typeof value.nodeType === 'number') {\r\n      this.emitScalar('HTMLNode');\r\n    } else if (value instanceof Date) {\r\n      this.emitScalar('Date(' + value + ')');\r\n    } else if (value.__Jasmine_been_here_before__) {\r\n      this.emitScalar('<circular reference: ' + (jasmine.isArray_(value) ? 'Array' : 'Object') + '>');\r\n    } else if (jasmine.isArray_(value) || typeof value == 'object') {\r\n      value.__Jasmine_been_here_before__ = true;\r\n      if (jasmine.isArray_(value)) {\r\n        this.emitArray(value);\r\n      } else {\r\n        this.emitObject(value);\r\n      }\r\n      delete value.__Jasmine_been_here_before__;\r\n    } else {\r\n      this.emitScalar(value.toString());\r\n    }\r\n  } finally {\r\n    this.ppNestLevel_--;\r\n  }\r\n};\r\n\r\njasmine.PrettyPrinter.prototype.iterateObject = function(obj, fn) {\r\n  for (var property in obj) {\r\n    if (!obj.hasOwnProperty(property)) continue;\r\n    if (property == '__Jasmine_been_here_before__') continue;\r\n    fn(property, obj.__lookupGetter__ ? (obj.__lookupGetter__(property) !== jasmine.undefined && \r\n                                         obj.__lookupGetter__(property) !== null) : false);\r\n  }\r\n};\r\n\r\njasmine.PrettyPrinter.prototype.emitArray = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitObject = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitScalar = jasmine.unimplementedMethod_;\r\njasmine.PrettyPrinter.prototype.emitString = jasmine.unimplementedMethod_;\r\n\r\njasmine.StringPrettyPrinter = function() {\r\n  jasmine.PrettyPrinter.call(this);\r\n\r\n  this.string = '';\r\n};\r\njasmine.util.inherit(jasmine.StringPrettyPrinter, jasmine.PrettyPrinter);\r\n\r\njasmine.StringPrettyPrinter.prototype.emitScalar = function(value) {\r\n  this.append(value);\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitString = function(value) {\r\n  this.append(\"'\" + value + \"'\");\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitArray = function(array) {\r\n  if (this.ppNestLevel_ > jasmine.MAX_PRETTY_PRINT_DEPTH) {\r\n    this.append(\"Array\");\r\n    return;\r\n  }\r\n\r\n  this.append('[ ');\r\n  for (var i = 0; i < array.length; i++) {\r\n    if (i > 0) {\r\n      this.append(', ');\r\n    }\r\n    this.format(array[i]);\r\n  }\r\n  this.append(' ]');\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.emitObject = function(obj) {\r\n  if (this.ppNestLevel_ > jasmine.MAX_PRETTY_PRINT_DEPTH) {\r\n    this.append(\"Object\");\r\n    return;\r\n  }\r\n\r\n  var self = this;\r\n  this.append('{ ');\r\n  var first = true;\r\n\r\n  this.iterateObject(obj, function(property, isGetter) {\r\n    if (first) {\r\n      first = false;\r\n    } else {\r\n      self.append(', ');\r\n    }\r\n\r\n    self.append(property);\r\n    self.append(' : ');\r\n    if (isGetter) {\r\n      self.append('<getter>');\r\n    } else {\r\n      self.format(obj[property]);\r\n    }\r\n  });\r\n\r\n  this.append(' }');\r\n};\r\n\r\njasmine.StringPrettyPrinter.prototype.append = function(value) {\r\n  this.string += value;\r\n};\r\njasmine.Queue = function(env) {\r\n  this.env = env;\r\n\r\n  // parallel to blocks. each true value in this array means the block will\r\n  // get executed even if we abort\r\n  this.ensured = [];\r\n  this.blocks = [];\r\n  this.running = false;\r\n  this.index = 0;\r\n  this.offset = 0;\r\n  this.abort = false;\r\n};\r\n\r\njasmine.Queue.prototype.addBefore = function(block, ensure) {\r\n  if (ensure === jasmine.undefined) {\r\n    ensure = false;\r\n  }\r\n\r\n  this.blocks.unshift(block);\r\n  this.ensured.unshift(ensure);\r\n};\r\n\r\njasmine.Queue.prototype.add = function(block, ensure) {\r\n  if (ensure === jasmine.undefined) {\r\n    ensure = false;\r\n  }\r\n\r\n  this.blocks.push(block);\r\n  this.ensured.push(ensure);\r\n};\r\n\r\njasmine.Queue.prototype.insertNext = function(block, ensure) {\r\n  if (ensure === jasmine.undefined) {\r\n    ensure = false;\r\n  }\r\n\r\n  this.ensured.splice((this.index + this.offset + 1), 0, ensure);\r\n  this.blocks.splice((this.index + this.offset + 1), 0, block);\r\n  this.offset++;\r\n};\r\n\r\njasmine.Queue.prototype.start = function(onComplete) {\r\n  this.running = true;\r\n  this.onComplete = onComplete;\r\n  this.next_();\r\n};\r\n\r\njasmine.Queue.prototype.isRunning = function() {\r\n  return this.running;\r\n};\r\n\r\njasmine.Queue.LOOP_DONT_RECURSE = true;\r\n\r\njasmine.Queue.prototype.next_ = function() {\r\n  var self = this;\r\n  var goAgain = true;\r\n\r\n  while (goAgain) {\r\n    goAgain = false;\r\n    \r\n    if (self.index < self.blocks.length && !(this.abort && !this.ensured[self.index])) {\r\n      var calledSynchronously = true;\r\n      var completedSynchronously = false;\r\n\r\n      var onComplete = function () {\r\n        if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {\r\n          completedSynchronously = true;\r\n          return;\r\n        }\r\n\r\n        if (self.blocks[self.index].abort) {\r\n          self.abort = true;\r\n        }\r\n\r\n        self.offset = 0;\r\n        self.index++;\r\n\r\n        var now = new Date().getTime();\r\n        if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {\r\n          self.env.lastUpdate = now;\r\n          self.env.setTimeout(function() {\r\n            self.next_();\r\n          }, 0);\r\n        } else {\r\n          if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {\r\n            goAgain = true;\r\n          } else {\r\n            self.next_();\r\n          }\r\n        }\r\n      };\r\n      self.blocks[self.index].execute(onComplete);\r\n\r\n      calledSynchronously = false;\r\n      if (completedSynchronously) {\r\n        onComplete();\r\n      }\r\n      \r\n    } else {\r\n      self.running = false;\r\n      if (self.onComplete) {\r\n        self.onComplete();\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\njasmine.Queue.prototype.results = function() {\r\n  var results = new jasmine.NestedResults();\r\n  for (var i = 0; i < this.blocks.length; i++) {\r\n    if (this.blocks[i].results) {\r\n      results.addResult(this.blocks[i].results());\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n\r\n/**\r\n * Runner\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n */\r\njasmine.Runner = function(env) {\r\n  var self = this;\r\n  self.env = env;\r\n  self.queue = new jasmine.Queue(env);\r\n  self.before_ = [];\r\n  self.after_ = [];\r\n  self.suites_ = [];\r\n};\r\n\r\njasmine.Runner.prototype.execute = function() {\r\n  var self = this;\r\n  if (self.env.reporter.reportRunnerStarting) {\r\n    self.env.reporter.reportRunnerStarting(this);\r\n  }\r\n  self.queue.start(function () {\r\n    self.finishCallback();\r\n  });\r\n};\r\n\r\njasmine.Runner.prototype.beforeEach = function(beforeEachFunction) {\r\n  beforeEachFunction.typeName = 'beforeEach';\r\n  this.before_.splice(0,0,beforeEachFunction);\r\n};\r\n\r\njasmine.Runner.prototype.afterEach = function(afterEachFunction) {\r\n  afterEachFunction.typeName = 'afterEach';\r\n  this.after_.splice(0,0,afterEachFunction);\r\n};\r\n\r\n\r\njasmine.Runner.prototype.finishCallback = function() {\r\n  this.env.reporter.reportRunnerResults(this);\r\n};\r\n\r\njasmine.Runner.prototype.addSuite = function(suite) {\r\n  this.suites_.push(suite);\r\n};\r\n\r\njasmine.Runner.prototype.add = function(block) {\r\n  if (block instanceof jasmine.Suite) {\r\n    this.addSuite(block);\r\n  }\r\n  this.queue.add(block);\r\n};\r\n\r\njasmine.Runner.prototype.specs = function () {\r\n  var suites = this.suites();\r\n  var specs = [];\r\n  for (var i = 0; i < suites.length; i++) {\r\n    specs = specs.concat(suites[i].specs());\r\n  }\r\n  return specs;\r\n};\r\n\r\njasmine.Runner.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.Runner.prototype.topLevelSuites = function() {\r\n  var topLevelSuites = [];\r\n  for (var i = 0; i < this.suites_.length; i++) {\r\n    if (!this.suites_[i].parentSuite) {\r\n      topLevelSuites.push(this.suites_[i]);\r\n    }\r\n  }\r\n  return topLevelSuites;\r\n};\r\n\r\njasmine.Runner.prototype.results = function() {\r\n  return this.queue.results();\r\n};\r\n/**\r\n * Internal representation of a Jasmine specification, or test.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {jasmine.Suite} suite\r\n * @param {String} description\r\n */\r\njasmine.Spec = function(env, suite, description) {\r\n  if (!env) {\r\n    throw new Error('jasmine.Env() required');\r\n  }\r\n  if (!suite) {\r\n    throw new Error('jasmine.Suite() required');\r\n  }\r\n  var spec = this;\r\n  spec.id = env.nextSpecId ? env.nextSpecId() : null;\r\n  spec.env = env;\r\n  spec.suite = suite;\r\n  spec.description = description;\r\n  spec.queue = new jasmine.Queue(env);\r\n\r\n  spec.afterCallbacks = [];\r\n  spec.spies_ = [];\r\n\r\n  spec.results_ = new jasmine.NestedResults();\r\n  spec.results_.description = description;\r\n  spec.matchersClass = null;\r\n};\r\n\r\njasmine.Spec.prototype.getFullName = function() {\r\n  return this.suite.getFullName() + ' ' + this.description + '.';\r\n};\r\n\r\n\r\njasmine.Spec.prototype.results = function() {\r\n  return this.results_;\r\n};\r\n\r\n/**\r\n * All parameters are pretty-printed and concatenated together, then written to the spec's output.\r\n *\r\n * Be careful not to leave calls to <code>jasmine.log</code> in production code.\r\n */\r\njasmine.Spec.prototype.log = function() {\r\n  return this.results_.log(arguments);\r\n};\r\n\r\njasmine.Spec.prototype.runs = function (func) {\r\n  var block = new jasmine.Block(this.env, func, this);\r\n  this.addToQueue(block);\r\n  return this;\r\n};\r\n\r\njasmine.Spec.prototype.addToQueue = function (block) {\r\n  if (this.queue.isRunning()) {\r\n    this.queue.insertNext(block);\r\n  } else {\r\n    this.queue.add(block);\r\n  }\r\n};\r\n\r\n/**\r\n * @param {jasmine.ExpectationResult} result\r\n */\r\njasmine.Spec.prototype.addMatcherResult = function(result) {\r\n  this.results_.addResult(result);\r\n};\r\n\r\njasmine.Spec.prototype.expect = function(actual) {\r\n  var positive = new (this.getMatchersClass_())(this.env, actual, this);\r\n  positive.not = new (this.getMatchersClass_())(this.env, actual, this, true);\r\n  return positive;\r\n};\r\n\r\n/**\r\n * Waits a fixed time period before moving to the next block.\r\n *\r\n * @deprecated Use waitsFor() instead\r\n * @param {Number} timeout milliseconds to wait\r\n */\r\njasmine.Spec.prototype.waits = function(timeout) {\r\n  var waitsFunc = new jasmine.WaitsBlock(this.env, timeout, this);\r\n  this.addToQueue(waitsFunc);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Waits for the latchFunction to return true before proceeding to the next block.\r\n *\r\n * @param {Function} latchFunction\r\n * @param {String} optional_timeoutMessage\r\n * @param {Number} optional_timeout\r\n */\r\njasmine.Spec.prototype.waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout) {\r\n  var latchFunction_ = null;\r\n  var optional_timeoutMessage_ = null;\r\n  var optional_timeout_ = null;\r\n\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    switch (typeof arg) {\r\n      case 'function':\r\n        latchFunction_ = arg;\r\n        break;\r\n      case 'string':\r\n        optional_timeoutMessage_ = arg;\r\n        break;\r\n      case 'number':\r\n        optional_timeout_ = arg;\r\n        break;\r\n    }\r\n  }\r\n\r\n  var waitsForFunc = new jasmine.WaitsForBlock(this.env, optional_timeout_, latchFunction_, optional_timeoutMessage_, this);\r\n  this.addToQueue(waitsForFunc);\r\n  return this;\r\n};\r\n\r\njasmine.Spec.prototype.fail = function (e) {\r\n  var expectationResult = new jasmine.ExpectationResult({\r\n    passed: false,\r\n    message: e ? jasmine.util.formatException(e) : 'Exception',\r\n    trace: { stack: e.stack }\r\n  });\r\n  this.results_.addResult(expectationResult);\r\n};\r\n\r\njasmine.Spec.prototype.getMatchersClass_ = function() {\r\n  return this.matchersClass || this.env.matchersClass;\r\n};\r\n\r\njasmine.Spec.prototype.addMatchers = function(matchersPrototype) {\r\n  var parent = this.getMatchersClass_();\r\n  var newMatchersClass = function() {\r\n    parent.apply(this, arguments);\r\n  };\r\n  jasmine.util.inherit(newMatchersClass, parent);\r\n  jasmine.Matchers.wrapInto_(matchersPrototype, newMatchersClass);\r\n  this.matchersClass = newMatchersClass;\r\n};\r\n\r\njasmine.Spec.prototype.finishCallback = function() {\r\n  this.env.reporter.reportSpecResults(this);\r\n};\r\n\r\njasmine.Spec.prototype.finish = function(onComplete) {\r\n  this.removeAllSpies();\r\n  this.finishCallback();\r\n  if (onComplete) {\r\n    onComplete();\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.after = function(doAfter) {\r\n  if (this.queue.isRunning()) {\r\n    this.queue.add(new jasmine.Block(this.env, doAfter, this), true);\r\n  } else {\r\n    this.afterCallbacks.unshift(doAfter);\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.execute = function(onComplete) {\r\n  var spec = this;\r\n  if (!spec.env.specFilter(spec)) {\r\n    spec.results_.skipped = true;\r\n    spec.finish(onComplete);\r\n    return;\r\n  }\r\n\r\n  this.env.reporter.reportSpecStarting(this);\r\n\r\n  spec.env.currentSpec = spec;\r\n\r\n  spec.addBeforesAndAftersToQueue();\r\n\r\n  spec.queue.start(function () {\r\n    spec.finish(onComplete);\r\n  });\r\n};\r\n\r\njasmine.Spec.prototype.addBeforesAndAftersToQueue = function() {\r\n  var runner = this.env.currentRunner();\r\n  var i;\r\n\r\n  for (var suite = this.suite; suite; suite = suite.parentSuite) {\r\n    for (i = 0; i < suite.before_.length; i++) {\r\n      this.queue.addBefore(new jasmine.Block(this.env, suite.before_[i], this));\r\n    }\r\n  }\r\n  for (i = 0; i < runner.before_.length; i++) {\r\n    this.queue.addBefore(new jasmine.Block(this.env, runner.before_[i], this));\r\n  }\r\n  for (i = 0; i < this.afterCallbacks.length; i++) {\r\n    this.queue.add(new jasmine.Block(this.env, this.afterCallbacks[i], this), true);\r\n  }\r\n  for (suite = this.suite; suite; suite = suite.parentSuite) {\r\n    for (i = 0; i < suite.after_.length; i++) {\r\n      this.queue.add(new jasmine.Block(this.env, suite.after_[i], this), true);\r\n    }\r\n  }\r\n  for (i = 0; i < runner.after_.length; i++) {\r\n    this.queue.add(new jasmine.Block(this.env, runner.after_[i], this), true);\r\n  }\r\n};\r\n\r\njasmine.Spec.prototype.explodes = function() {\r\n  throw 'explodes function should not have been called';\r\n};\r\n\r\njasmine.Spec.prototype.spyOn = function(obj, methodName, ignoreMethodDoesntExist) {\r\n  if (obj == jasmine.undefined) {\r\n    throw \"spyOn could not find an object to spy upon for \" + methodName + \"()\";\r\n  }\r\n\r\n  if (!ignoreMethodDoesntExist && obj[methodName] === jasmine.undefined) {\r\n    throw methodName + '() method does not exist';\r\n  }\r\n\r\n  if (!ignoreMethodDoesntExist && obj[methodName] && obj[methodName].isSpy) {\r\n    throw new Error(methodName + ' has already been spied upon');\r\n  }\r\n\r\n  var spyObj = jasmine.createSpy(methodName);\r\n\r\n  this.spies_.push(spyObj);\r\n  spyObj.baseObj = obj;\r\n  spyObj.methodName = methodName;\r\n  spyObj.originalValue = obj[methodName];\r\n\r\n  obj[methodName] = spyObj;\r\n\r\n  return spyObj;\r\n};\r\n\r\njasmine.Spec.prototype.removeAllSpies = function() {\r\n  for (var i = 0; i < this.spies_.length; i++) {\r\n    var spy = this.spies_[i];\r\n    spy.baseObj[spy.methodName] = spy.originalValue;\r\n  }\r\n  this.spies_ = [];\r\n};\r\n\r\n/**\r\n * Internal representation of a Jasmine suite.\r\n *\r\n * @constructor\r\n * @param {jasmine.Env} env\r\n * @param {String} description\r\n * @param {Function} specDefinitions\r\n * @param {jasmine.Suite} parentSuite\r\n */\r\njasmine.Suite = function(env, description, specDefinitions, parentSuite) {\r\n  var self = this;\r\n  self.id = env.nextSuiteId ? env.nextSuiteId() : null;\r\n  self.description = description;\r\n  self.queue = new jasmine.Queue(env);\r\n  self.parentSuite = parentSuite;\r\n  self.env = env;\r\n  self.before_ = [];\r\n  self.after_ = [];\r\n  self.children_ = [];\r\n  self.suites_ = [];\r\n  self.specs_ = [];\r\n};\r\n\r\njasmine.Suite.prototype.getFullName = function() {\r\n  var fullName = this.description;\r\n  for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n    fullName = parentSuite.description + ' ' + fullName;\r\n  }\r\n  return fullName;\r\n};\r\n\r\njasmine.Suite.prototype.finish = function(onComplete) {\r\n  this.env.reporter.reportSuiteResults(this);\r\n  this.finished = true;\r\n  if (typeof(onComplete) == 'function') {\r\n    onComplete();\r\n  }\r\n};\r\n\r\njasmine.Suite.prototype.beforeEach = function(beforeEachFunction) {\r\n  beforeEachFunction.typeName = 'beforeEach';\r\n  this.before_.unshift(beforeEachFunction);\r\n};\r\n\r\njasmine.Suite.prototype.afterEach = function(afterEachFunction) {\r\n  afterEachFunction.typeName = 'afterEach';\r\n  this.after_.unshift(afterEachFunction);\r\n};\r\n\r\njasmine.Suite.prototype.results = function() {\r\n  return this.queue.results();\r\n};\r\n\r\njasmine.Suite.prototype.add = function(suiteOrSpec) {\r\n  this.children_.push(suiteOrSpec);\r\n  if (suiteOrSpec instanceof jasmine.Suite) {\r\n    this.suites_.push(suiteOrSpec);\r\n    this.env.currentRunner().addSuite(suiteOrSpec);\r\n  } else {\r\n    this.specs_.push(suiteOrSpec);\r\n  }\r\n  this.queue.add(suiteOrSpec);\r\n};\r\n\r\njasmine.Suite.prototype.specs = function() {\r\n  return this.specs_;\r\n};\r\n\r\njasmine.Suite.prototype.suites = function() {\r\n  return this.suites_;\r\n};\r\n\r\njasmine.Suite.prototype.children = function() {\r\n  return this.children_;\r\n};\r\n\r\njasmine.Suite.prototype.execute = function(onComplete) {\r\n  var self = this;\r\n  this.queue.start(function () {\r\n    self.finish(onComplete);\r\n  });\r\n};\r\njasmine.WaitsBlock = function(env, timeout, spec) {\r\n  this.timeout = timeout;\r\n  jasmine.Block.call(this, env, null, spec);\r\n};\r\n\r\njasmine.util.inherit(jasmine.WaitsBlock, jasmine.Block);\r\n\r\njasmine.WaitsBlock.prototype.execute = function (onComplete) {\r\n  if (jasmine.VERBOSE) {\r\n    this.env.reporter.log('>> Jasmine waiting for ' + this.timeout + ' ms...');\r\n  }\r\n  this.env.setTimeout(function () {\r\n    onComplete();\r\n  }, this.timeout);\r\n};\r\n/**\r\n * A block which waits for some condition to become true, with timeout.\r\n *\r\n * @constructor\r\n * @extends jasmine.Block\r\n * @param {jasmine.Env} env The Jasmine environment.\r\n * @param {Number} timeout The maximum time in milliseconds to wait for the condition to become true.\r\n * @param {Function} latchFunction A function which returns true when the desired condition has been met.\r\n * @param {String} message The message to display if the desired condition hasn't been met within the given time period.\r\n * @param {jasmine.Spec} spec The Jasmine spec.\r\n */\r\njasmine.WaitsForBlock = function(env, timeout, latchFunction, message, spec) {\r\n  this.timeout = timeout || env.defaultTimeoutInterval;\r\n  this.latchFunction = latchFunction;\r\n  this.message = message;\r\n  this.totalTimeSpentWaitingForLatch = 0;\r\n  jasmine.Block.call(this, env, null, spec);\r\n};\r\njasmine.util.inherit(jasmine.WaitsForBlock, jasmine.Block);\r\n\r\njasmine.WaitsForBlock.TIMEOUT_INCREMENT = 10;\r\n\r\njasmine.WaitsForBlock.prototype.execute = function(onComplete) {\r\n  if (jasmine.VERBOSE) {\r\n    this.env.reporter.log('>> Jasmine waiting for ' + (this.message || 'something to happen'));\r\n  }\r\n  var latchFunctionResult;\r\n  try {\r\n    latchFunctionResult = this.latchFunction.apply(this.spec);\r\n  } catch (e) {\r\n    this.spec.fail(e);\r\n    onComplete();\r\n    return;\r\n  }\r\n\r\n  if (latchFunctionResult) {\r\n    onComplete();\r\n  } else if (this.totalTimeSpentWaitingForLatch >= this.timeout) {\r\n    var message = 'timed out after ' + this.timeout + ' msec waiting for ' + (this.message || 'something to happen');\r\n    this.spec.fail({\r\n      name: 'timeout',\r\n      message: message\r\n    });\r\n\r\n    this.abort = true;\r\n    onComplete();\r\n  } else {\r\n    this.totalTimeSpentWaitingForLatch += jasmine.WaitsForBlock.TIMEOUT_INCREMENT;\r\n    var self = this;\r\n    this.env.setTimeout(function() {\r\n      self.execute(onComplete);\r\n    }, jasmine.WaitsForBlock.TIMEOUT_INCREMENT);\r\n  }\r\n};\r\n\r\njasmine.version_= {\r\n  \"major\": 1,\r\n  \"minor\": 3,\r\n  \"build\": 1,\r\n  \"revision\": 1354556913\r\n};\r\n","type":"application/javascript","title":"$:/plugins/tiddlywiki/jasmine/jasmine.js","module-type":"library"},"$:/plugins/tiddlywiki/jasmine/reporter.js":{"text":"(function() {\r\n  //\r\n  // Imports\r\n  //\r\n  var util;\r\n  try {\r\n    util = require('util')\r\n  } catch(e) {\r\n    util = require('sys')\r\n  }\r\n\r\n  var jasmineNode = {};\r\n  //\r\n  // Helpers\r\n  //\r\n  function noop() {}\r\n\r\n\r\n  jasmineNode.TerminalReporter = function(config) {\r\n    this.print_ = config.print || util.print;\r\n    this.color_ = config.color ? this.ANSIColors : this.NoColors;\r\n\r\n    this.started_ = false;\r\n    this.finished_ = false;\r\n\r\n    this.callback_ = config.onComplete || false\r\n\r\n    this.suites_ = [];\r\n    this.specResults_ = {};\r\n    this.failures_ = [];\r\n    this.includeStackTrace_ = config.includeStackTrace === false ? false : true;\r\n  }\r\n\r\n\r\n  jasmineNode.TerminalReporter.prototype = {\r\n    reportRunnerStarting: function(runner) {\r\n      this.started_ = true;\r\n      this.startedAt = new Date();\r\n      var suites = runner.topLevelSuites();\r\n      for (var i = 0; i < suites.length; i++) {\r\n        var suite = suites[i];\r\n        this.suites_.push(this.summarize_(suite));\r\n      }\r\n    },\r\n\r\n    ANSIColors: {\r\n        pass:    function() { return '\\033[32m'; }, // Green\r\n        fail:    function() { return '\\033[31m'; }, // Red\r\n        neutral: function() { return '\\033[0m';  }  // Normal\r\n    },\r\n\r\n    NoColors: {\r\n        pass:    function() { return ''; },\r\n        fail:    function() { return ''; },\r\n        neutral: function() { return ''; }\r\n    },\r\n\r\n    summarize_: function(suiteOrSpec) {\r\n      var isSuite = suiteOrSpec instanceof jasmine.Suite;\r\n\r\n      // We could use a separate object for suite and spec\r\n      var summary = {\r\n        id: suiteOrSpec.id,\r\n        name: suiteOrSpec.description,\r\n        type: isSuite? 'suite' : 'spec',\r\n        suiteNestingLevel: 0,\r\n        children: []\r\n      };\r\n\r\n      if (isSuite) {\r\n        var calculateNestingLevel = function(examinedSuite) {\r\n          var nestingLevel = 0;\r\n          while (examinedSuite.parentSuite !== null) {\r\n            nestingLevel += 1;\r\n            examinedSuite = examinedSuite.parentSuite;\r\n          }\r\n          return nestingLevel;\r\n        };\r\n\r\n        summary.suiteNestingLevel = calculateNestingLevel(suiteOrSpec);\r\n\r\n        var children = suiteOrSpec.children();\r\n        for (var i = 0; i < children.length; i++) {\r\n          summary.children.push(this.summarize_(children[i]));\r\n        }\r\n      }\r\n\r\n      return summary;\r\n    },\r\n\r\n    // This is heavily influenced by Jasmine's Html/Trivial Reporter\r\n    reportRunnerResults: function(runner) {\r\n      this.reportFailures_();\r\n\r\n      var results = runner.results();\r\n      var resultColor = (results.failedCount > 0) ? this.color_.fail() : this.color_.pass();\r\n\r\n      var specs = runner.specs();\r\n      var specCount = specs.length;\r\n\r\n      var message = \"\\n\\nFinished in \" + ((new Date().getTime() - this.startedAt.getTime()) / 1000) + \" seconds\";\r\n      this.printLine_(message);\r\n\r\n      // This is what jasmine-html.js has\r\n      //message = \"\" + specCount + \" spec\" + ( specCount === 1 ? \"\" : \"s\" ) + \", \" + results.failedCount + \" failure\" + ((results.failedCount === 1) ? \"\" : \"s\");\r\n\r\n      this.printLine_(this.stringWithColor_(this.printRunnerResults_(runner), resultColor));\r\n\r\n      this.finished_ = true;\r\n      if(this.callback_) { this.callback_(runner); }\r\n    },\r\n\r\n    reportFailures_: function() {\r\n      if (this.failures_.length === 0) {\r\n        return;\r\n      }\r\n\r\n      var indent = '  ', failure;\r\n      this.printLine_('\\n');\r\n\r\n      this.print_('Failures:');\r\n\r\n      for (var i = 0; i < this.failures_.length; i++) {\r\n        failure = this.failures_[i];\r\n        this.printLine_('\\n');\r\n        this.printLine_('  ' + (i + 1) + ') ' + failure.spec);\r\n        this.printLine_('   Message:');\r\n        this.printLine_('     ' + this.stringWithColor_(failure.message, this.color_.fail()));\r\n        if (this.includeStackTrace_) {\r\n            this.printLine_('   Stacktrace:');\r\n            this.print_('     ' + failure.stackTrace);\r\n        }\r\n      }\r\n    },\r\n\r\n    reportSuiteResults: function(suite) {\r\n      // Not used in this context\r\n    },\r\n\r\n    reportSpecResults: function(spec) {\r\n      var result = spec.results();\r\n      var msg = '';\r\n      if (result.passed()) {\r\n        msg = this.stringWithColor_('.', this.color_.pass());\r\n        //      } else if (result.skipped) {  TODO: Research why \"result.skipped\" returns false when \"xit\" is called on a spec?\r\n        //        msg = (colors) ? (ansi.yellow + '*' + ansi.none) : '*';\r\n      } else {\r\n        msg = this.stringWithColor_('F', this.color_.fail());\r\n        this.addFailureToFailures_(spec);\r\n      }\r\n      this.spec_results += msg;\r\n      this.print_(msg);\r\n    },\r\n\r\n    addFailureToFailures_: function(spec) {\r\n      var result = spec.results();\r\n      var failureItem = null;\r\n\r\n      var items_length = result.items_.length;\r\n      for (var i = 0; i < items_length; i++) {\r\n        if (result.items_[i].passed_ === false) {\r\n          failureItem = result.items_[i];\r\n\r\n          var failure = {\r\n            spec: spec.suite.getFullName() + \" \" + spec.description,\r\n            message: failureItem.message,\r\n            stackTrace: failureItem.trace.stack\r\n          }\r\n\r\n          this.failures_.push(failure);\r\n        }\r\n      }\r\n    },\r\n\r\n    printRunnerResults_: function(runner){\r\n      var results = runner.results();\r\n      var specs = runner.specs();\r\n      var msg = '';\r\n      msg += specs.length + ' test' + ((specs.length === 1) ? '' : 's') + ', ';\r\n      msg += results.totalCount + ' assertion' + ((results.totalCount === 1) ? '' : 's') + ', ';\r\n      msg += results.failedCount + ' failure' + ((results.failedCount === 1) ? '' : 's') + '\\n';\r\n      return msg;\r\n    },\r\n\r\n      // Helper Methods //\r\n    stringWithColor_: function(stringValue, color) {\r\n      return (color || this.color_.neutral()) + stringValue + this.color_.neutral();\r\n    },\r\n\r\n    printLine_: function(stringValue) {\r\n      this.print_(stringValue);\r\n      this.print_('\\n');\r\n    }\r\n  };\r\n\r\n  // ***************************************************************\r\n  // TerminalVerboseReporter uses the TerminalReporter's constructor\r\n  // ***************************************************************\r\n  jasmineNode.TerminalVerboseReporter = function(config) {\r\n    jasmineNode.TerminalReporter.call(this, config);\r\n    // The extra field in this object\r\n    this.indent_ = 0;\r\n  }\r\n\r\n\r\n  jasmineNode.TerminalVerboseReporter.prototype = {\r\n    reportSpecResults: function(spec) {\r\n      if (spec.results().failedCount > 0) {\r\n        this.addFailureToFailures_(spec);\r\n      }\r\n\r\n      this.specResults_[spec.id] = {\r\n        messages: spec.results().getItems(),\r\n        result: spec.results().failedCount > 0 ? 'failed' : 'passed'\r\n      };\r\n    },\r\n\r\n    reportRunnerResults: function(runner) {\r\n      var messages = new Array();\r\n      this.buildMessagesFromResults_(messages, this.suites_);\r\n\r\n      var messages_length = messages.length;\r\n      for (var i = 0; i < messages_length-1; i++) {\r\n        this.printLine_(messages[i]);\r\n      }\r\n\r\n      this.print_(messages[messages_length-1]);\r\n\r\n      // Call the parent object's method\r\n      jasmineNode.TerminalReporter.prototype.reportRunnerResults.call(this, runner);\r\n    },\r\n\r\n    buildMessagesFromResults_: function(messages, results, depth) {\r\n      var element, specResult, specIndentSpaces, msg = '';\r\n      depth = (depth === undefined) ? 0 : depth;\r\n\r\n      var results_length = results.length;\r\n      for (var i = 0; i < results_length; i++) {\r\n        element = results[i];\r\n\r\n        if (element.type === 'spec') {\r\n          specResult = this.specResults_[element.id.toString()];\r\n\r\n          if (specResult.result === 'passed') {\r\n            msg = this.stringWithColor_(this.indentMessage_(element.name, depth), this.color_.pass());\r\n          } else {\r\n            msg = this.stringWithColor_(this.indentMessage_(element.name, depth), this.color_.fail());\r\n          }\r\n\r\n          messages.push(msg);\r\n        } else {\r\n          messages.push('');\r\n          messages.push(this.indentMessage_(element.name, depth));\r\n        }\r\n\r\n        this.buildMessagesFromResults_(messages, element.children, depth + 2);\r\n      }\r\n    },\r\n\r\n    indentMessage_: function(message, indentCount) {\r\n      var _indent = '';\r\n      for (var i = 0; i < indentCount; i++) {\r\n        _indent += '  ';\r\n      }\r\n      return (_indent + message);\r\n    }\r\n  };\r\n\r\n  // Inherit from TerminalReporter\r\n  jasmineNode.TerminalVerboseReporter.prototype.__proto__ = jasmineNode.TerminalReporter.prototype;\r\n\r\n  //\r\n  // Exports\r\n  //\r\n  exports.jasmineNode = jasmineNode;\r\n})();\r\n","type":"application/javascript","title":"$:/plugins/tiddlywiki/jasmine/reporter.js","module-type":"library"},"$:/plugins/tiddlywiki/jasmine/jasmine-plugin.js":{"title":"$:/plugins/tiddlywiki/jasmine/jasmine-plugin.js","text":"/*\\\r\ntitle: $:/plugins/tiddlywiki/jasmine/jasmine-plugin.js\r\ntype: application/javascript\r\nmodule-type: startup\r\n\r\nThe main module of the Jasmine test plugin for TiddlyWiki5\r\n\r\n\\*/\r\n(function(){\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n\r\nvar TEST_TIDDLER_FILTER = \"[type[application/javascript]tag[$:/tags/test-spec]]\";\r\n\r\n/*\r\nStartup function for running tests\r\n*/\r\nexports.startup = function() {\r\n\t// Get the Jasmine exports\r\n\tvar jasmine = $tw.modules.execute(\"$:/plugins/tiddlywiki/jasmine/jasmine.js\");\r\n\t// Add our other context variables\r\n\tvar context = $tw.utils.extend({},jasmine,{\r\n\t\t\tconsole: console,\r\n\t\t\tsetInterval: setInterval,\r\n\t\t\tclearInterval: clearInterval,\r\n\t\t\tsetTimeout: setTimeout,\r\n\t\t\tclearTimeout: clearTimeout,\r\n\t\t\texports: {},\r\n\t\t\t$tw: $tw\r\n\t});\r\n\t// Prepare the Jasmine environment\r\n\tvar jasmineEnv = jasmine.jasmine.getEnv();\r\n\tjasmineEnv.updateInterval = 1000;\r\n\t// Execute the appropriate reporter\r\n\tvar reporterTitle = $tw.browser ? \"$:/plugins/tiddlywiki/jasmine/jasmine-html.js\" : \"$:/plugins/tiddlywiki/jasmine/reporter.js\";\r\n\tcontext.require = function(moduleTitle) {\r\n\t\treturn $tw.modules.execute(moduleTitle,reporterTitle);\r\n\t};\r\n\tvar code = $tw.wiki.getTiddlerText(reporterTitle,\"\"),\r\n\t\treporterExports = $tw.utils.evalSandboxed(code,context,reporterTitle);\r\n\t// Link the reporter into jasmine\r\n\tif($tw.browser) {\r\n\t\tvar htmlReporter = new jasmine.jasmine.HtmlReporter();\r\n\t\tjasmineEnv.addReporter(htmlReporter);\r\n\t\tjasmineEnv.specFilter = function(spec) {\r\n\t\t\treturn htmlReporter.specFilter(spec);\r\n\t\t};\r\n\t} else {\r\n\t\t// The HTMLReporter links itself into the jasmine object automatically, but we have to manually add the node reporter\r\n\t\tjasmine.jasmine.TerminalVerboseReporter = reporterExports.jasmineNode.TerminalVerboseReporter;\r\n\t\tjasmine.jasmine.TerminalReporter = reporterExports.jasmineNode.TerminalReporter;\r\n\t\tjasmineEnv.addReporter(new jasmine.jasmine.TerminalVerboseReporter({\r\n\t\t\tprint: require(\"util\").print,\r\n\t\t\tcolor: true,\r\n\t\t\tincludeStackTrace: true\r\n\t\t}));\r\n\t}\r\n\t// Iterate through all the test modules\r\n\tvar tests = $tw.wiki.filterTiddlers(TEST_TIDDLER_FILTER);\r\n\t$tw.utils.each(tests,function(title,index) {\r\n\t\t// Get the test specification code\r\n\t\tvar code = $tw.wiki.getTiddlerText(title,\"\");\r\n\t\t// Add a require handler\r\n\t\tcontext.require = function(moduleTitle) {\r\n\t\t\treturn $tw.modules.execute(moduleTitle,title);\r\n\t\t};\r\n\t\t// Execute the test code with the context variables\r\n\t\t$tw.utils.evalSandboxed(code,context,title);\r\n\t});\r\n\t// Execute the tests\r\n\tjasmineEnv.execute();\r\n};\r\n\r\n})();\r\n","type":"application/javascript","module-type":"startup"},"$:/plugins/tiddlywiki/jasmine/readme":{"title":"$:/plugins/tiddlywiki/jasmine/readme","text":"This plugin provides a framework for running tests in the browser and under Node.js. It is based on [[Jasmine|http://pivotal.github.io/jasmine/]] test framework.\n\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/jasmine]]\r\n"}}}