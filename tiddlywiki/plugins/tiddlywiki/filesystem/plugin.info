{"title":"$:/plugins/tiddlywiki/filesystem","description":"Local filesystem syncadaptor","author":"JeremyRuston","core-version":">=5.0.0","list":"readme","version":"5.1.17","plugin-type":"plugin","dependents":"","type":"application/json","tiddlers":{"$:/plugins/tiddlywiki/filesystem/filesystemadaptor.js":{"title":"$:/plugins/tiddlywiki/filesystem/filesystemadaptor.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/filesystem/filesystemadaptor.js\ntype: application/javascript\nmodule-type: syncadaptor\n\nA sync adaptor module for synchronising with the local filesystem via node.js APIs\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Get a reference to the file system\nvar fs = $tw.node ? require(\"fs\") : null,\n\tpath = $tw.node ? require(\"path\") : null;\n\nfunction FileSystemAdaptor(options) {\n\tvar self = this;\n\tthis.wiki = options.wiki;\n\tthis.logger = new $tw.utils.Logger(\"filesystem\",{colour: \"blue\"});\n\t// Create the <wiki>/tiddlers folder if it doesn't exist\n\t$tw.utils.createDirectory($tw.boot.wikiTiddlersPath);\n}\n\nFileSystemAdaptor.prototype.name = \"filesystem\";\n\nFileSystemAdaptor.prototype.isReady = function() {\n\t// The file system adaptor is always ready\n\treturn true;\n};\n\nFileSystemAdaptor.prototype.getTiddlerInfo = function(tiddler) {\n\treturn {};\n};\n\n/*\nReturn a fileInfo object for a tiddler, creating it if necessary:\n  filepath: the absolute path to the file containing the tiddler\n  type: the type of the tiddler file (NOT the type of the tiddler -- see below)\n  hasMetaFile: true if the file also has a companion .meta file\n\nThe boot process populates $tw.boot.files for each of the tiddler files that it loads. The type is found by looking up the extension in $tw.config.fileExtensionInfo (eg \"application/x-tiddler\" for \".tid\" files).\n\nIt is the responsibility of the filesystem adaptor to update $tw.boot.files for new files that are created.\n*/\nFileSystemAdaptor.prototype.getTiddlerFileInfo = function(tiddler,callback) {\n\t// See if we've already got information about this file\n\tvar self = this,\n\t\ttitle = tiddler.fields.title,\n\t\tfileInfo = $tw.boot.files[title];\n\tif(fileInfo) {\n\t\t// If so, just invoke the callback\n\t\tcallback(null,fileInfo);\n\t} else {\n\t\t// Otherwise, we'll need to generate it\n\t\tfileInfo = {};\n\t\tvar tiddlerType = tiddler.fields.type || \"text/vnd.tiddlywiki\";\n\t\t// Get the content type info\n\t\tvar contentTypeInfo = $tw.config.contentTypeInfo[tiddlerType] || {};\n\t\t// Get the file type by looking up the extension\n\t\tvar extension = contentTypeInfo.extension || \".tid\";\n\t\tfileInfo.type = ($tw.config.fileExtensionInfo[extension] || {type: \"application/x-tiddler\"}).type;\n\t\t// Use a .meta file unless we're saving a .tid file.\n\t\t// (We would need more complex logic if we supported other template rendered tiddlers besides .tid)\n\t\tfileInfo.hasMetaFile = (fileInfo.type !== \"application/x-tiddler\") && (fileInfo.type !== \"application/json\");\n\t\tif(!fileInfo.hasMetaFile) {\n\t\t\textension = \".tid\";\n\t\t}\n\t\t// Generate the base filepath and ensure the directories exist\n\t\tvar baseFilepath = path.resolve($tw.boot.wikiTiddlersPath,this.generateTiddlerBaseFilepath(title));\n\t\t$tw.utils.createFileDirectories(baseFilepath);\n\t\t// Start by getting a list of the existing files in the directory\n\t\tfs.readdir(path.dirname(baseFilepath),function(err,files) {\n\t\t\tif(err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\t// Start with the base filename plus the extension\n\t\t\tvar filepath = baseFilepath;\n\t\t\tif(filepath.substr(-extension.length).toLocaleLowerCase() !== extension.toLocaleLowerCase()) {\n\t\t\t\tfilepath = filepath + extension;\n\t\t\t}\n\t\t\tvar filename = path.basename(filepath),\n\t\t\t\tcount = 1;\n\t\t\t// Add a discriminator if we're clashing with an existing filename while\n\t\t\t// handling case-insensitive filesystems (NTFS, FAT/FAT32, etc.)\n\t\t\twhile(files.some(function(value) {return value.toLocaleLowerCase() === filename.toLocaleLowerCase();})) {\n\t\t\t\tfilepath = baseFilepath + \" \" + (count++) + extension;\n\t\t\t\tfilename = path.basename(filepath);\n\t\t\t}\n\t\t\t// Set the final fileInfo\n\t\t\tfileInfo.filepath = filepath;\nconsole.log(\"\\x1b[1;35m\" + \"For \" + title + \", type is \" + fileInfo.type + \" hasMetaFile is \" + fileInfo.hasMetaFile + \" filepath is \" + fileInfo.filepath + \"\\x1b[0m\");\n\t\t\t$tw.boot.files[title] = fileInfo;\n\t\t\t// Pass it to the callback\n\t\t\tcallback(null,fileInfo);\n\t\t});\n\t}\n};\n\n/*\nGiven a list of filters, apply every one in turn to source, and return the first result of the first filter with non-empty result.\n*/\nFileSystemAdaptor.prototype.findFirstFilter = function(filters,source) {\n\tfor(var i=0; i<filters.length; i++) {\n\t\tvar result = this.wiki.filterTiddlers(filters[i],null,source);\n\t\tif(result.length > 0) {\n\t\t\treturn result[0];\n\t\t}\n\t}\n\treturn null;\n};\n\n/*\nGiven a tiddler title and an array of existing filenames, generate a new legal filename for the title, case insensitively avoiding the array of existing filenames\n*/\nFileSystemAdaptor.prototype.generateTiddlerBaseFilepath = function(title) {\n\tvar baseFilename;\n\t// Check whether the user has configured a tiddler -> pathname mapping\n\tvar pathNameFilters = this.wiki.getTiddlerText(\"$:/config/FileSystemPaths\");\n\tif(pathNameFilters) {\n\t\tvar source = this.wiki.makeTiddlerIterator([title]);\n\t\tbaseFilename = this.findFirstFilter(pathNameFilters.split(\"\\n\"),source);\n\t\tif(baseFilename) {\n\t\t\t// Interpret \"/\" and \"\\\" as path separator\n\t\t\tbaseFilename = baseFilename.replace(/\\/|\\\\/g,path.sep);\n\t\t}\n\t}\n\tif(!baseFilename) {\n\t\t// No mappings provided, or failed to match this tiddler so we use title as filename\n\t\tbaseFilename = title.replace(/\\/|\\\\/g,\"_\");\n\t}\n\t// Remove any of the characters that are illegal in Windows filenames\n\tvar baseFilename = $tw.utils.transliterate(baseFilename.replace(/<|>|\\:|\\\"|\\||\\?|\\*|\\^/g,\"_\"));\n\t// Truncate the filename if it is too long\n\tif(baseFilename.length > 200) {\n\t\tbaseFilename = baseFilename.substr(0,200);\n\t}\n\treturn baseFilename;\n};\n\n/*\nSave a tiddler and invoke the callback with (err,adaptorInfo,revision)\n*/\nFileSystemAdaptor.prototype.saveTiddler = function(tiddler,callback) {\n\tvar self = this;\n\tthis.getTiddlerFileInfo(tiddler,function(err,fileInfo) {\n\t\tif(err) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tvar filepath = fileInfo.filepath,\n\t\t\terror = $tw.utils.createDirectory(path.dirname(filepath));\n\t\tif(error) {\n\t\t\treturn callback(error);\n\t\t}\n\t\tif(fileInfo.hasMetaFile) {\n\t\t\t// Save the tiddler as a separate body and meta file\n\t\t\tvar typeInfo = $tw.config.contentTypeInfo[tiddler.fields.type || \"text/plain\"] || {encoding: \"utf8\"};\n\t\t\tfs.writeFile(filepath,tiddler.fields.text,{encoding: typeInfo.encoding},function(err) {\n\t\t\t\tif(err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tcontent = self.wiki.renderTiddler(\"text/plain\",\"$:/core/templates/tiddler-metadata\",{variables: {currentTiddler: tiddler.fields.title}});\n\t\t\t\tfs.writeFile(fileInfo.filepath + \".meta\",content,{encoding: \"utf8\"},function (err) {\n\t\t\t\t\tif(err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tself.logger.log(\"Saved file\",filepath);\n\t\t\t\t\treturn callback(null);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// Save the tiddler as a self contained templated file\n\t\t\tvar content = self.wiki.renderTiddler(\"text/plain\",\"$:/core/templates/tid-tiddler\",{variables: {currentTiddler: tiddler.fields.title}});\n\t\t\tfs.writeFile(filepath,content,{encoding: \"utf8\"},function (err) {\n\t\t\t\tif(err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tself.logger.log(\"Saved file\",filepath);\n\t\t\t\treturn callback(null);\n\t\t\t});\n\t\t}\n\t});\n};\n\n/*\nLoad a tiddler and invoke the callback with (err,tiddlerFields)\n\nWe don't need to implement loading for the file system adaptor, because all the tiddler files will have been loaded during the boot process.\n*/\nFileSystemAdaptor.prototype.loadTiddler = function(title,callback) {\n\tcallback(null,null);\n};\n\n/*\nDelete a tiddler and invoke the callback with (err)\n*/\nFileSystemAdaptor.prototype.deleteTiddler = function(title,callback,options) {\n\tvar self = this,\n\t\tfileInfo = $tw.boot.files[title];\n\t// Only delete the tiddler if we have writable information for the file\n\tif(fileInfo) {\n\t\t// Delete the file\n\t\tfs.unlink(fileInfo.filepath,function(err) {\n\t\t\tif(err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tself.logger.log(\"Deleted file\",fileInfo.filepath);\n\t\t\t// Delete the metafile if present\n\t\t\tif(fileInfo.hasMetaFile) {\n\t\t\t\tfs.unlink(fileInfo.filepath + \".meta\",function(err) {\n\t\t\t\t\tif(err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\treturn $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn $tw.utils.deleteEmptyDirs(path.dirname(fileInfo.filepath),callback);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tcallback(null);\n\t}\n};\n\nif(fs) {\n\texports.adaptorClass = FileSystemAdaptor;\n}\n\n})();\n","type":"application/javascript","module-type":"syncadaptor"},"$:/plugins/tiddlywiki/filesystem/readme":{"title":"$:/plugins/tiddlywiki/filesystem/readme","text":"The filesystem plugin is used under Node.js to synchronise tiddler changes back to the file system. It is inert when used in the browser.\n\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/filesystem]]\n"}}}