{"title":"$:/plugins/tiddlywiki/railroad","description":"Railroad diagram generator","author":"AstridElocson","plugin-type":"plugin","list":"readme usage syntax example","version":"5.1.18-prerelease","dependents":"","type":"application/json","tiddlers":{"$:/plugins/tiddlywiki/railroad/components.js":{"title":"$:/plugins/tiddlywiki/railroad/components.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/railroad/components.js\ntype: application/javascript\nmodule-type: library\n\nComponents of a railroad diagram.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar railroad = require(\"$:/plugins/tiddlywiki/railroad/railroad-diagrams.js\");\n\n/////////////////////////// Base component\n\nvar Component = function() {\n\tthis.type = \"Component\";\n};\n\n// Set up a leaf component\nComponent.prototype.initialiseLeaf = function(type,text) {\n\tthis.type = type;\n\tthis.text = text;\n};\n\n// Set up a component with a single child\nComponent.prototype.initialiseWithChild = function(type,content) {\n\tthis.type = type;\n\tthis.child = toSingleChild(content);\n};\n\n// Set up a component with an array of children\nComponent.prototype.initialiseWithChildren = function(type,content) {\n\tthis.type = type;\n\t// Force the content to be an array\n\tthis.children = $tw.utils.isArray(content) ? content : [content];\n}\n\n// Return an array of the SVG strings of an array of children\nComponent.prototype.getSvgOfChildren = function() {\n\treturn this.children.map(function(child) {\n\t\treturn child.toSvg();\n\t});\n}\n\nComponent.prototype.toSvg = function() {\n\treturn \"\";\n}\n\nComponent.prototype.debug = function(output,indent) {\n\toutput.push(indent);\n\toutput.push(this.type);\n\t// Add the text of a leaf component\n\tif(this.text && this.text !== \"\") {\n\t\toutput.push(\": \");\n\t\toutput.push(this.text);\n\t}\n\t// Flag the normal route\n\tif(this.normal !== undefined) {\n\t\tif(this.normal === true) {\n\t\t\toutput.push(\" (normal)\");\n\t\t} else if(this.normal !== false) {\n\t\t\toutput.push(\" (normal: \");\n\t\t\toutput.push(this.normal);\n\t\t\toutput.push(\")\");\n\t\t}\n\t}\n\toutput.push(\"\\n\");\n\tvar contentIndent = indent + \"  \";\n\t// Add the one child\n\tif(this.child) {\n\t\tthis.child.debug(output,contentIndent);\n\t}\n\t// Add the array of children\n\tif(this.children) {\n\t\tthis.debugArray(this.children,output,contentIndent);\n\t}\n  \t// Add the separator if there is one\n\tif(this.separator) {\n\t\toutput.push(indent);\n\t\toutput.push(\"(separator)\\n\");\n\t\tthis.separator.debug(output,contentIndent);\n\t}\n};\n\nComponent.prototype.debugArray = function(array,output,indent) {\n\tfor(var i=0; i<array.length; i++) {\n\t\tvar item = array[i];\n\t\t// Choice content is a special case: we number the branches\n\t\tif(item.isChoiceBranch) {\n\t\t\toutput.push(indent);\n\t\t\toutput.push(\"(\");\n\t\t\toutput.push(i);\n\t\t\toutput.push(\")\\n\");\n\t\t\titem.debug(output,\"  \"+indent);\n\t\t} else {\n\t\t\titem.debug(output,indent);\n\t\t}\n\t}\n}\n\nvar toSingleChild = function(content) {\n\tif($tw.utils.isArray(content)) {\n\t\t// Reduce an array of one child to just the child\n\t\tif(content.length === 1) {\n\t\t\treturn content[0];\n\t\t} else {\n\t\t\t// Never allow an empty sequence\n\t\t  \tif(content.length === 0) {\n  \t\t\t\tcontent.push(new Dummy());\n\t\t  \t}\n\t\t\t// Wrap multiple children into a single sequence component\n\t\t\treturn new Sequence(content);\n\t\t}\n\t} else {\n\t\t// Already single\n\t\treturn content;\n\t}\n}\n\n/////////////////////////// Leaf components\n\nvar Comment = function(text) {\n\tthis.initialiseLeaf(\"Comment\",text);\n};\n\nComment.prototype = new Component();\n\nComment.prototype.toSvg = function() {\n\treturn railroad.Comment(this.text);\n}\n\nvar Dummy = function() {\n\tthis.initialiseLeaf(\"Dummy\");\n};\n\nDummy.prototype = new Component();\n\nDummy.prototype.toSvg = function() {\n\treturn railroad.Skip();\n}\n\nvar Nonterminal = function(text) {\n\tthis.initialiseLeaf(\"Nonterminal\",text);\n};\n\nNonterminal.prototype = new Component();\n\nNonterminal.prototype.toSvg = function() {\n\treturn railroad.NonTerminal(this.text);\n}\n\nvar Terminal = function(text) {\n\tthis.initialiseLeaf(\"Terminal\",text);\n};\n\nTerminal.prototype = new Component();\n\nTerminal.prototype.toSvg = function() {\n\treturn railroad.Terminal(this.text);\n}\n\n/////////////////////////// Components with one child\n\nvar Optional = function(content,normal) {\n\tthis.initialiseWithChild(\"Optional\",content);\n\tthis.normal = normal;\n};\n\nOptional.prototype = new Component();\n\nOptional.prototype.toSvg = function() {\n\t// Call Optional(component,\"skip\")\n\treturn railroad.Optional(this.child.toSvg(), this.normal ? undefined : \"skip\");\n}\n\nvar OptionalRepeated = function(content,separator,normal,wantArrow) {\n\tthis.initialiseWithChild(\"OptionalRepeated\",content);\n\tthis.separator = toSingleChild(separator);\n\tthis.normal = normal;\n\tthis.wantArrow = wantArrow;\n};\n\nOptionalRepeated.prototype = new Component();\n\nOptionalRepeated.prototype.toSvg = function() {\n\t// Call ZeroOrMore(component,separator,\"skip\")\n\tvar separatorSvg = this.separator ? this.separator.toSvg() : null;\n\tvar skip = this.normal ? undefined : \"skip\";\n\treturn railroad.ZeroOrMore(this.child.toSvg(),separatorSvg,skip,this.wantArrow);\n}\n\nvar Repeated = function(content,separator,wantArrow) {\n\tthis.initialiseWithChild(\"Repeated\",content);\n\tthis.separator = toSingleChild(separator);\n\tthis.wantArrow = wantArrow;\n};\n\nRepeated.prototype = new Component();\n\nRepeated.prototype.toSvg = function() {\n\t// Call OneOrMore(component,separator)\n\tvar separatorSvg = this.separator ? this.separator.toSvg() : null;\n\treturn railroad.OneOrMore(this.child.toSvg(),separatorSvg,this.wantArrow);\n}\n\nvar Link = function(content,options) {\n\tthis.initialiseWithChild(\"Link\",content);\n\tthis.options = options;\n};\n\nLink.prototype = new Component();\n\nLink.prototype.toSvg = function() {\n\treturn railroad.Link(this.child.toSvg(),this.options);\n}\n\nvar Transclusion = function(content) {\n\tthis.initialiseWithChild(\"Transclusion\",content);\n};\n\nTransclusion.prototype = new Component();\n\nTransclusion.prototype.toSvg = function() {\n\treturn this.child.toSvg();\n}\n\n/////////////////////////// Components with an array of children\n\nvar Root = function(content) {\n\tthis.initialiseWithChildren(\"Root\",content);\n};\n\nRoot.prototype = new Component();\n\nRoot.prototype.toSvg = function(options) {\n\tvar args = this.getSvgOfChildren();\n\targs.unshift(options);\n\t// Call Diagram(options,component1,component2,...)\n\treturn railroad.Diagram.apply(null,args);\n}\n\nvar Sequence = function(content) {\n\tthis.initialiseWithChildren(\"Sequence\",content);\n};\n\nSequence.prototype = new Component();\n\nSequence.prototype.toSvg = function() {\n\t// Call Sequence(component1,component2,...)\n\treturn railroad.Sequence.apply(null,this.getSvgOfChildren());\n}\n\nvar Choice = function(content,normal) {\n\tthis.initialiseWithChildren(\"Choice\",content.map(toSingleChild));\n\tfor(var i=0; i<this.children.length; i++) {\n\t\tthis.children[i].isChoiceBranch = true;\n\t}\n\tthis.normal = normal;\n};\n\nChoice.prototype = new Component();\n\nChoice.prototype.toSvg = function() {\n\t// Call Choice(normal,component1,component2,...)\n\tvar args = this.getSvgOfChildren();\n\targs.unshift(this.normal);\n\treturn railroad.Choice.apply(null,args);\n}\n\n/////////////////////////// Exports\n\nexports.components = {\n\tChoice: Choice,\n\tComment: Comment,\n\tDummy: Dummy,\n\tLink: Link,\n\tNonterminal: Nonterminal,\n\tOptional: Optional,\n\tOptionalRepeated: OptionalRepeated,\n\tRepeated: Repeated,\n\tRoot: Root,\n\tSequence: Sequence,\n\tTerminal: Terminal,\n\tTransclusion: Transclusion\n};\n\n})();","type":"application/javascript","module-type":"library"},"$:/plugins/tiddlywiki/railroad/example-source":{"title":"$:/plugins/tiddlywiki/railroad/example-source","created":"20150103184022184","modified":"20150119214125000","tags":"","type":"text/vnd.tiddlywiki.railroad","text":"[\"+\"]\n({ [[digit|GettingStarted]] } | \"#\" <'escape sequence'>)\n[{(\"@\" name-char | :\"--\" )}]\n"},"$:/plugins/tiddlywiki/railroad/example":{"title":"$:/plugins/tiddlywiki/railroad/example","created":"20150102165032410","modified":"20150120090735000","tags":"","text":"Notation:\n\n<pre><code><$text text={{$:/plugins/tiddlywiki/railroad/example-source}}/></code></pre>\n\nDiagram:\n\n{{$:/plugins/tiddlywiki/railroad/example-source}}\n\nDebug mode:\n\n<$railroad debug=\"yes\" text={{$:/plugins/tiddlywiki/railroad/example-source}}/>\n"},"$:/plugins/tiddlywiki/railroad/readme":{"title":"$:/plugins/tiddlywiki/railroad/readme","created":"20150102163222184","modified":"20150119231005000","text":"This plugin provides a `<$railroad>` widget for generating railroad diagrams as SVG images.\n\nAlternatively, the [[diagram notation|$:/plugins/tiddlywiki/railroad/syntax]] can be stored in a dedicated tiddler with its `type` field set to `text/vnd.tiddlywiki.railroad`, and that tiddler can simply be transcluded to wherever it is needed.\n\nThe plugin is based on [[a library by Tab Atkins|https://github.com/tabatkins/railroad-diagrams]], and has been extended to make it more flexible, including allowing components of a diagram to function as links or be transcluded from other tiddlers.\n"},"$:/plugins/tiddlywiki/railroad/syntax-string":{"title":"$:/plugins/tiddlywiki/railroad/syntax-string","created":"20150103184022184","modified":"20150103184022184","text":"('\"' text '\"' | \"'\" text \"'\" | '\"\"\"' text '\"\"\"')"},"$:/plugins/tiddlywiki/railroad/syntax":{"title":"$:/plugins/tiddlywiki/railroad/syntax","created":"20150103184022184","modified":"20150119220342000","text":"The railroad widget uses a special notation to construct the components defined below.\n\n`x` and `y` here stand for any component.\n\nNames (as opposed to quoted strings) are available when a value starts with a letter and contains only letters, digits, underscores, dots and hyphens.\n\n---\n\n; sequence\n: <$railroad text=\"\"\" [\"<-\"] {x} [\"->\"] \"\"\"/>\n* A sequence of components\n* The `<-` and `->` delimiters allow you to force a single component to be treated as a sequence. This is occasionally useful for spacing a diagram out\n\n---\n\n; optional\n: <$railroad text=\"\"\" \"[\" [\":\"] x \"]\" \"\"\"/>\n* A component that can be omitted\n* The colon makes `x` appear straight ahead\n\n---\n\n; repeated\n: <$railroad text=\"\"\" \"{\" x [:\"+\" y] \"}\" \"\"\"/>\n* A list of one or more `x`\n* The `+` suffix adds `y` as a separator between each `x` and the next\n\n---\n\n; optional repeated\n: <$railroad text=\"\"\" \"[{\" [\":\"] x [:\"+\" y] \"}]\" \"\"\"/>\n* An optional list of `x`, i.e. a list of zero or more `x`\n\n---\n\n; choice\n: <$railroad text=\"\"\" \"(\" {[:\":\"] x +\"|\"} \")\" \"\"\"/>\n* A set of alternatives\n* The colon indicates which branch appears straight ahead. By default, it's the first branch\n\n---\n\n; string / terminal\n: <$railroad text={{$:/plugins/tiddlywiki/railroad/syntax-string}}/>\n* A literal or terminal component\n* This follows the normal ~TiddlyWiki rules for quoted strings\n\n---\n\n; nonterminal\n: <$railroad text=\"\"\" (name | \"<\" string \">\") \"\"\"/>\n* A nonterminal component, i.e. the name of another diagram\n\n---\n\n; comment\n: <$railroad text=\"\"\" \"/\" string \"/\" \"\"\"/>\n* A comment\n\n---\n\n; dummy\n: <$railroad text=\"\"\" \"-\" \"\"\"/>\n* The absence of a component\n\n---\n\n; link\n: <$railroad text=\"\"\" \"[[\" x \"|\" (name|string) \"]]\" \"\"\"/>\n* A link to the tiddler title or URI given by the string or name\n\n---\n\n; transclusion\n: <$railroad text=\"\"\" \"{{\" (name|string) \"}}\" \"\"\"/>\n* Treats the content of another tiddler as diagram syntax and transcludes it into the current diagram\n\n---\n\n; arrow pragma\n: <$railroad text=\"\"\" \"\\arrow\" (\"yes\" | \"no\") \"\"\"/>\n* Controls whether repeat paths have an arrow on them\n* Can be toggled on and off in mid-diagram, if desired\n\n---\n\n; debug pragma\n: <$railroad text=\"\"\" \"\\debug\" \"\"\"/>\n* Causes the diagram to display its parse tree\n\n---\n\n; start/end pragma\n: <$railroad text=\"\"\" (\"\\start\" |: \"\\end\") (\"none\" |: \"single\" | \"double\") \"\"\"/>\n* Controls the style of the diagram's startpoint or endpoint\n"},"$:/plugins/tiddlywiki/railroad/usage":{"title":"$:/plugins/tiddlywiki/railroad/usage","created":"20150102163222184","modified":"20150119231005000","text":"The content of the `<$railroad>` widget is ignored.\n\n|!Attribute |!Description |!Default |\n|text |Text in a special notation that defines the diagram's layout |-- |\n|arrow |If set to `no`, repeat paths do not have an arrow on them |`yes` |\n|start |Style of the startpoint: `single`, `double`, `none` |`single` |\n|end |Style of the endpoint: `single`, `double`, `none` |`single` |\n|debug |If set to `yes`, the diagram displays its parse tree |`no` |\n\nThese options can also be specified via pragmas in the diagram notation, or globally via a dictionary tiddler called `$:/config/railroad`:\n\n```\narrow: yes\nstart: single\nend: single\ndebug: no\n```\n"},"$:/plugins/tiddlywiki/railroad/railroad-diagrams.css":{"text":"/* CSS modified for TiddlyWiki */\nsvg.railroad-diagram {\n\tbackground-color: hsl(30,20%,98%);\n\tborder-radius: 5px;\n}\nsvg.railroad-diagram:hover {\n\tbackground-color: hsl(30,20%,96%);\n}\nsvg.railroad-diagram path,\nsvg.railroad-diagram rect {\n\tstroke-width: 2;\n\tstroke: #333;\n}\nsvg.railroad-diagram path {\n\tfill: rgba(0,0,0,0);\n}\nsvg.railroad-diagram rect {\n\tfill: hsl(120,100%,90%);\n}\nsvg.railroad-diagram text {\n\tfont: 14px monospace;\n\ttext-anchor: middle;\n}\nsvg.railroad-diagram text.label {\n\ttext-anchor: start;\n}\nsvg.railroad-diagram text.comment {\n\tfont: italic 12px monospace;\n}\nsvg.railroad-diagram path.arrow {\n    stroke-width: 2;\n}","type":"text/css","title":"$:/plugins/tiddlywiki/railroad/railroad-diagrams.css","tags":"$:/tags/Stylesheet"},"$:/plugins/tiddlywiki/railroad/railroad-diagrams.js":{"text":"(function(document) {\n/* TiddlyWiki: modifications to the original library are commented like this */\n\n/*\nRailroad Diagrams\nby Tab Atkins Jr. (and others)\nhttp://xanthir.com\nhttp://twitter.com/tabatkins\nhttp://github.com/tabatkins/railroad-diagrams\n\nThis document and all associated files in the github project are licensed under CC0: http://creativecommons.org/publicdomain/zero/1.0/\nThis means you can reuse, remix, or otherwise appropriate this project for your own use WITHOUT RESTRICTION.\n(The actual legal meaning can be found at the above link.)\nDon't ask me for permission to use any part of this project, JUST USE IT.\nI would appreciate attribution, but that is not required by the license.\n*/\n\n/*\nThis file uses a module pattern to avoid leaking names into the global scope.\nThe only accidental leakage is the name \"temp\".\nThe exported names can be found at the bottom of this file;\nsimply change the names in the array of strings to change what they are called in your application.\n\nAs well, several configuration constants are passed into the module function at the bottom of this file.\nAt runtime, these constants can be found on the Diagram class.\n*/\n\nvar temp = (function(options) {\n\tfunction subclassOf(baseClass, superClass) {\n\t\tbaseClass.prototype = Object.create(superClass.prototype);\n\t\tbaseClass.prototype.$super = superClass.prototype;\n\t}\n\n\tfunction unnull(/* children */) {\n\t\treturn [].slice.call(arguments).reduce(function(sofar, x) { return sofar !== undefined ? sofar : x; });\n\t}\n\n\tfunction determineGaps(outer, inner) {\n\t\tvar diff = outer - inner;\n\t\tswitch(Diagram.INTERNAL_ALIGNMENT) {\n\t\t\tcase 'left': return [0, diff]; break;\n\t\t\tcase 'right': return [diff, 0]; break;\n\t\t\tcase 'center':\n\t\t\tdefault: return [diff/2, diff/2]; break;\n\t\t}\n\t}\n\n\tfunction wrapString(value) {\n\t\treturn ((typeof value) == 'string') ? new Terminal(value) : value;\n\t}\n\n\n\tfunction SVG(name, attrs, text) {\n\t\tattrs = attrs || {};\n\t\ttext = text || '';\n\t\tvar el = document.createElementNS(\"http://www.w3.org/2000/svg\",name);\n\t\tfor(var attr in attrs) {\n\t\t\tel.setAttribute(attr, attrs[attr]);\n\t\t}\n\t\tel.textContent = text;\n\t\treturn el;\n\t}\n\n\tfunction FakeSVG(tagName, attrs, text){\n\t\tif(!(this instanceof FakeSVG)) return new FakeSVG(tagName, attrs, text);\n\t\tif(text) this.children = text;\n\t\telse this.children = [];\n\t\tthis.tagName = tagName;\n\t\tthis.attrs = unnull(attrs, {});\n\t\treturn this;\n\t};\n\tFakeSVG.prototype.format = function(x, y, width) {\n\t\t// Virtual\n\t};\n\tFakeSVG.prototype.addTo = function(parent) {\n\t\tif(parent instanceof FakeSVG) {\n\t\t\tparent.children.push(this);\n\t\t\treturn this;\n\t\t} else {\n\t\t\tvar svg = this.toSVG();\n\t\t\tparent.appendChild(svg);\n\t\t\treturn svg;\n\t\t}\n\t};\n\tFakeSVG.prototype.toSVG = function() {\n\t\tvar el = SVG(this.tagName, this.attrs);\n\t\tif(typeof this.children == 'string') {\n\t\t\tel.textContent = this.children;\n\t\t} else {\n\t\t\tthis.children.forEach(function(e) {\n\t\t\t\tel.appendChild(e.toSVG());\n\t\t\t});\n\t\t}\n\t\treturn el;\n\t};\n\tFakeSVG.prototype.toString = function() {\n\t\tvar str = '<' + this.tagName;\n\t\tvar group = this.tagName == \"g\" || this.tagName == \"svg\";\n\t\tfor(var attr in this.attrs) {\n\t\t\tstr += ' ' + attr + '=\"' + (this.attrs[attr]+'').replace(/&/g, '&amp;').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\t\tstr += '>';\n\t\tif(group) str += \"\\n\";\n\t\tif(typeof this.children == 'string') {\n\t\t\tstr += this.children.replace(/&/g, '&amp;').replace(/</g, '&lt;');\n\t\t} else {\n\t\t\tthis.children.forEach(function(e) {\n\t\t\t\tstr += e;\n\t\t\t});\n\t\t}\n\t\tstr += '</' + this.tagName + '>\\n';\n\t\treturn str;\n\t}\n\n\tfunction Path(x,y,attrs) {\n\t\tif(!(this instanceof Path)) return new Path(x,y,attrs);\n\t\tFakeSVG.call(this, 'path', attrs);\n\t\tthis.attrs.d = \"M\"+x+' '+y;\n\t}\n\tsubclassOf(Path, FakeSVG);\n\tPath.prototype.m = function(x,y) {\n\t\tthis.attrs.d += 'm'+x+' '+y;\n\t\treturn this;\n\t}\n\tPath.prototype.h = function(val) {\n\t\tthis.attrs.d += 'h'+val;\n\t\treturn this;\n\t}\n\tPath.prototype.right = Path.prototype.h;\n\tPath.prototype.left = function(val) { return this.h(-val); }\n\tPath.prototype.v = function(val) {\n\t\tthis.attrs.d += 'v'+val;\n\t\treturn this;\n\t}\n\tPath.prototype.down = Path.prototype.v;\n\tPath.prototype.up = function(val) { return this.v(-val); }\n\tPath.prototype.arc = function(sweep){\n\t\tvar x = Diagram.ARC_RADIUS;\n\t\tvar y = Diagram.ARC_RADIUS;\n\t\tif(sweep[0] == 'e' || sweep[1] == 'w') {\n\t\t\tx *= -1;\n\t\t}\n\t\tif(sweep[0] == 's' || sweep[1] == 'n') {\n\t\t\ty *= -1;\n\t\t}\n\t\tif(sweep == 'ne' || sweep == 'es' || sweep == 'sw' || sweep == 'wn') {\n\t\t\tvar cw = 1;\n\t\t} else {\n\t\t\tvar cw = 0;\n\t\t}\n\t\tthis.attrs.d += \"a\"+Diagram.ARC_RADIUS+\" \"+Diagram.ARC_RADIUS+\" 0 0 \"+cw+' '+x+' '+y;\n\t\treturn this;\n\t}\n\tPath.prototype.format = function() {\n\t\t// All paths in this library start/end horizontally.\n\t\t// The extra .5 ensures a minor overlap, so there's no seams in bad rasterizers.\n\t\tthis.attrs.d += 'h.5';\n\t\treturn this;\n\t}\n/* TiddlyWiki: added support for arbitrary straight lines */\n\tPath.prototype.line = function(dx,dy) {\n\t\tthis.attrs.d += \"l\"+dx+\" \"+dy;\n\t\treturn this;\n\t}\n\n/* TiddlyWiki: added twOptions parameter, passing it to Start() and End() */\n\tfunction Diagram(twOptions, items) {\n\t\tif(!(this instanceof Diagram)) return new Diagram(twOptions, [].slice.call(arguments,1));\n\t\tFakeSVG.call(this, 'svg', {class: Diagram.DIAGRAM_CLASS});\n\t\tthis.items = items.map(wrapString);\n\t\tthis.items.unshift(new Start(twOptions.start));\n\t\tthis.items.push(new End(twOptions.end));\n\t\tthis.width = this.items.reduce(function(sofar, el) { return sofar + el.width + (el.needsSpace?20:0)}, 0)+1;\n\t\tthis.up = Math.max.apply(null, this.items.map(function (x) { return x.up; }));\n\t\tthis.down = Math.max.apply(null, this.items.map(function (x) { return x.down; }));\n\t\tthis.formatted = false;\t\t\n\t}\n\tsubclassOf(Diagram, FakeSVG);\n\tfor(var option in options) {\n\t\tDiagram[option] = options[option];\n\t}\n\tDiagram.prototype.format = function(paddingt, paddingr, paddingb, paddingl) {\n\t\tpaddingt = unnull(paddingt, 20);\n\t\tpaddingr = unnull(paddingr, paddingt, 20);\n\t\tpaddingb = unnull(paddingb, paddingt, 20);\n\t\tpaddingl = unnull(paddingl, paddingr, 20);\n\t\tvar x = paddingl;\n\t\tvar y = paddingt;\n\t\ty += this.up;\n\t\tvar g = FakeSVG('g', Diagram.STROKE_ODD_PIXEL_LENGTH ? {transform:'translate(.5 .5)'} : {});\n\t\tfor(var i = 0; i < this.items.length; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\tif(item.needsSpace) {\n\t\t\t\tPath(x,y).h(10).addTo(g);\n\t\t\t\tx += 10;\n\t\t\t}\n\t\t\titem.format(x, y, item.width).addTo(g);\n\t\t\tx += item.width;\n\t\t\tif(item.needsSpace) {\n\t\t\t\tPath(x,y).h(10).addTo(g);\n\t\t\t\tx += 10;\n\t\t\t}\n\t\t}\n\t\tthis.attrs.width = this.width + paddingl + paddingr;\n\t\tthis.attrs.height = this.up + this.down + paddingt + paddingb;\n\t\tthis.attrs.viewBox = \"0 0 \"  + this.attrs.width + \" \" + this.attrs.height;\n\t\tg.addTo(this);\n\t\tthis.formatted = true;\n\t\treturn this;\n\t}\n\tDiagram.prototype.addTo = function(parent) {\n\t\tvar scriptTag = document.getElementsByTagName('script');\n\t\tscriptTag = scriptTag[scriptTag.length - 1];\n\t\tvar parentTag = scriptTag.parentNode;\n\t\tparent = parent || parentTag;\n\t\treturn this.$super.addTo.call(this, parent);\n\t}\n\tDiagram.prototype.toSVG = function() {\n\t\tif (!this.formatted) {\n\t\t\tthis.format();\n\t\t}\n\t\treturn this.$super.toSVG.call(this);\n\t}\n\tDiagram.prototype.toString = function() {\n\t\tif (!this.formatted) {\n\t\t\tthis.format();\n\t\t}\n\t\treturn this.$super.toString.call(this);\n\t}\n\n\tfunction Sequence(items) {\n\t\tif(!(this instanceof Sequence)) return new Sequence([].slice.call(arguments));\n\t\tFakeSVG.call(this, 'g');\n\t\tthis.items = items.map(wrapString);\n\t\tthis.width = this.items.reduce(function(sofar, el) { return sofar + el.width + (el.needsSpace?20:0)}, 0);\n\t\tthis.up = this.items.reduce(function(sofar,el) { return Math.max(sofar, el.up)}, 0);\n\t\tthis.down = this.items.reduce(function(sofar,el) { return Math.max(sofar, el.down)}, 0);\n\t}\n\tsubclassOf(Sequence, FakeSVG);\n\tSequence.prototype.format = function(x,y,width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\tfor(var i = 0; i < this.items.length; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\tif(item.needsSpace) {\n\t\t\t\tPath(x,y).h(10).addTo(this);\n\t\t\t\tx += 10;\n\t\t\t}\n\t\t\titem.format(x, y, item.width).addTo(this);\n\t\t\tx += item.width;\n\t\t\tif(item.needsSpace) {\n\t\t\t\tPath(x,y).h(10).addTo(this);\n\t\t\t\tx += 10;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tfunction Choice(normal, items) {\n\t\tif(!(this instanceof Choice)) return new Choice(normal, [].slice.call(arguments,1));\n\t\tFakeSVG.call(this, 'g');\n\t\tif( typeof normal !== \"number\" || normal !== Math.floor(normal) ) {\n\t\t\tthrow new TypeError(\"The first argument of Choice() must be an integer.\");\n\t\t} else if(normal < 0 || normal >= items.length) {\n\t\t\tthrow new RangeError(\"The first argument of Choice() must be an index for one of the items.\");\n\t\t} else {\n\t\t\tthis.normal = normal;\n\t\t}\n\t\tthis.items = items.map(wrapString);\n\t\tthis.width = this.items.reduce(function(sofar, el){return Math.max(sofar, el.width)},0) + Diagram.ARC_RADIUS*4;\n\t\tthis.up = this.down = 0;\n\t\tfor(var i = 0; i < this.items.length; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\tif(i < normal) { this.up += Math.max(Diagram.ARC_RADIUS,item.up + item.down + Diagram.VERTICAL_SEPARATION); }\n\t\t\tif(i == normal) { this.up += Math.max(Diagram.ARC_RADIUS, item.up); this.down += Math.max(Diagram.ARC_RADIUS, item.down); }\n\t\t\tif(i > normal) { this.down += Math.max(Diagram.ARC_RADIUS,Diagram.VERTICAL_SEPARATION + item.up + item.down); }\n\t\t}\n\t}\n\tsubclassOf(Choice, FakeSVG);\n\tChoice.prototype.format = function(x,y,width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\tvar last = this.items.length -1;\n\t\tvar innerWidth = this.width - Diagram.ARC_RADIUS*4;\n\n\t\t// Do the elements that curve above\n\t\tfor(var i = this.normal - 1; i >= 0; i--) {\n\t\t\tvar item = this.items[i];\n\t\t\tif( i == this.normal - 1 ) {\n\t\t\t\tvar distanceFromY = Math.max(Diagram.ARC_RADIUS*2, this.items[i+1].up + Diagram.VERTICAL_SEPARATION + item.down);\n\t\t\t}\n\t\t\tPath(x,y).arc('se').up(distanceFromY - Diagram.ARC_RADIUS*2).arc('wn').addTo(this);\n\t\t\titem.format(x+Diagram.ARC_RADIUS*2,y - distanceFromY,innerWidth).addTo(this);\n\t\t\tPath(x+Diagram.ARC_RADIUS*2+innerWidth, y-distanceFromY).arc('ne').down(distanceFromY - Diagram.ARC_RADIUS*2).arc('ws').addTo(this);\n\t\t\tdistanceFromY += Math.max(Diagram.ARC_RADIUS, item.up + Diagram.VERTICAL_SEPARATION + (i == 0 ? 0 : this.items[i-1].down));\n\t\t}\n\n\t\t// Do the straight-line path.\n\t\tPath(x,y).right(Diagram.ARC_RADIUS*2).addTo(this);\n\t\tthis.items[this.normal].format(x+Diagram.ARC_RADIUS*2, y, innerWidth).addTo(this);\n\t\tPath(x+Diagram.ARC_RADIUS*2+innerWidth, y).right(Diagram.ARC_RADIUS*2).addTo(this);\n\n\t\t// Do the elements that curve below\n\t\tfor(var i = this.normal+1; i <= last; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\tif( i == this.normal + 1 ) {\n\t\t\t\tvar distanceFromY = Math.max(Diagram.ARC_RADIUS*2, this.items[i-1].down + Diagram.VERTICAL_SEPARATION + item.up);\n\t\t\t}\n\t\t\tPath(x,y).arc('ne').down(distanceFromY - Diagram.ARC_RADIUS*2).arc('ws').addTo(this);\n\t\t\titem.format(x+Diagram.ARC_RADIUS*2, y+distanceFromY, innerWidth).addTo(this);\n\t\t\tPath(x+Diagram.ARC_RADIUS*2+innerWidth, y+distanceFromY).arc('se').up(distanceFromY - Diagram.ARC_RADIUS*2).arc('wn').addTo(this);\n\t\t\tdistanceFromY += Math.max(Diagram.ARC_RADIUS, item.down + Diagram.VERTICAL_SEPARATION + (i == last ? 0 : this.items[i+1].up));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfunction Optional(item, skip) {\n\t\tif( skip === undefined )\n\t\t\treturn Choice(1, Skip(), item);\n\t\telse if ( skip === \"skip\" )\n\t\t\treturn Choice(0, Skip(), item);\n\t\telse\n\t\t\tthrow \"Unknown value for Optional()'s 'skip' argument.\";\n\t}\n\n/* TiddlyWiki: added wantArrow */\n\tfunction OneOrMore(item, rep, wantArrow) {\n\t\tif(!(this instanceof OneOrMore)) return new OneOrMore(item, rep, wantArrow);\n\t\tFakeSVG.call(this, 'g');\n\n/* TiddlyWiki: code added */\n\t\tthis.wantArrow = wantArrow;\n\n\t\trep = rep || (new Skip);\n\t\tthis.item = wrapString(item);\n\t\tthis.rep = wrapString(rep);\n\t\tthis.width = Math.max(this.item.width, this.rep.width) + Diagram.ARC_RADIUS*2;\n\t\tthis.up = this.item.up;\n\t\tthis.down = Math.max(Diagram.ARC_RADIUS*2, this.item.down + Diagram.VERTICAL_SEPARATION + this.rep.up + this.rep.down);\n\n/* TiddlyWiki: moved calculation of distanceFromY (of the repeat arc) to here */\n\t\tthis.distanceFromY = Math.max(Diagram.ARC_RADIUS*2, this.item.down+Diagram.VERTICAL_SEPARATION+this.rep.up);\n\t}\n\tsubclassOf(OneOrMore, FakeSVG);\n\tOneOrMore.prototype.needsSpace = true;\n\tOneOrMore.prototype.format = function(x,y,width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\t// Draw item\n\t\tPath(x,y).right(Diagram.ARC_RADIUS).addTo(this);\n\t\tthis.item.format(x+Diagram.ARC_RADIUS,y,this.width-Diagram.ARC_RADIUS*2).addTo(this);\n\t\tPath(x+this.width-Diagram.ARC_RADIUS,y).right(Diagram.ARC_RADIUS).addTo(this);\n\n\t\t// Draw repeat arc\n/* TiddlyWiki: moved calculation of distanceFromY from here to constructor */\n\t\tvar distanceFromY = this.distanceFromY;\n\t\t\n\t\tPath(x+Diagram.ARC_RADIUS,y).arc('nw').down(distanceFromY-Diagram.ARC_RADIUS*2).arc('ws').addTo(this);\n\t\tthis.rep.format(x+Diagram.ARC_RADIUS, y+distanceFromY, this.width - Diagram.ARC_RADIUS*2).addTo(this);\n\t\tPath(x+this.width-Diagram.ARC_RADIUS, y+distanceFromY).arc('se').up(distanceFromY-Diagram.ARC_RADIUS*2).arc('en').addTo(this);\n\t\t\n/* TiddlyWiki: code added */\n\t\tif(this.wantArrow) {\n\t\t\tvar arrowSize = Diagram.ARC_RADIUS/2;\n\t\t\t// Compensate for the illusion that makes the arrow look unbalanced if it's too close to the curve below it\n\t\t\tvar multiplier = (distanceFromY < arrowSize*5) ? 1.2 : 1;\n\t\t\tPath(x-arrowSize, y+distanceFromY/2 + arrowSize/2, {class:\"arrow\"}).\n\t\t\t\tline(arrowSize, -arrowSize).line(arrowSize*multiplier, arrowSize).addTo(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfunction ZeroOrMore(item, rep, skip, wantArrow) {\n\t\treturn Optional(OneOrMore(item, rep, wantArrow), skip);\n\t}\n\n/* TiddlyWiki: added type parameter */\n\tfunction Start(type) {\n\t\tif(!(this instanceof Start)) return new Start(type);\n\t\tFakeSVG.call(this, 'path');\n\t\tthis.type = type || 'single'\n\t\tthis.width = (this.type === 'double') ? 20 : 10;\n\t\tthis.up = 10;\n\t\tthis.down = 10;\n\t}\n\tsubclassOf(Start, FakeSVG);\n\tStart.prototype.format = function(x,y) {\n/* TiddlyWiki: added types */\n\t\tif(this.type === 'single') {\n\t\t\tthis.attrs.d = 'M '+x+' '+(y-10)+' v 20 m 0 -10 h 10.5';\n\t\t} else if(this.type === 'double') {\n\t\t\tthis.attrs.d = 'M '+x+' '+(y-10)+' v 20 m 10 -20 v 20 m -10 -10 h 20.5';\n\t\t} else { // 'none'\n\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 10.5';\n\t\t}\n\t\treturn this;\n\t}\n\n/* TiddlyWiki: added type parameter */\n\tfunction End(type) {\n\t\tif(!(this instanceof End)) return new End(type);\n\t\tFakeSVG.call(this, 'path');\n\t\tthis.type = type || 'double';\n\t\tthis.width = (this.type === 'double') ? 20 : 10;\n\t\tthis.up = 10;\n\t\tthis.down = 10;\n\t}\n\tsubclassOf(End, FakeSVG);\n\tEnd.prototype.format = function(x,y) {\n/* TiddlyWiki: added types */\n\t\tif(this.type === 'single') {\n\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 10 m 0 -10 v 20';\n\t\t} else if(this.type === 'double') {\n\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 20 m -10 -10 v 20 m 10 -20 v 20';\n\t\t} else { // 'none'\n\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 10';\n\t\t}\n\t\treturn this;\n\t}\n\n\tfunction Terminal(text) {\n\t\tif(!(this instanceof Terminal)) return new Terminal(text);\n\t\tFakeSVG.call(this, 'g');\n\t\tthis.text = text;\n\t\tthis.width = text.length * 8 + 20; /* Assume that each char is .5em, and that the em is 16px */\n\t\tthis.up = 11;\n\t\tthis.down = 11;\n\t}\n\tsubclassOf(Terminal, FakeSVG);\n\tTerminal.prototype.needsSpace = true;\n\tTerminal.prototype.format = function(x, y, width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\tFakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down, rx:10, ry:10}).addTo(this);\n\t\tFakeSVG('text', {x:x+this.width/2, y:y+4}, this.text).addTo(this);\n\t\treturn this;\n\t}\n\n\tfunction NonTerminal(text) {\n\t\tif(!(this instanceof NonTerminal)) return new NonTerminal(text);\n\t\tFakeSVG.call(this, 'g');\n\t\tthis.text = text;\n\t\tthis.width = text.length * 8 + 20;\n\t\tthis.up = 11;\n\t\tthis.down = 11;\n\t}\n\tsubclassOf(NonTerminal, FakeSVG);\n\tNonTerminal.prototype.needsSpace = true;\n\tNonTerminal.prototype.format = function(x, y, width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\tFakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down}).addTo(this);\n\t\tFakeSVG('text', {x:x+this.width/2, y:y+4}, this.text).addTo(this);\n\t\treturn this;\n\t}\n\n\tfunction Comment(text) {\n\t\tif(!(this instanceof Comment)) return new Comment(text);\n\t\tFakeSVG.call(this, 'g');\n\t\tthis.text = text;\n\t\tthis.width = text.length * 7 + 10;\n\t\tthis.up = 11;\n\t\tthis.down = 11;\n\t}\n\tsubclassOf(Comment, FakeSVG);\n\tComment.prototype.needsSpace = true;\n\tComment.prototype.format = function(x, y, width) {\n\t\t// Hook up the two sides if this is narrower than its stated width.\n\t\tvar gaps = determineGaps(width, this.width);\n\t\tPath(x,y).h(gaps[0]).addTo(this);\n\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n\t\tx += gaps[0];\n\n\t\tFakeSVG('text', {x:x+this.width/2, y:y+5, class:'comment'}, this.text).addTo(this);\n\t\treturn this;\n\t}\n\n\tfunction Skip() {\n\t\tif(!(this instanceof Skip)) return new Skip();\n\t\tFakeSVG.call(this, 'g');\n\t\tthis.width = 0;\n\t\tthis.up = 0;\n\t\tthis.down = 0;\n\t}\n\tsubclassOf(Skip, FakeSVG);\n\tSkip.prototype.format = function(x, y, width) {\n\t\tPath(x,y).right(width).addTo(this);\n\t\treturn this;\n\t}\n\t\n/* TiddlyWiki: added linking ability */\n\tfunction Link(item,options) {\n\t\tif(!(this instanceof Link)) return new Link(item,options);\n\t\tFakeSVG.call(this,'a',options);\n\t\tthis.item = item;\n\t\tthis.width = item.width;\n\t\tthis.up = item.up;\n\t\tthis.down = item.down;\n\t}\n\tsubclassOf(Link, FakeSVG);\n\tLink.prototype.needsSpace = true;\n\tLink.prototype.format = function(x, y, width) {\n\t\tthis.item.format(x,y,width).addTo(this);\n\t\treturn this;\n\t}\n\n/* TiddlyWiki: this block replaces the export mechanism in the original library */\n\tif (exports) {\n\t\texports.Diagram = Diagram;\n\t\texports.Sequence = Sequence;\n\t\texports.Choice = Choice;\n\t\texports.Optional = Optional;\n\t\texports.OneOrMore = OneOrMore;\n\t\texports.ZeroOrMore = ZeroOrMore;\n\t\texports.Terminal = Terminal;\n\t\texports.NonTerminal = NonTerminal;\n\t\texports.Comment = Comment;\n\t\texports.Skip = Skip;\n\t\texports.Link = Link;\n\t};\n})(\n\t{\n\tVERTICAL_SEPARATION: 8,\n\tARC_RADIUS: 10,\n\tDIAGRAM_CLASS: 'railroad-diagram',\n\tSTROKE_ODD_PIXEL_LENGTH: true,\n\tINTERNAL_ALIGNMENT: 'center',\n\t}\n);\n\n/* TiddlyWiki: removed assignments to properties of the window object */\n\n})($tw.node ? $tw.fakeDocument : window.document)\n","type":"application/javascript","title":"$:/plugins/tiddlywiki/railroad/railroad-diagrams.js","module-type":"library"},"$:/plugins/tiddlywiki/railroad/parser.js":{"title":"$:/plugins/tiddlywiki/railroad/parser.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/railroad/parser.js\ntype: application/javascript\nmodule-type: library\n\nParser for the source of a railroad diagram.\n\n[:x]\t\t\toptional, normally included\n[x]\t\t\t\toptional, normally omitted\n{x}\t\t\t\tone or more\n{x +\",\"}\t\tone or more, comma-separated\n[{:x}]\t\t\tzero or more, normally included\n[{:x +\",\"}]\t\tzero or more, comma-separated, normally included\n[{x}]\t\t\tzero or more, normally omitted\n[{x +\",\"}]\t\tzero or more, comma-separated, normally omitted\nx y z\t\t\tsequence\n<-x y z->\t\texplicit sequence\n(x|y|z)\t\t\talternatives\n(x|:y|z)\t\talternatives, normally y\n\"x\"\t\t\t\tterminal\n<\"x\">\t\t\tnonterminal\n/\"blah\"/\t\tcomment\n-\t\t\t\tdummy\n[[x|\"tiddler\"]]\tlink\n{{\"tiddler\"}}\ttransclusion\n\n\"x\" can also be written 'x' or \"\"\"x\"\"\"\n\npragmas:\n\t\\arrow yes|no\n\t\\debug yes|no\n\t\\start single|double|none\n\t\\end single|double|none\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar components = require(\"$:/plugins/tiddlywiki/railroad/components.js\").components;\n\nvar Parser = function(widget,source,options) {\n\tthis.widget = widget;\n\tthis.source = source;\n\tthis.options = options;\n\tthis.tokens = this.tokenise(source);\n\tthis.tokenPos = 0;\n\tthis.advance();\n\tthis.content = this.parseContent();\n\tthis.root = new components.Root(this.content);\n\tthis.checkFinished();\n};\n\n/////////////////////////// Parser dispatch\n\nParser.prototype.parseContent = function() {\n\tvar content = [];\n\t// Parse zero or more components\n\twhile(true) {\n\t\tvar component = this.parseComponent();\n\t\tif(!component) {\n\t\t\tbreak;\n\t\t}\n\t\tif(!component.isPragma) {\n\t\t\tcontent.push(component);\n\t\t}\n\t}\n\treturn content;\n};\n\nParser.prototype.parseComponent = function() {\n\tvar component = null;\n\tif(this.token) {\n\t\tif(this.at(\"string\")) {\n\t\t\tcomponent = this.parseTerminal();\n\t\t} else if(this.at(\"name\")) {\n\t\t\tcomponent = this.parseName();\n\t\t} else if(this.at(\"pragma\")) {\n\t\t\tcomponent = this.parsePragma();\n\t\t} else {\n\t\t\tswitch(this.token.value) {\n\t\t\t\tcase \"[\":\n\t\t\t\t\tcomponent = this.parseOptional();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"{\":\n\t\t\t\t\tcomponent = this.parseRepeated();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<\":\n\t\t\t\t\tcomponent = this.parseNonterminal();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"(\":\n\t\t\t\t\tcomponent = this.parseChoice();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"/\":\n\t\t\t\t\tcomponent = this.parseComment();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"[[\":\n\t\t\t\t\tcomponent = this.parseLink();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"{{\":\n\t\t\t\t\tcomponent = this.parseTransclusion();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<-\":\n\t\t\t\t\tcomponent = this.parseSequence();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"-\":\n\t\t\t\t\tcomponent = this.parseDummy();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn component;\n};\n\n/////////////////////////// Specific components\n\nParser.prototype.parseChoice = function() {\n\t// Consume the (\n\tthis.advance();\n\tvar content = [],\n\t\tcolon = -1;\n\tdo {\n\t\t// Allow at most one branch to be prefixed with a colon\n\t\tif(colon === -1 && this.eat(\":\")) {\n\t\t\tcolon = content.length;\n\t\t}\n\t\t// Parse the next branch\n\t\tcontent.push(this.parseContent());\n\t} while(this.eat(\"|\"));\n\t// Consume the closing bracket\n\tthis.close(\")\");\n\t// Create a component\n\treturn new components.Choice(content,colon === -1 ? 0 : colon);\n};\n\nParser.prototype.parseComment = function() {\n\t// Consume the /\n\tthis.advance();\n\t// The comment's content should be in a string literal\n\tvar content = this.expectString(\"after /\");\n\t// Consume the closing /\n\tthis.close(\"/\");\n\t// Create a component\n\treturn new components.Comment(content);\n};\n\nParser.prototype.parseDummy = function() {\n\t// Consume the -\n\tthis.advance();\n\t// Create a component\n\treturn new components.Dummy();\n};\n\nParser.prototype.parseLink = function() {\n\t// Consume the [[\n\tthis.advance();\n\t// Parse the content\n\tvar content = this.parseContent();\n\t// Consume the |\n\tthis.expect(\"|\");\n\t// Consume the target\n\tvar target = this.expectNameOrString(\"as link target\");\n\t// Prepare some attributes for the SVG \"a\" element to carry\n\tvar options = {\"data-tw-target\": target};\n\tif($tw.utils.isLinkExternal(target)) {\n\t\toptions[\"data-tw-external\"] = true;\n\t}\n\t// Consume the closing ]]\n\tthis.close(\"]]\");\n\t// Create a component\n\treturn new components.Link(content,options);\n};\n\nParser.prototype.parseName = function() {\n\t// Create a component\n\tvar component = new components.Nonterminal(this.token.value);\n\t// Consume the name\n\tthis.advance();\n\treturn component;\n};\n\nParser.prototype.parseNonterminal = function() {\n\t// Consume the <\n\tthis.advance();\n\t// The nonterminal's name should be in a string literal\n\tvar content = this.expectString(\"after <\");\n\t// Consume the closing bracket\n\tthis.close(\">\");\n\t// Create a component\n\treturn new components.Nonterminal(content);\n};\n\nParser.prototype.parseOptional = function() {\n\tvar wantArrow = this.options.arrow;\n\t// Consume the [\n\tthis.advance();\n\t// Consume the { if there is one\n\tvar repeated = this.eat(\"{\");\n\t// Note whether omission is the normal route\n\tvar normal = this.eat(\":\");\n\t// Parse the content\n\tvar content = this.parseContent(),\n\t\tseparator = null;\n\t// Parse the separator if there is one\n\tif(repeated && this.eat(\"+\")) {\n\t\tseparator = this.parseContent();\n\t}\n\t// Consume the closing brackets\n\tif(repeated) {\n\t\tthis.close(\"}\");\n\t}\n\tthis.close(\"]\");\n\t// Create a component\n\treturn repeated ? new components.OptionalRepeated(content,separator,normal,wantArrow)\n\t\t: new components.Optional(content,normal);\n};\n\nParser.prototype.parseRepeated = function() {\n\tvar wantArrow = this.options.arrow;\n\t// Consume the {\n\tthis.advance();\n\t// Parse the content\n\tvar content = this.parseContent(),\n\t\tseparator = null;\n\t// Parse the separator if there is one\n\tif(this.eat(\"+\")) {\n\t\tseparator = this.parseContent();\n\t}\n\t// Consume the closing bracket\n\tthis.close(\"}\");\n\t// Create a component\n\treturn new components.Repeated(content,separator,wantArrow);\n};\n\nParser.prototype.parseSequence = function() {\n\t// Consume the <-\n\tthis.advance();\n\t// Parse the content\n\tvar content = this.parseContent();\n\t// Consume the closing ->\n\tthis.close(\"->\");\n\t// Create a component\n\treturn new components.Sequence(content);\n};\n\nParser.prototype.parseTerminal = function() {\n\tvar component = new components.Terminal(this.token.value);\n\t// Consume the string literal\n\tthis.advance();\n    return component;\n};\n\nParser.prototype.parseTransclusion = function() {\n\t// Consume the {{\n\tthis.advance();\n\t// Consume the text reference\n\tvar textRef = this.expectNameOrString(\"as transclusion source\");\n\t// Consume the closing }}\n\tthis.close(\"}}\");\n\t// Retrieve the content of the text reference\n\tvar source = this.widget.wiki.getTextReference(textRef,\"\",this.widget.getVariable(\"currentTiddler\"));\n\t// Parse the content\n\tvar content = new Parser(this.widget,source).content;\n\t// Create a component\n\treturn new components.Transclusion(content);\n};\n\n/////////////////////////// Pragmas\n\nParser.prototype.parsePragma = function() {\n\t// Create a dummy component\n\tvar component = { isPragma: true };\n\t// Consume the pragma\n\tvar pragma = this.token.value;\n\tthis.advance();\n\t// Apply the setting\n\tif(pragma === \"arrow\") {\n\t\tthis.options.arrow = this.parseYesNo(pragma);\t\t\n\t} else if(pragma === \"debug\") {\n\t\tthis.options.debug = true;\n\t} else if(pragma === \"start\") {\n\t\tthis.options.start = this.parseTerminusStyle(pragma);\t\t\n\t} else if(pragma === \"end\") {\n\t\tthis.options.end = this.parseTerminusStyle(pragma);\t\t\n\t} else {\n\t\tthrow \"Invalid pragma\";\n\t}\n\treturn component;\n};\n\nParser.prototype.parseYesNo = function(pragma) {\n\treturn this.parseSetting([\"yes\",\"no\"],pragma) === \"yes\";\n}\n\nParser.prototype.parseTerminusStyle = function(pragma) {\n\treturn this.parseSetting([\"single\",\"double\",\"none\"],pragma);\n}\n\nParser.prototype.parseSetting = function(options,pragma) {\n\tif(this.at(\"name\") && options.indexOf(this.token.value) !== -1) {\n\t\treturn this.tokenValueEaten();\t\t\n\t}\n\tthrow options.join(\" or \") + \" expected after \\\\\" + pragma;\n}\n\n/////////////////////////// Token manipulation\n\nParser.prototype.advance = function() {\n\tif(this.tokenPos >= this.tokens.length) {\n\t\tthis.token = null;\n\t}\n\tthis.token = this.tokens[this.tokenPos++];\n};\n\nParser.prototype.at = function(token) {\n\treturn this.token && (this.token.type === token || this.token.type === \"token\" && this.token.value === token);\n};\n\nParser.prototype.eat = function(token) {\n\tvar at = this.at(token);\n\tif(at) {\n\t\tthis.advance();\n\t}\n\treturn at;\n};\n\nParser.prototype.tokenValueEaten = function() {\n\tvar output = this.token.value;\n\tthis.advance();\n\treturn output;\n};\n\nParser.prototype.close = function(token) {\n\tif(!this.eat(token)) {\n\t\tthrow \"Closing \" + token + \" expected\";\n\t}\n};\n\nParser.prototype.checkFinished = function() {\n\tif(this.token) {\n\t\tthrow \"Syntax error at \" + this.token.value;\n\t}\n};\n\nParser.prototype.expect = function(token) {\n\tif(!this.eat(token)) {\n\t\tthrow token + \" expected\";\n\t}\n};\n\nParser.prototype.expectString = function(context,token) {\n\tif(!this.at(\"string\")) {\n\t\ttoken = token || \"String\";\n\t\tthrow token + \" expected \" + context;\n\t}\n\treturn this.tokenValueEaten();\n};\n\nParser.prototype.expectNameOrString = function(context) {\n\tif(this.at(\"name\")) {\n\t\treturn this.tokenValueEaten();\n\t}\n\treturn this.expectString(context,\"Name or string\");\n};\n\n/////////////////////////// Tokenisation\n\nParser.prototype.tokenise = function(source) {\n\tvar tokens = [],\n\t\tpos = 0,\n\t\tc, s, token;\n\twhile(pos < source.length) {\n\t\t// Initialise this iteration\n\t\ts = token = null;\n\t\t// Skip whitespace\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\n\t\t// Avoid falling off the end of the string\n\t\tif (pos >= source.length) {\n\t\t\tbreak;\n\t\t}\n\t\t// Examine the next character\n\t\tc = source.charAt(pos);\n\t\tif(\"\\\"'\".indexOf(c) !== -1) {\n\t\t\t// String literal\n\t\t\ttoken = $tw.utils.parseStringLiteral(source,pos);\n\t\t\tif(!token) {\n\t\t\t\tthrow \"Unterminated string literal\";\n\t\t\t}\n\t\t} else if(\"[]{}\".indexOf(c) !== -1) {\n\t\t\t// Single or double character\n\t\t\ts = source.charAt(pos+1) === c ? c + c : c;\n\t\t} else if(c === \"<\") {\n\t\t\t// < or <-\n\t\t\ts = source.charAt(pos+1) === \"-\" ? \"<-\" : \"<\";\n\t\t} else if(c === \"-\") {\n\t\t\t// - or ->\n\t\t\ts = source.charAt(pos+1) === \">\" ? \"->\" : \"-\";\n\t\t} else if(\"()>+/:|\".indexOf(c) !== -1) {\n\t\t\t// Single character\n\t\t\ts = c;\n\t\t} else if(c.match(/[a-zA-Z]/)) {\n\t\t\t// Name\n\t\t\ttoken = this.readName(source,pos);\n\t\t} else if(c.match(/\\\\/)) {\n\t\t\t// Pragma\n\t\t\ttoken = this.readPragma(source,pos);\n\t\t} else {\n\t\t\tthrow \"Syntax error at \" + c;\n\t\t}\n\t\t// Add our findings to the return array\n\t\tif(token) {\n\t\t\ttokens.push(token);\n\t\t} else {\n\t\t\ttoken = $tw.utils.parseTokenString(source,pos,s);\n\t\t\ttokens.push(token);\n\t\t}\n\t\t// Prepare for the next character\n\t\tpos = token.end;\n\t}\n\treturn tokens;\n};\n\nParser.prototype.readName = function(source,pos) {\n\tvar re = /([a-zA-Z0-9_.-]+)/g;\n\tre.lastIndex = pos;\n\tvar match = re.exec(source);\n\tif(match && match.index === pos) {\n\t\treturn {type: \"name\", value: match[1], start: pos, end: pos+match[1].length};\n\t} else {\n\t\tthrow \"Invalid name\";\n\t}\n};\n\nParser.prototype.readPragma = function(source,pos) {\n\tvar re = /([a-z]+)/g;\n\tpos++;\n\tre.lastIndex = pos;\n\tvar match = re.exec(source);\n\tif(match && match.index === pos) {\n\t\treturn {type: \"pragma\", value: match[1], start: pos, end: pos+match[1].length};\n\t} else {\n\t\tthrow \"Invalid pragma\";\n\t}\n};\n\n/////////////////////////// Exports\n\nexports.parser = Parser;\n\n})();","type":"application/javascript","module-type":"library"},"$:/plugins/tiddlywiki/railroad/typed-parser.js":{"title":"$:/plugins/tiddlywiki/railroad/typed-parser.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/railroad/typed-parser.js\ntype: application/javascript\nmodule-type: parser\n\nThis parser wraps unadorned railroad syntax into a railroad widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar RailroadParser = function(type,text,options) {\n\tvar element = {\n\t\t\ttype: \"railroad\",\n\t\t\ttag: \"$railroad\",\n\t\t\ttext: text\n\t\t};\n\tthis.tree = [element];\nconsole.log(text);\n};\n\nexports[\"text/vnd.tiddlywiki.railroad\"] = RailroadParser;\n\n})();\n\n","type":"application/javascript","module-type":"parser"},"$:/plugins/tiddlywiki/railroad/wrapper.js":{"title":"$:/plugins/tiddlywiki/railroad/wrapper.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/railroad/wrapper.js\ntype: application/javascript\nmodule-type: widget\n\nWrapper for `railroad-diagrams.js` that provides a `<$railroad>` widget.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Parser = require(\"$:/plugins/tiddlywiki/railroad/parser.js\").parser,\n\tWidget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar RailroadWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\nvar RAILROAD_OPTIONS = \"$:/config/railroad\";\n\n/*\nInherit from the base widget class\n*/\nRailroadWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nRailroadWidget.prototype.render = function(parent,nextSibling) {\n\t// Housekeeping\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\t// Get the source text\n\tvar source = this.getAttribute(\"text\",this.parseTreeNode.text || \"\");\n\t// Create a div to contain the SVG or error message\n\tvar div = this.document.createElement(\"div\");\n\ttry {\n\t\t// Initialise options from the config tiddler or widget attributes\n\t\tvar config = $tw.wiki.getTiddlerData(RAILROAD_OPTIONS,{});\n\t\tvar options = {\n\t\t\tarrow: this.getAttribute(\"arrow\", config.arrow || \"yes\") === \"yes\",\n\t\t\tdebug: this.getAttribute(\"debug\", config.debug || \"no\") === \"yes\",\n\t\t\tstart: this.getAttribute(\"start\", config.start || \"single\"),\n\t\t\tend: this.getAttribute(\"end\", config.end || \"single\")\n\t\t};\n\t\t// Parse the source\n\t\tvar parser = new Parser(this,source,options);\n\t\t// Generate content into the div\n\t\tif(parser.options.debug) {\n\t\t\tthis.renderDebug(parser,div);\n\t\t} else {\n\t\t\tthis.renderSvg(parser,div);\n\t\t}\n\t} catch(ex) {\n\t\tdiv.className = \"tc-error\";\n\t\tdiv.textContent = ex;\n\t}\n\t// Insert the div into the DOM\n\tparent.insertBefore(div,nextSibling);\n\tthis.domNodes.push(div);\n};\n\nRailroadWidget.prototype.renderDebug = function(parser,div) {\n\tvar output = [\"<pre>\"];\n\tparser.root.debug(output, \"\");\n\toutput.push(\"</pre>\");\n\tdiv.innerHTML = output.join(\"\");\n};\n\nRailroadWidget.prototype.renderSvg = function(parser,div) {\n\t// Generate a model of the diagram\n\tvar fakeSvg = parser.root.toSvg(parser.options);\n\t// Render the model into a tree of SVG DOM nodes\n\tvar svg = fakeSvg.toSVG();\n\t// Fill in the remaining attributes of any link nodes\n\tthis.patchLinks(svg);\n\t// Insert the SVG tree into the div\n\tdiv.appendChild(svg);\n};\n\nRailroadWidget.prototype.patchLinks = function(node) {\n\tvar self = this;\n\tif(!$tw.node && node.hasChildNodes()) {\n\t\tvar children = node.childNodes;\n\t\tfor(var i=0; i<children.length; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar attributes = child.attributes;\n\t\t\tif(attributes) {\n\t\t\t\t// Find each element that has a data-tw-target attribute\n\t\t\t\tvar target = child.attributes[\"data-tw-target\"];\n\t\t\t\tif(target !== undefined) {\n\t\t\t\t\ttarget = target.value;\n\t\t\t\t\tif(child.attributes[\"data-tw-external\"]) {\n\t\t\t\t\t\t// External links are straightforward\n\t\t\t\t\t\tchild.setAttribute(\"target\",\"_blank\");\n\t\t\t\t\t\tchild.setAttribute(\"rel\",\"noopener noreferrer\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Each internal link gets its own onclick handler, capturing its own copy of target\n\t\t\t\t\t\t(function(myTarget) {\n\t\t\t\t\t\t\tchild.onclick = function(event) {\n\t\t\t\t\t\t\t\tself.dispatchLink(myTarget,event);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})(target);\n\t\t\t\t\t\ttarget = \"#\" + target;\n\t\t\t\t\t}\n\t\t\t\t\tchild.setAttributeNS(\"http://www.w3.org/1999/xlink\",\"href\",target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.patchLinks(child);\n\t\t}\n\t}\n};\n\nRailroadWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(changedAttributes.text || changedTiddlers[RAILROAD_OPTIONS]) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn false;\t\n};\n\nRailroadWidget.prototype.dispatchLink = function(to,event) {\n\t// Send the click on its way as a navigate event\n\tvar bounds = this.domNodes[0].getBoundingClientRect();\n\tthis.dispatchEvent({\n\t\ttype: \"tm-navigate\",\n\t\tnavigateTo: to,\n\t\tnavigateFromTitle: this.getVariable(\"storyTiddler\"),\n\t\tnavigateFromNode: this,\n\t\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\n\t\t},\n\t\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey || (event.button === 1)\n\t});\n\tevent.preventDefault();\n\tevent.stopPropagation();\n\treturn false;\n};\n\nexports.railroad = RailroadWidget;\n\n})();","type":"application/javascript","module-type":"widget"}}}