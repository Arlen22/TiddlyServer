{"title":"$:/plugins/tiddlywiki/tw2parser","description":"TiddlyWiki Classic parser","authors":"JeremyRuston, JeffreyWilkinson","core-version":">=5.0.15","list":"readme","version":"5.1.21-prerelease","plugin-type":"plugin","dependents":"","type":"application/json","tiddlers":{"$:/core/ui/ViewTemplate/classic":{"title":"$:/core/ui/ViewTemplate/classic","tags":"$:/tags/ViewTemplate $:/tags/EditTemplate","type":"text/vnd.tiddlywiki","text":"\n\n"},"$:/core/modules/widgets/classictransclude.js":{"title":"$:/core/modules/widgets/classictransclude.js","text":"/*\\\ntitle: $:/core/modules/widgets/classictransclude.js\ntype: application/javascript\nmodule-type: widget\n\nTransclude widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar sliceSeparator = \"::\";\nvar sectionSeparator = \"##\";\n\nfunction getsectionname(title) {\n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sectionSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(pos + sectionSeparator.length);\n\t}\n\treturn \"\";\n}\nfunction getslicename(title) { \n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sliceSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(pos + sliceSeparator.length);\n\t}\n\treturn \"\";\n};\nfunction gettiddlername(title) {\n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sectionSeparator);\n\n\tif(pos != -1) {\n\t\treturn title.substr(0,pos);\n\t}\n\tpos = title.indexOf(sliceSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(0,pos);\n\t}\n\treturn title;\n}\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar TranscludeWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nTranscludeWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nTranscludeWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nCompute the internal state of the widget\n*/\nTranscludeWidget.prototype.execute = function() {\n\t// Get our parameters\n\tthis.rawTitle = this.getAttribute(\"tiddler\",this.getVariable(\"currentTiddler\"));\n\tthis.transcludeTitle = gettiddlername(this.rawTitle);\n\tthis.section = getsectionname(this.rawTitle);\n\tthis.slice = getslicename(this.rawTitle);\n\t// Check for recursion\n\tvar recursionMarker = this.makeRecursionMarker();\n\tif(this.parentWidget && this.parentWidget.hasVariable(\"transclusion\",recursionMarker)) {\n\t\tthis.makeChildWidgets([{type: \"text\", text: $tw.language.getString(\"Error/RecursiveTransclusion\")}]);\n\t\treturn;\n\t}\n\t// Check for correct type\n\tvar existingTiddler = this.wiki.getTiddler(this.transcludeTitle);\n\t// Check if we're dealing with a classic tiddler\n\tif(existingTiddler && existingTiddler.hasField(\"type\") && existingTiddler.fields.type !== \"text/x-tiddlywiki\") {\n\t\tthis.makeChildWidgets([{type: \"text\", text: \"Tiddler not of type 'text/x-tiddlywiki'\"}]);\n\t\treturn;\n\t}\n\tif(existingTiddler && !existingTiddler.hasField(\"type\")) {\n\t\tthis.makeChildWidgets([{type: \"text\", text: \"Tiddler not of type 'text/x-tiddlywiki'\"}]);\n\t\treturn;\n\t}\t\t\n\t// Set context variables for recursion detection\n\tthis.setVariable(\"transclusion\",recursionMarker);\n\t// Parse \n\tvar text = this.wiki.getTiddlerText(this.transcludeTitle);\n\tif (!!this.section||!!this.slice) {\n\t\ttext =this.refineTiddlerText(text, this.section, this.slice);\n\t}\n\n\tthis.options  ={};\n\tthis.options.parseAsInline = false;\n\tvar parser = this.wiki.parseText(\"text/x-tiddlywiki\",text,{});\n\tvar\tparseTreeNodes = parser ? parser.tree : this.parseTreeNode.children;\n\t// Construct the child widgets\n\tthis.makeChildWidgets(parseTreeNodes);\n};\n/*\nCompose a string comprising the title, field and/or index to identify this transclusion for recursion detection\n*/\nTranscludeWidget.prototype.makeRecursionMarker = function() {\n\tvar output = [];\n\toutput.push(\"{\");\n\toutput.push(this.getVariable(\"currentTiddler\",{defaultValue: \"\"}));\n\toutput.push(\"|\");\n\toutput.push(this.transcludeTitle || \"\");\n\toutput.push(\"|\");\n\toutput.push(this.transcludeField || \"\");\n\toutput.push(\"|\");\n\toutput.push(this.transcludeIndex || \"\");\n\toutput.push(\"|\");\n\toutput.push(this.section || \"\");\n\toutput.push(\"|\");\n\toutput.push(this.slice || \"\");\n\toutput.push(\"}\");\n\treturn output.join(\"\");\n};\n\nTranscludeWidget.prototype.slicesRE = /(?:^([\\'\\/]{0,2})~?([\\.\\w]+)\\:\\1[\\t\\x20]*([^\\n]*)[\\t\\x20]*$)|(?:^\\|([\\'\\/]{0,2})~?([\\.\\w]+)\\:?\\4\\|[\\t\\x20]*([^\\|\\n]*)[\\t\\x20]*\\|$)/gm;\n\nTranscludeWidget.prototype.calcAllSlices = function(text)\n{\n\tvar slices = {};\n\tthis.slicesRE.lastIndex = 0;\n\tvar m = this.slicesRE.exec(text);\n\twhile(m) {\n\t\tif(m[2])\n\t\t\tslices[m[2]] = m[3];\n\t\telse\n\t\t\tslices[m[5]] = m[6];\n\t\tm = this.slicesRE.exec(text);\n\t}\n\treturn slices;\n};\n\n// Returns the slice of text of the given name\nTranscludeWidget.prototype.getTextSlice = function(text,sliceName)\n{\n\treturn (this.calcAllSlices(text))[sliceName];\n};\n\nTranscludeWidget.prototype.refineTiddlerText = function(text,section,slice)\n{\n\tvar textsection = null;\n\tif (slice) {\n\t\tvar textslice = this.getTextSlice(text,slice);\n\t\tif(textslice)\n\t\t\treturn textslice;\n\t}\n\tif(!section)\n\t\treturn text;\n\tvar re = new RegExp(\"(^!{1,6}[ \\t]*\" + $tw.utils.escapeRegExp(section) + \"[ \\t]*\\n)\",\"mg\");\n\tre.lastIndex = 0;\n\tvar match = re.exec(text);\n\tif(match) {\n\t\tvar t = text.substr(match.index+match[1].length);\n\t\tvar re2 = /^!/mg;\n\t\tre2.lastIndex = 0;\n\t\tmatch = re2.exec(t); //# search for the next heading\n\t\tif(match)\n\t\t\tt = t.substr(0,match.index-1);//# don't include final \\n\n\t\treturn t;\n\t}\n\treturn \"\";\n}\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nTranscludeWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(changedAttributes.tiddler ||changedTiddlers[this.transcludeTitle]) {\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\t\t\n\t}\n};\n\nexports.classictransclude = TranscludeWidget;\n\n})();\n","type":"application/javascript","module-type":"widget"},"$:/macros/tiddlywiki/entry.js":{"title":"$:/macros/tiddlywiki/entry.js","text":"/*\\\ntitle: $:/macros/tiddlywiki/entry.js\ntype: application/javascript\nmodule-type: macro\n\\*/\n(function(){\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n/*\nInformation about this macro\nreturns value of key in a data json tiddler\nnote that macros are not connected with the refresh mechanism -use with caution.\n*/\nexports.name = \"entryof\";\n\nexports.params = [\n\t{ name: \"key\" }, { name: \"map\" }\n];\n/*\nRun the macro\n*/\nexports.run = function(key,map) {\n\ttry{\n\t\treturn  JSON.parse(map)[key];\n\t} catch(e) {\n\t\treturn \"\";\n\t}\n}\n})();\n","type":"application/javascript","module-type":"macro"},"$:/plugins/tiddlywiki/tw2parser/image-css":{"title":"$:/plugins/tiddlywiki/tw2parser/image-css","tags":"$:/tags/Stylesheet","type":"text/plain","text":".classic-image-left{\n     float: left;\n}\n\n.classic-image-right{\n     float: right;\n}\n"},"$:/plugins/tiddlywiki/tw2parser/macrodefs":{"title":"$:/plugins/tiddlywiki/tw2parser/macrodefs","text":"\\define tiddler(tiddler)\n<$classictransclude tiddler = \"$tiddler$\"/>\n\\end\n\n\\define slider(chkUniqueCookieName tiddler label tooltip)\n<span title=$tooltip$><$button popup=\"$chkUniqueCookieName$\" class=\"tc-btn-invisible tc-slider\">$label$</$button>\n<$reveal type=\"nomatch\" text=\"\" default=\"\" state=\"$chkUniqueCookieName$\" animate=\"yes\">\n<$classictransclude tiddler = \"$tiddler$\"/>\n</$reveal></span>\n\\end\n\n\\define __system_tabinstance(state, currentTab, prompts, labels)\n\t\t<span title=<<entryof \"$currentTab$\" \"\"\"$prompts$\"\"\">> ><$button set=<<qualify \"$state$\">> setTo=\"$currentTab$\" selectedClass=\"tc-tab-selected\">\n\t\t<<entryof \"$currentTab$\" \"\"\"$labels$\"\"\" >>\n\t\t</$button></span>\n\\end\n\n\\define __system_tabs(tabsList,prompts,labels,state:\"$:/state/tab\")\n<div class=\"tc-tab-buttons\">\n\t<$list filter=\"$tabsList$\" variable=\"currentTab\">\n\t\t<$macrocall $name=\"__system_tabinstance\" state=\"$state$\" prompts=\"\"\"$prompts$\"\"\" labels=\"\"\"$labels$\"\"\" currentTab=<<currentTab>>/>\n\t</$list>\n</div>\n<div class=\"tc-tab-divider\"/>\n<div class=\"tc-tab-content\">\n\t<$list filter=\"$tabsList$\" variable=\"currentTab\">\n\t\t<$reveal type=\"match\" state=<<qualify \"$state$\">> text=<<currentTab>> default=\"$default$\">\n\t\t\t<$classictransclude tiddler=<<currentTab>> />\n\t\t</$reveal>\n\t</$list>\n</div>\n\\end\n"},"$:/macros/classic/macroadapter.js":{"title":"$:/macros/classic/macroadapter.js","text":"/*\\\ntitle: $:/macros/classic/macroadapter.js\ntype: application/javascript\nmodule-type: module\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n/*\nInformation about this module:\nrename macros and\nre-jig macro params from tw2 to tw5 style\nnew macros created as a result of adapting tw2 should be \nprepended \"__system\" to distinguish them from the actual used name\n*/\nvar sliceSeparator = \"::\";\nvar sectionSeparator = \"##\";\n\nfunction getsectionname(title) {\n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sectionSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(pos + sectionSeparator.length);\n\t}\n\treturn \"\";\n}\nfunction getslicename(title) { \n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sliceSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(pos + sliceSeparator.length);\n\t}\n\treturn \"\";\n};\nfunction gettiddlername(title) {\n\tif(!title)\n\t\treturn \"\";\n\tvar pos = title.indexOf(sectionSeparator);\n\n\tif(pos != -1) {\n\t\treturn title.substr(0,pos);\n\t}\n\tpos = title.indexOf(sliceSeparator);\n\tif(pos != -1) {\n\t\treturn title.substr(0,pos);\n\t}\n\treturn title;\n}\n\nvar parserparams = function(paramString) {\n\tvar params = [],\n\t\treParam = /\\s*(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\"'\\s]+)))/mg,\n\t\tparamMatch = reParam.exec(paramString);\n\twhile(paramMatch) {\n\t\t// Process this parameter\n\t\tvar paramInfo = {\n\t\t\tvalue: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]\n\t\t};\n\t\tif(paramMatch[1]) {\n\t\t\tparamInfo.name = paramMatch[1];\n\t\t}\n\t\tparams.push(paramInfo);\n\t\t// Find the next match\n\t\tparamMatch = reParam.exec(paramString);\n\t}\n\treturn params;\n}\nvar tabshandler = function(paramstring) {\n\tvar params = parserparams(paramstring);\n\tvar cookie = params[0].value;\n\tvar numTabs = (params.length-1)/3;\n\tvar t;\n\tvar tabslist = \"\";\n\tvar labelarray = {};\n    var promptarray = {};\n\tfor(t=0; t<numTabs; t++) {\n\t\tvar contentName = params[t*3+3].value;\n\t\ttabslist = tabslist+\" \" + contentName;\n\t\tlabelarray[contentName] = params[t*3+1].value;\n\t\tpromptarray[contentName] = params[t*3+2].value;\n\t} \n\t//Create a list of names (tiddlers, tiddler/sections, tiddler/slices), and create maps from name -> label and name -> prompt\n\t//Use json to implement maps \n\treturn '\"\"\"'+tabslist +'\"\"\" \"\"\"'+JSON.stringify(promptarray)+'\"\"\" \"\"\"'+JSON.stringify(labelarray)+'\"\"\" \"\"\"'+cookie+'\"\"\"';\n};\nvar namedapter = {tabs:'__system_tabs'};\nvar paramadapter = {\n\ttabs: tabshandler\n}\nexports.name = 'macroadapter';\nexports.namedapter = namedapter;\nexports.paramadapter = paramadapter;\n})();\n","type":"application/javascript","module-type":"module"},"$:/plugins/tiddlywiki/tw2parser/readme":{"title":"$:/plugins/tiddlywiki/tw2parser/readme","text":"This experimental plugin provides support for parsing and rendering tiddlers written in TiddlyWiki Classic format (`text/x-tiddlywiki`).\n\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/tw2parser]]\n"},"$:/plugins/tiddlywiki/tw2parser/wikitextparser.js":{"title":"$:/plugins/tiddlywiki/tw2parser/wikitextparser.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/tw2parser/wikitextparser.js\ntype: application/javascript\nmodule-type: parser\n\nParses a block of tiddlywiki-format wiki text into a parse tree object. This is a transliterated version of the old TiddlyWiki code. The plan is to replace it with a new, mostly backwards compatible parser built in PEGJS.\n\nA wikitext parse tree is an array of objects with a `type` field that can be `text`,`macro` or the name of an HTML element.\n\nText nodes are represented as `{type: \"text\", value: \"A string of text\"}`.\n\nMacro nodes look like this:\n`\n{type: \"macro\", name: \"view\", params: {\n\tone: {type: \"eval\", value: \"2+2\"},\n\ttwo: {type: \"string\", value: \"twenty two\"}\n}}\n`\nHTML nodes look like this:\n`\n{type: \"div\", attributes: {\n\tsrc: \"one\"\n\tstyles: {\n\t\t\"background-color\": \"#fff\",\n\t\t\"color\": \"#000\"\n\t}\n}}\n`\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\nCreates a new instance of the wiki text parser with the specified options. The\noptions are a hashmap of mandatory members as follows:\n\n\twiki: The wiki object to use to parse any cascaded content (eg transclusion)\n\nPlanned:\n\n\tenableRules: An array of names of wiki text rules to enable. If not specified, all rules are available\n\textraRules: An array of additional rule handlers to add\n\tenableMacros: An array of names of macros to enable. If not specified, all macros are available\n\textraMacros: An array of additional macro handlers to add\n*/\n\nvar WikiTextParser = function(type,text,options) {\n\tthis.wiki = options.wiki;\n\tthis.autoLinkWikiWords = true;\n\tthis.installRules();\n\ttext = text || \"no text\";\n\tthis.source = text;\n\tthis.nextMatch = 0;\n\tthis.children = [];\n\tthis.tree =[];\n\tthis.output = null;\n\tthis.subWikify(this.children);\n\t// prepend tw2 macros locally to the content\n\tvar parser = $tw.wiki.parseTiddler(\"$:/plugins/tiddlywiki/tw2parser/macrodefs\",{parseAsInline:false});\n\tthis.tree = [{\n\t\ttype: \"element\",\n\t\ttag: \"div\",\n\t\tchildren:this.children\n\t}];\n\t// clone the output of parser \n\tvar root = JSON.parse(JSON.stringify(parser.tree));\n\t// macros are defined in a linear tree; walk down the tree and append the source's parsed content \n\tvar baseroot = root;\n\twhile (root[0] && root[0].children && root[0].children.length !== 0 ){ \n\t\troot = root[0].children;\n\t}\n\troot[0].children[0] = this.tree[0];\n\tthis.tree = baseroot;\n};\n\n\nWikiTextParser.prototype.installRules = function() {\n\tvar rules = require(\"./wikitextrules.js\").rules,\n\t\tpattern = [];\n\tfor(var n=0; n<rules.length; n++) {\n\t\tpattern.push(\"(\" + rules[n].match + \")\");\n\t}\n\tthis.rules = rules;\n\tthis.rulesRegExp = new RegExp(pattern.join(\"|\"),\"mg\");\n};\n\n\nWikiTextParser.prototype.outputText = function(place,startPos,endPos) {\n\tif(startPos < endPos) {\n\t\tplace.push({type: \"text\",text:this.source.substring(startPos,endPos)});\n\t}\n};\n\nWikiTextParser.prototype.subWikify = function(output,terminator) {\n\t// Handle the terminated and unterminated cases separately, this speeds up wikifikation by about 30%\n\tif(terminator)\n\t\tthis.subWikifyTerm(output,new RegExp(\"(\" + terminator + \")\",\"mg\"));\n\telse\n\t\tthis.subWikifyUnterm(output);\n};\n\nWikiTextParser.prototype.subWikifyUnterm = function(output) {\n\t// subWikify can be indirectly recursive, so we need to save the old output pointer\n\tvar oldOutput = this.output;\n\tthis.output = output;\n\t// Get the first match\n\tthis.rulesRegExp.lastIndex = this.nextMatch;\n\tvar ruleMatch = this.rulesRegExp.exec(this.source);\n\twhile(ruleMatch) {\n\t\t// Output any text before the match\n\t\tif(ruleMatch.index > this.nextMatch)\n\t\t\tthis.outputText(this.output,this.nextMatch,ruleMatch.index);\n\t\t// Set the match parameters for the handler\n\t\tthis.matchStart = ruleMatch.index;\n\t\tthis.matchLength = ruleMatch[0].length;\n\t\tthis.matchText = ruleMatch[0];\n\t\tthis.nextMatch = this.rulesRegExp.lastIndex;\n\t\t// Figure out which rule matched and call its handler\n\t\tvar t;\n\t\tfor(t=1; t<ruleMatch.length; t++) {\n\t\t\tif(ruleMatch[t]) {\n\t\t\t\tthis.rules[t-1].handler(this);\n\t\t\t\tthis.rulesRegExp.lastIndex = this.nextMatch;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Get the next match\n\t\truleMatch = this.rulesRegExp.exec(this.source);\n\t}\n\t// Output any text after the last match\n\tif(this.nextMatch < this.source.length) {\n\t\tthis.outputText(this.output,this.nextMatch,this.source.length);\n\t\tthis.nextMatch = this.source.length;\n\t}\n\t// Restore the output pointer\n\tthis.output = oldOutput;\n};\n\nWikiTextParser.prototype.subWikifyTerm = function(output,terminatorRegExp) {\n\t// subWikify can be indirectly recursive, so we need to save the old output pointer\n\tvar oldOutput = this.output;\n\tthis.output = output;\n\t// Get the first matches for the rule and terminator RegExps\n\tterminatorRegExp.lastIndex = this.nextMatch;\n\tvar terminatorMatch = terminatorRegExp.exec(this.source);\n\tthis.rulesRegExp.lastIndex = this.nextMatch;\n\tvar ruleMatch = this.rulesRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);\n\twhile(terminatorMatch || ruleMatch) {\n\t\t// Check for a terminator match before the next rule match\n\t\tif(terminatorMatch && (!ruleMatch || terminatorMatch.index <= ruleMatch.index)) {\n\t\t\t// Output any text before the match\n\t\t\tif(terminatorMatch.index > this.nextMatch)\n\t\t\t\tthis.outputText(this.output,this.nextMatch,terminatorMatch.index);\n\t\t\t// Set the match parameters\n\t\t\tthis.matchText = terminatorMatch[1];\n\t\t\tthis.matchLength = terminatorMatch[1].length;\n\t\t\tthis.matchStart = terminatorMatch.index;\n\t\t\tthis.nextMatch = this.matchStart + this.matchLength;\n\t\t\t// Restore the output pointer\n\t\t\tthis.output = oldOutput;\n\t\t\treturn;\n\t\t}\n\t\t// It must be a rule match; output any text before the match\n\t\tif(ruleMatch.index > this.nextMatch)\n\t\t\tthis.outputText(this.output,this.nextMatch,ruleMatch.index);\n\t\t// Set the match parameters\n\t\tthis.matchStart = ruleMatch.index;\n\t\tthis.matchLength = ruleMatch[0].length;\n\t\tthis.matchText = ruleMatch[0];\n\t\tthis.nextMatch = this.rulesRegExp.lastIndex;\n\t\t// Figure out which rule matched and call its handler\n\t\tvar t;\n\t\tfor(t=1; t<ruleMatch.length; t++) {\n\t\t\tif(ruleMatch[t]) {\n\t\t\t\tthis.rules[t-1].handler(this);\n\t\t\t\tthis.rulesRegExp.lastIndex = this.nextMatch;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Get the next match\n\t\tterminatorRegExp.lastIndex = this.nextMatch;\n\t\tterminatorMatch = terminatorRegExp.exec(this.source);\n\t\truleMatch = this.rulesRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);\n\t}\n\t// Output any text after the last match\n\tif(this.nextMatch < this.source.length) {\n\t\tthis.outputText(this.output,this.nextMatch,this.source.length);\n\t\tthis.nextMatch = this.source.length;\n\t}\n\t// Restore the output pointer\n\tthis.output = oldOutput;\n};\n\nexports[\"text/x-tiddlywiki\"] = WikiTextParser;\n\n})();\n","type":"application/javascript","module-type":"parser"},"$:/plugins/tiddlywiki/tw2parser/wikitextrules.js":{"title":"$:/plugins/tiddlywiki/tw2parser/wikitextrules.js","text":"/*\\\ntitle: $:/plugins/tiddlywiki/tw2parser/wikitextrules.js\ntype: application/javascript\nmodule-type: module\n\nRule modules for the wikitext parser\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\nvar macroadapter = require(\"$:/macros/classic/macroadapter.js\");\nvar textPrimitives = {\n\tupperLetter: \"[A-Z\\u00c0-\\u00de\\u0150\\u0170]\",\n\tlowerLetter: \"[a-z0-9_\\\\-\\u00df-\\u00ff\\u0151\\u0171]\",\n\tanyLetter:   \"[A-Za-z0-9_\\\\-\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\tanyLetterStrict: \"[A-Za-z0-9\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\n\tsliceSeparator: \"::\",\n\tsectionSeparator: \"##\",\n\turlPattern: \"(?:file|http|https|mailto|ftp|irc|news|data):[^\\\\s'\\\"]+(?:/|\\\\b)\",\n\tunWikiLink: \"~\",\n\tbrackettedLink: \"\\\\[\\\\[([^\\\\]]+)\\\\]\\\\]\",\n\ttitledBrackettedLink: \"\\\\[\\\\[([^\\\\[\\\\]\\\\|]+)\\\\|([^\\\\[\\\\]\\\\|]+)\\\\]\\\\]\"\n};\n\ntextPrimitives.wikiLink = \"(?:(?:\" + textPrimitives.upperLetter + \"+\" +\n\t\t\t\t\t\t\ttextPrimitives.lowerLetter + \"+\" +\n\t\t\t\t\t\t\ttextPrimitives.upperLetter +\n\t\t\t\t\t\t\ttextPrimitives.anyLetter + \"*)|(?:\" +\n\t\t\t\t\t\t\ttextPrimitives.upperLetter + \"{2,}\" +\n\t\t\t\t\t\t\ttextPrimitives.lowerLetter + \"+))\";\n\ntextPrimitives.cssLookahead = \"(?:(\" + textPrimitives.anyLetter +\n\t\"+)\\\\(([^\\\\)\\\\|\\\\n]+)(?:\\\\):))|(?:(\" + textPrimitives.anyLetter + \"+):([^;\\\\|\\\\n]+);)\";\n\ntextPrimitives.cssLookaheadRegExp = new RegExp(textPrimitives.cssLookahead,\"mg\");\n\ntextPrimitives.tiddlerForcedLinkRegExp = new RegExp(\"(?:\" + textPrimitives.titledBrackettedLink + \")|(?:\" +\n\ttextPrimitives.brackettedLink + \")|(?:\" +\n\ttextPrimitives.urlPattern + \")\",\"mg\");\n\ntextPrimitives.tiddlerAnyLinkRegExp = new RegExp(\"(\"+ textPrimitives.wikiLink + \")|(?:\" +\n\ttextPrimitives.titledBrackettedLink + \")|(?:\" +\n\ttextPrimitives.brackettedLink + \")|(?:\" +\n\ttextPrimitives.urlPattern + \")\",\"mg\");\n\n// Helper to add an attribute to an HTML node\nvar setAttr = function(node,attr,value) {\n\tif(!node.attributes) {\n\t\tnode.attributes = {};\n\t}\n\tnode.attributes[attr] ={type: \"string\", value:value} ;\n};\n\nvar inlineCssHelper = function(w) {\n\tvar styles = [];\n\ttextPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;\n\tvar lookaheadMatch = textPrimitives.cssLookaheadRegExp.exec(w.source);\n\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\n\t\tvar s,v;\n\t\tif(lookaheadMatch[1]) {\n\t\t\ts = lookaheadMatch[1];\n\t\t\tv = lookaheadMatch[2];\n\t\t} else {\n\t\t\ts = lookaheadMatch[3];\n\t\t\tv = lookaheadMatch[4];\n\t\t}\n\t\tif(s==\"bgcolor\")\n\t\t\ts = \"backgroundColor\";\n\t\tif(s==\"float\")\n\t\t\ts = \"cssFloat\";\n\t\tstyles.push({style: s, value: v});\n\t\tw.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;\n\t\ttextPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;\n\t\tlookaheadMatch = textPrimitives.cssLookaheadRegExp.exec(w.source);\n\t}\n\treturn styles;\n};\n\nvar applyCssHelper = function(e,styles) {\n\n\tif(styles.length > 0) {\n\n\t\tfor(var t=0; t< styles.length; t++) {\n\t\t\t$tw.utils.addStyleToParseTreeNode(e,$tw.utils.roundTripPropertyName(styles[t].style),styles[t].value);\n\t\t}\n\t}\n\t\n};\n\nvar enclosedTextHelper = function(w) {\n\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\tvar text = lookaheadMatch[1];\n\t\tw.output.push({type:\"element\",tag:this.element,\n\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\n\t\tw.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;\n\t}\n};\n\nvar insertMacroCall = function(w,output,macroName,paramString) {\n\tvar params = [],\n\t\treParam = /\\s*(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\"'\\s]+)))/mg,\n\t\tparamMatch = reParam.exec(paramString);\n\twhile(paramMatch) {\n\t\t// Process this parameter\n\t\tvar paramInfo = {\n\t\t\tvalue: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]\n\t\t};\n\t\tif(paramMatch[1]) {\n\t\t\tparamInfo.name = paramMatch[1];\n\t\t}\n\t\tparams.push(paramInfo);\n\t\t// Find the next match\n\t\tparamMatch = reParam.exec(paramString);\n\t}\n\toutput.push({\n\t\ttype: \"macrocall\",\n\t\tname: macroName,\n\t\tparams: params,\n\t\tisBlock: false\n\t});\n}\n\n\nvar isLinkExternal = function(to) {\n\tvar externalRegExp = /(?:file|http|https|mailto|ftp|irc|news|data|skype):[^\\s'\"]+(?:\\/|\\b)/i;\n\treturn externalRegExp.test(to);\n};\nvar rules = [\n{\n\tname: \"table\",\n\tmatch: \"^\\\\|(?:[^\\\\n]*)\\\\|(?:[fhck]?)$\",\n\tlookaheadRegExp: /^\\|([^\\n]*)\\|([fhck]?)$/mg,\n\trowTermRegExp: /(\\|(?:[fhck]?)$\\n?)/mg,\n\tcellRegExp: /(?:\\|([^\\n\\|]*)\\|)|(\\|[fhck]?$\\n?)/mg,\n\tcellTermRegExp: /((?:\\x20*)\\|)/mg,\n\trowTypes: {\"c\":\"caption\", \"h\":\"thead\", \"\":\"tbody\", \"f\":\"tfoot\"},\n\thandler: function(w)\n\t{\n\t\tvar table = {type:\"element\",tag:\"table\",attributes: {\"class\": {type: \"string\", value:\"table\"}},\n\t\t\t\t\tchildren: []};\n\t\t\n\t\tw.output.push(table);\n\t\tvar prevColumns = [];\n\t\tvar currRowType = null;\n\t\tvar rowContainer;\n\t\tvar rowCount = 0;\n\t\tw.nextMatch = w.matchStart;\n\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\n\t\t\tvar nextRowType = lookaheadMatch[2];\n\t\t\tif(nextRowType == \"k\") {\n\t\t\t\ttable.attributes[\"class\"] = lookaheadMatch[1];\n\t\t\t\tw.nextMatch += lookaheadMatch[0].length+1;\n\t\t\t} else {\n\t\t\t\tif(nextRowType != currRowType) {\n\t\t\t\t\trowContainer = {type:\"element\",tag:this.rowTypes[nextRowType],children: []};\n\t\t\t\t\ttable.children.push(rowContainer);\n\t\t\t\t\tcurrRowType = nextRowType;\n\t\t\t\t}\n\t\t\t\tif(currRowType == \"c\") {\n\t\t\t\t\t// Caption\n\t\t\t\t\tw.nextMatch++;\n\t\t\t\t\t// Move the caption to the first row if it isn't already\n\t\t\t\t\tif(table.children.length !== 1) {\n\t\t\t\t\t\ttable.children.pop(); // Take rowContainer out of the children array\n\t\t\t\t\t\ttable.children.splice(0,0,rowContainer); // Insert it at the bottom\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\trowContainer.attributes={};\n\t\t\t\t\trowContainer.attributes.align = rowCount === 0 ? \"top\" : \"bottom\";\n\t\t\t\t\tw.subWikifyTerm(rowContainer.children,this.rowTermRegExp);\n\t\t\t\t} else {\n\t\t\t\t\tvar theRow = {type:\"element\",tag:\"tr\",\n\t\t\t\t\t\tattributes: {\"class\": {type: \"string\", value:rowCount%2 ? \"oddRow\" : \"evenRow\"}},\n\t\t\t\t\t\tchildren: []};\n\t\t\t\t\t\n\t\t\t\t\trowContainer.children.push(theRow);\n\t\t\t\t\tthis.rowHandler(w,theRow.children,prevColumns);\n\t\t\t\t\trowCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\n\t\t\tlookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\t}\n\t},\n\trowHandler: function(w,e,prevColumns)\n\t{\n\t\tvar col = 0;\n\t\tvar colSpanCount = 1;\n\t\tvar prevCell = null;\n\t\tthis.cellRegExp.lastIndex = w.nextMatch;\n\t\tvar cellMatch = this.cellRegExp.exec(w.source);\n\t\twhile(cellMatch && cellMatch.index == w.nextMatch) {\n\t\t\tif(cellMatch[1] == \"~\") {\n\t\t\t\t// Rowspan\n\t\t\t\tvar last = prevColumns[col];\n\t\t\tif(last) {\n\t\t\t\tlast.rowSpanCount++;\n\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"rowspan\",last.rowSpanCount);\n\t\t\t\tvar vAlign = $tw.utils.getAttributeValueFromParseTreeNode(last.element,\"valign\",\"center\");\n\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"valign\",vAlign);\n\t\t\t\tif(colSpanCount > 1) {\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"colspan\",colSpanCount);\n\t\t\t\t\tcolSpanCount = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex-1;\n\t\t\t} else if(cellMatch[1] == \">\") {\n\t\t\t\t// Colspan\n\t\t\t\tcolSpanCount++;\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex-1;\n\t\t\t} else if(cellMatch[2]) {\n\t\t\t\t// End of row\n\t\t\t\tif(prevCell && colSpanCount > 1) {\n\t\t\t\t\tprevCell.attributes.colspan = colSpanCount;\n\t\t\t\t}\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Cell\n\t\t\t\tw.nextMatch++;\n\t\t\t\tvar styles = inlineCssHelper(w);\n\t\t\t\tvar spaceLeft = false;\n\t\t\t\tvar chr = w.source.substr(w.nextMatch,1);\n\t\t\t\twhile(chr == \" \") {\n\t\t\t\t\tspaceLeft = true;\n\t\t\t\t\tw.nextMatch++;\n\t\t\t\t\tchr = w.source.substr(w.nextMatch,1);\n\t\t\t\t}\n\t\t\t\tvar cell;\n\t\t\t\tif(chr == \"!\") {\n\t\t\t\t\tcell = {type:\"element\",tag:\"th\",children: []};\n\t\t\t\t\te.push(cell);\n\t\t\t\t\tw.nextMatch++;\n\t\t\t\t} else {\n\t\t\t\t\tcell = {type:\"element\",tag:\"td\",children: []};\n\t\t\t\t\te.push(cell);\n\t\t\t\t}\n\t\t\t\tprevCell = cell;\n\t\t\t\tprevColumns[col] = {rowSpanCount:1,element:cell};\n\t\t\t\tif(colSpanCount > 1) {\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"colspan\",colSpanCount);\n\t\t\t\t\tcolSpanCount = 1;\n\t\t\t\t}\n\t\t\t\tapplyCssHelper(cell,styles);\n\t\t\t\tw.subWikifyTerm(cell.children,this.cellTermRegExp);\n\t\t\t\tif (!cell.attributes) cell.attributes ={};\n\t\t\t\tif(w.matchText.substr(w.matchText.length-2,1) == \" \") // spaceRight\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"align\",spaceLeft ? \"center\" : \"left\");\n\t\t\t\telse if(spaceLeft)\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"align\",\"right\");\n\t\t\t\tw.nextMatch--;\n\t\t\t}\n\t\t\tcol++;\n\t\t\tthis.cellRegExp.lastIndex = w.nextMatch;\n\t\t\tcellMatch = this.cellRegExp.exec(w.source);\n\t\t}\n\t}\n},\n\n{\n\tname: \"heading\",\n\tmatch: \"^!{1,6}\",\n\ttermRegExp: /(\\n)/mg,\n\thandler: function(w)\n\t{\n\t\tvar e = {type:\"element\",tag:\"h\" + w.matchLength,children: []};\n\t\tw.output.push(e);\n\t\tw.subWikifyTerm(e.children,this.termRegExp);\n\t}\n},\n\n{\n\tname: \"list\",\n\tmatch: \"^(?:[\\\\*#;:]+)\",\n\tlookaheadRegExp: /^(?:(?:(\\*)|(#)|(;)|(:))+)/mg,\n\ttermRegExp: /(\\n)/mg,\n\thandler: function(w)\n\t{\n\t\tvar stack = [w.output];\n\t\tvar currLevel = 0, currType = null;\n\t\tvar listLevel, listType, itemType, baseType;\n\t\tw.nextMatch = w.matchStart;\n\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\n\t\t\tif(lookaheadMatch[1]) {\n\t\t\t\tlistType = \"ul\";\n\t\t\t\titemType = \"li\";\n\t\t\t} else if(lookaheadMatch[2]) {\n\t\t\t\tlistType = \"ol\";\n\t\t\t\titemType = \"li\";\n\t\t\t} else if(lookaheadMatch[3]) {\n\t\t\t\tlistType = \"dl\";\n\t\t\t\titemType = \"dt\";\n\t\t\t} else if(lookaheadMatch[4]) {\n\t\t\t\tlistType = \"dl\";\n\t\t\t\titemType = \"dd\";\n\t\t\t}\n\t\t\tif(!baseType)\n\t\t\t\tbaseType = listType;\n\t\t\tlistLevel = lookaheadMatch[0].length;\n\t\t\tw.nextMatch += lookaheadMatch[0].length;\n\t\t\tvar t,e;\n\t\t\tif(listLevel > currLevel) {\n\t\t\t\tfor(t=currLevel; t<listLevel; t++) {\n\t\t\t\t\tvar target = stack[stack.length-1];\n\t\t\t\t\tif(currLevel !== 0 && target.children) {\n\t\t\t\t\t\ttarget = target.children[target.children.length-1];\n\t\t\t\t\t}\n\t\t\t\t\te = {type:\"element\",tag:listType,children: []};\n\t\t\t\t\ttarget.push(e);\n\t\t\t\t\tstack.push(e.children);\n\t\t\t\t}\n\t\t\t} else if(listType!=baseType && listLevel==1) {\n\t\t\t\tw.nextMatch -= lookaheadMatch[0].length;\n\t\t\t\treturn;\n\t\t\t} else if(listLevel < currLevel) {\n\t\t\t\tfor(t=currLevel; t>listLevel; t--)\n\t\t\t\t\tstack.pop();\n\t\t\t} else if(listLevel == currLevel && listType != currType) {\n\t\t\t\tstack.pop();\n\t\t\t\te = {type:\"element\",tag:listType,children: []};\n\t\t\t\tstack[stack.length-1].push(e);\n\t\t\t\tstack.push(e.children);\n\t\t\t}\n\t\t\tcurrLevel = listLevel;\n\t\t\tcurrType = listType;\n\t\t\te = {type:\"element\",tag:itemType,children: []};\n\t\t\tstack[stack.length-1].push(e);\n\t\t\tw.subWikifyTerm(e.children,this.termRegExp);\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\n\t\t\tlookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\t}\n\t}\n},\n\n{\n\tname: \"quoteByBlock\",\n\tmatch: \"^<<<\\\\n\",\n\ttermRegExp: /(^<<<(\\n|$))/mg,\n\telement: \"blockquote\",\n\thandler:  function(w) {\n\t\tvar e = {type:\"element\",tag:this.element,children: []};\n\t\tw.output.push(e);\n\t\tw.subWikifyTerm(e.children,this.termRegExp);\n\t}\n},\n\n{\n\tname: \"quoteByLine\",\n\tmatch: \"^>+\",\n\tlookaheadRegExp: /^>+/mg,\n\ttermRegExp: /(\\n)/mg,\n\telement: \"blockquote\",\n\thandler: function(w)\n\t{\n\t\tvar stack = [];\n\t\tvar currLevel = 0;\n\t\tvar newLevel = w.matchLength;\n\t\tvar t,matched,e;\n\t\tdo {\n\t\t\tif(newLevel > currLevel) {\n\t\t\t\tfor(t=currLevel; t<newLevel; t++) {\n\t\t\t\t\tvar f = stack[stack.length-1];\n\t\t\t\t\te = {type:\"element\",tag:this.element,children: []};\n\t\t\t\t\tstack.push(e);\n\t\t\t\t\tif (t ===0){\n\t\t\t\t\t\tw.output.push(e);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tf.children.push(e);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(newLevel < currLevel) {\n\t\t\t\tfor(t=currLevel; t>newLevel; t--)\n\t\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tcurrLevel = newLevel;\n\t\t\tw.subWikifyTerm(stack[stack.length-1].children,this.termRegExp);\n\t\t\tstack[stack.length-1].children.push({type:\"element\",tag:\"br\"});\n\t\t\t//e.push({type:\"element\",tag:\"br\"});\n\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\n\t\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\t\tmatched = lookaheadMatch && lookaheadMatch.index == w.nextMatch;\n\t\t\tif(matched) {\n\t\t\t\tnewLevel = lookaheadMatch[0].length;\n\t\t\t\tw.nextMatch += lookaheadMatch[0].length;\n\t\t\t}\n\t\t} while(matched);\n\t}\n},\n\n{\n\tname: \"rule\",\n\tmatch: \"^----+$\\\\n?|<hr ?/?>\\\\n?\",\n\thandler: function(w)\n\t{\n\t\tw.output.push({type:\"element\",tag:\"hr\"});\n\t}\n},\n\n{\n\tname: \"monospacedByLine\",\n\tmatch: \"^(?:/\\\\*\\\\{\\\\{\\\\{\\\\*/|\\\\{\\\\{\\\\{|//\\\\{\\\\{\\\\{|<!--\\\\{\\\\{\\\\{-->)\\\\n\",\n\telement: \"pre\",\n\thandler: function(w)\n\t{\n\t\tswitch(w.matchText) {\n\t\tcase \"/*{{{*/\\n\": // CSS\n\t\t\tthis.lookaheadRegExp = /\\/\\*\\{\\{\\{\\*\\/\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*\\/\\*\\}\\}\\}\\*\\/$\\n?)/mg;\n\t\t\tbreak;\n\t\tcase \"{{{\\n\": // monospaced block\n\t\t\tthis.lookaheadRegExp = /^\\{\\{\\{\\n((?:^[^\\n]*\\n)+?)(^\\f*\\}\\}\\}$\\n?)/mg;\n\t\t\tbreak;\n\t\tcase \"//{{{\\n\": // plugin\n\t\t\tthis.lookaheadRegExp = /^\\/\\/\\{\\{\\{\\n\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*\\/\\/\\}\\}\\}$\\n?)/mg;\n\t\t\tbreak;\n\t\tcase \"<!--{{{-->\\n\": //template\n\t\t\tthis.lookaheadRegExp = /<!--\\{\\{\\{-->\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*<!--\\}\\}\\}-->$\\n?)/mg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tenclosedTextHelper.call(this,w);\n\t}\n},\n\n{\n\tname: \"typedBlock\",\n\t\tmatch: \"^\\\\$\\\\$\\\\$(?:[^ >\\\\r\\\\n]*)\\\\r?\\\\n\",\n\tlookaheadRegExp: /^\\$\\$\\$([^ >\\r\\n]*)\\n((?:^[^\\n]*\\r?\\n)+?)(^\\f*\\$\\$\\$\\r?\\n?)/mg,\n\t//match: \"^\\\\$\\\\$\\\\$(?:[^ >\\\\r\\\\n]*)(?: *> *([^ \\\\r\\\\n]+))?\\\\r?\\\\n\",\n\t//lookaheadRegExp: /^\\$\\$\\$([^ >\\r\\n]*)(?: *> *([^ \\r\\n]+))\\n((?:^[^\\n]*\\n)+?)(^\\f*\\$\\$\\$$\\n?)/mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\t// The wikitext parsing infrastructure is horribly unre-entrant\n\t\t\tvar parseType = lookaheadMatch[1],\n\t\t\t\trenderType ,//= this.match[2],\n\t\t\t\ttext = lookaheadMatch[2],\n\t\t\t\toldOutput = w.output,\n\t\t\t\toldSource = w.source,\n\t\t\t\toldNextMatch = w.nextMatch,\n\t\t\t\toldChildren = w.children;\n\t\t\t// Parse the block according to the specified type\n\t\t\tvar parser = $tw.wiki.parseText(parseType,text.toString(),{defaultType: \"text/plain\"});\n\n\t\t\tw.output = oldOutput;\n\t\t\tw.source = oldSource;\n\t\t\tw.nextMatch = oldNextMatch;\n\t\t\tw.children = oldChildren;\n\t\t\tfor (var i=0; i<parser.tree.length; i++) {\n\t\t\t\tw.output.push(parser.tree[i]);\n\t\t\t}\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t}\n\t}\n},\n\n{\n\tname: \"wikifyComment\",\n\tmatch: \"^(?:/\\\\*\\\\*\\\\*|<!---)\\\\n\",\n\thandler: function(w)\n\t{\n\t\tvar termRegExp = (w.matchText == \"/***\\n\") ? (/(^\\*\\*\\*\\/\\n)/mg) : (/(^--->\\n)/mg);\n\t\tw.subWikifyTerm(w.output,termRegExp);\n\t}\n},\n\n{\n\tname: \"macro\",\n\tmatch: \"<<\",\n\tlookaheadRegExp: /<<(?:([!@Â£\\$%\\^\\&\\*\\(\\)`\\~'\"\\|\\\\\\/;\\:\\.\\,\\+\\=\\-\\_\\{\\}])|([^>\\s]+))(?:\\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source),\n\t\t\tname;\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\tname = lookaheadMatch[1] || lookaheadMatch[2];\n\t\t\tvar params = lookaheadMatch[3], nameold =name;\n\t\t\tif (name) {\n\t\t\t\tif (!!macroadapter.paramadapter[name]) {\n\t\t\t\t\tparams=macroadapter.paramadapter[name](params);\n\t\t\t\t\t//alert(\"going out as \"+params);\n\t\t\t\t}\n\t\t\t\tif (!!macroadapter.namedapter[name]) {\n\t\t\t\t\tname=macroadapter.namedapter[name];\n\t\t\t\t}\n\t\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t\t\tinsertMacroCall(w,w.output,name,params);\n\t\t\t}\n\t\t}\n\t}\n},\n\n\n{\n\tname: \"prettyLink\",\n\tmatch: \"\\\\[\\\\[\",\n\tlookaheadRegExp: /\\[\\[(.*?)(?:\\|(~)?(.*?))?\\]\\]/mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\tvar text = lookaheadMatch[1],\n\t\t\t\tlink = text;\n\t\t\tif(lookaheadMatch[3]) {\n\t\t\t\t// Pretty bracketted link\n\t\t\t\tlink = lookaheadMatch[3];\n\t\t\t}\n\tif(isLinkExternal(link)) {\n\t\tw.output.push({\n\t\t\ttype: \"element\",\n\t\t\ttag: \"a\",\n\t\t\tattributes: {\n\t\t\t\thref: {type: \"string\", value: link},\n\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\n\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\n\t\t\t},\n\t\t\tchildren: [{\n\t\t\t\ttype: \"text\", text: text\n\t\t\t}]\n\t\t});\n\t} else {\n\t\tw.output.push({\n\t\t\ttype: \"link\",\n\t\t\tattributes: {\n\t\t\t\tto: {type: \"string\", value: link}\n\t\t\t},\n\t\t\tchildren: [{\n\t\t\t\ttype: \"text\", text: text\n\t\t\t}]\n\t\t});\n\t}\n\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t}\n\t}\n},\n{\n\tname: \"wikiLink\",\n\tmatch: textPrimitives.unWikiLink+\"?\"+textPrimitives.wikiLink,\n\thandler: function(w)\n\t{\n\t\tif(w.matchText.substr(0,1) == textPrimitives.unWikiLink) {\n\t\t\tw.outputText(w.output,w.matchStart+1,w.nextMatch);\n\t\t\treturn;\n\t\t}\n\t\tif(w.matchStart > 0) {\n\t\t\tvar preRegExp = new RegExp(textPrimitives.anyLetterStrict,\"mg\");\n\t\t\tpreRegExp.lastIndex = w.matchStart-1;\n\t\t\tvar preMatch = preRegExp.exec(w.source);\n\t\t\tif(preMatch.index == w.matchStart-1) {\n\t\t\t\tw.outputText(w.output,w.matchStart,w.nextMatch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(w.autoLinkWikiWords) {\n\t\t\tw.output.push({\n\t\t\t\ttype: \"link\",\n\t\t\t\tattributes: {\n\t\t\t\t\tto: {type: \"string\", value: w.matchText}\n\t\t\t\t},\n\t\t\t\tchildren: [{\n\t\t\t\t\ttype: \"text\",\n\t\t\t\t\ttext: w.source.substring(w.matchStart,w.nextMatch)\n\t\t\t\t}]\n\t\t\t});\n\t\t} else {\t\n\t\t\tw.outputText(w.output,w.matchStart,w.nextMatch);\n\t\t}\n\t}\n},\n\n{\n\tname: \"urlLink\",\n\tmatch: textPrimitives.urlPattern,\n\thandler: function(w)\n\t{\n\t\t\tw.output.push({\n\t\t\ttype: \"element\",\n\t\t\ttag: \"a\",\n\t\t\tattributes: {\n\t\t\t\thref: {type: \"string\", value: w.matchText},\n\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\n\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\n\t\t\t},\n\t\t\tchildren: [{\n\t\t\t\ttype: \"text\", text: w.source.substring(w.matchStart,w.nextMatch)\n\t\t\t}]\n\t\t});\n\n\t}\n},\n\n{\n\tname: \"image\",\n\tmatch: \"\\\\[[<>]?[Ii][Mm][Gg]\\\\[\",\n\t// [<] sequence below is to avoid lessThan-questionMark sequence so TiddlyWikis can be included in PHP files\n\tlookaheadRegExp: /\\[([<]?)(>?)[Ii][Mm][Gg]\\[(?:([^\\|\\]]+)\\|)?([^\\[\\]\\|]+)\\](?:\\[([^\\]]*)\\])?\\]/mg,\n\thandler: function(w)\n\t{\n\t\tvar node = {\n\t\t\ttype: \"image\",\n\t\t\tattributes: {}\n\t\t};\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source),\n\t\t\timageParams = {},\n\t\t\tlinkParams = {};\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\tif(lookaheadMatch[1]) {\n\t\t\t\tnode.attributes.class = {type: \"string\", value: \"classic-image-left\"};\n\t\t\t} else if(lookaheadMatch[2]) {\n\t\t\t\tnode.attributes.class  = {type: \"string\", value: \"classic-image-right\"};\n\t\t\t}\n\t\t\tif(lookaheadMatch[3]) {\n\t\t\t\tnode.attributes.tooltip = {type: \"string\", value: lookaheadMatch[3]};\n\t\t\t}\n\t\t\tnode.attributes.source = {type: \"string\", value: lookaheadMatch[4]};\n\t\t\tif(lookaheadMatch[5]) {\n\t\t\t\tif(isLinkExternal(lookaheadMatch[5])) {\n\t\t\t\t\tw.output.push({\n\t\t\t\t\t\ttype: \"element\",\n\t\t\t\t\t\ttag: \"a\",\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\thref: {type: \"string\", value:lookaheadMatch[5]},\n\t\t\t\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\n\t\t\t\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: [node]\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tw.output.push({\n\t\t\t\t\t\ttype: \"link\",\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\tto: {type: \"string\", value: lookaheadMatch[5]}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: [node]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw.output.push(node);\n\t\t\t}\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t}\n\t}\n},\n\n{\n\tname: \"html\",\n\tmatch: \"<[Hh][Tt][Mm][Ll]>\",\n\tlookaheadRegExp: /<[Hh][Tt][Mm][Ll]>((?:.|\\n)*?)<\\/[Hh][Tt][Mm][Ll]>/mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\tw.output.push({\ttype:\"raw\", html:lookaheadMatch[1]});\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t}\n\t}\n},\n\n{\n\tname: \"commentByBlock\",\n\tmatch: \"/%\",\n\tlookaheadRegExp: /\\/%((?:.|\\n)*?)%\\//mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart)\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t}\n},\n\n{\n\tname: \"characterFormat\",\n\tmatch: \"''|//|__|\\\\^\\\\^|~~|--(?!\\\\s|$)|\\\\{\\\\{\\\\{|`\",\n\thandler: function(w)\n\t{\n\t\tvar e,lookaheadRegExp,lookaheadMatch;\n\t\tswitch(w.matchText) {\n\t\tcase \"''\":\n\t\t\te = {type:\"element\",tag:\"strong\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/('')/mg);\n\t\t\tbreak;\n\t\tcase \"//\":\n\t\t\te = {type:\"element\",tag:\"em\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/(\\/\\/)/mg);\n\t\t\tbreak;\n\t\tcase \"__\":\n\t\t\te = {type:\"element\",tag:\"u\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/(__)/mg);\n\t\t\tbreak;\n\t\tcase \"^^\":\n\t\t\te = {type:\"element\",tag:\"sup\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/(\\^\\^)/mg);\n\t\t\tbreak;\n\t\tcase \"~~\":\n\t\t\te = {type:\"element\",tag:\"sub\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/(~~)/mg);\n\t\t\tbreak;\n\t\tcase \"--\":\n\t\t\te = {type:\"element\",tag:\"strike\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tw.subWikifyTerm(e.children,/(--)/mg);\n\t\t\tbreak;\n\t\tcase \"`\":\n\t\t\tlookaheadRegExp = /`((?:.|\\n)*?)`/mg;\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\n\t\t\tlookaheadMatch = lookaheadRegExp.exec(w.source);\n\t\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\t\tw.output.push({type:\"element\",tag:\"code\",\n\t\t\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"{{{\":\n\t\t\tlookaheadRegExp = /\\{\\{\\{((?:.|\\n)*?)\\}\\}\\}/mg;\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\n\t\t\tlookaheadMatch = lookaheadRegExp.exec(w.source);\n\t\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\t\tw.output.push({type:\"element\",tag:\"code\",\n\t\t\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\n\t\t\t\tw.nextMatch = lookaheadRegExp.lastIndex;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n},\n\n{\n\tname: \"customFormat\",\n\tmatch: \"@@|\\\\{\\\\{\",\n\thandler: function(w)\n\t{\n\t\tswitch(w.matchText) {\n\t\tcase \"@@\":\n\t\t\tvar e = {type:\"element\",tag:\"span\",children: []};\n\t\t\tw.output.push(e);\n\t\t\tvar styles = inlineCssHelper(w);\n\t\t\tif(styles.length === 0)\n\t\t\t\tsetAttr(e,\"class\",\"marked\");\n\t\t\telse\n\t\t\t\tapplyCssHelper(e,styles);\n\t\t\tw.subWikifyTerm(e.children,/(@@)/mg);\n\t\t\tbreak;\n\t\tcase \"{{\":\n\t\t\tvar lookaheadRegExp = /\\{\\{[\\s]*([\\-\\w]+[\\-\\s\\w]*)[\\s]*\\{(\\n?)/mg;\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\n\t\t\tvar lookaheadMatch = lookaheadRegExp.exec(w.source);\n\t\t\tif(lookaheadMatch) {\n\t\t\t\tw.nextMatch = lookaheadRegExp.lastIndex;\n\t\t\t\te = {type:\"element\",tag:lookaheadMatch[2] == \"\\n\" ? \"div\" : \"span\",\n\t\t\t\t\tattributes: {\"class\": {type: \"string\", value:lookaheadMatch[1]}},children: []};\n\t\t\t\tw.output.push(e);\n\t\t\t\tw.subWikifyTerm(e.children,/(\\}\\}\\})/mg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n},\n\n{\n\tname: \"mdash\",\n\tmatch: \"--\",\n\thandler: function(w)\n\t{\n\t\tw.output.push({type: \"entity\", entity: \"&mdash;\"});\n\t}\n},\n\n{\n\tname: \"lineBreak\",\n\tmatch: \"\\\\n|<br ?/?>\",\n\thandler: function(w)\n\t{\n\t\tw.output.push({type:\"element\",tag:\"br\"});\n\t}\n},\n\n{\n\tname: \"rawText\",\n\tmatch: \"\\\"{3}|<nowiki>\",\n\tlookaheadRegExp: /(?:\\\"{3}|<nowiki>)((?:.|\\n)*?)(?:\\\"{3}|<\\/nowiki>)/mg,\n\thandler: function(w)\n\t{\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\n\t\t\tw.output.push({type: \"text\",text: lookaheadMatch[1]\n\t\t\t});\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\n\t\t}\n\t}\n},\n\n{\n\tname: \"htmlEntitiesEncoding\",\n\tmatch: \"&#?[a-zA-Z0-9]{2,8};\",\n\thandler: function(w)\n\t{\n\t\tw.output.push({type: \"entity\", entity: w.matchText});\n\t}\n}\n\n];\n\nexports.rules = rules;\n\n})();\n","type":"application/javascript","module-type":"module"}}}