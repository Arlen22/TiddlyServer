{"title":"$:/plugins/tiddlywiki/tw2parser","description":"TiddlyWiki Classic parser","authors":"JeremyRuston, JeffreyWilkinson","core-version":">=5.0.15","list":"readme","version":"5.1.18-prerelease","plugin-type":"plugin","dependents":"","type":"application/json","tiddlers":{"$:/core/ui/ViewTemplate/classic":{"title":"$:/core/ui/ViewTemplate/classic","tags":"$:/tags/ViewTemplate $:/tags/EditTemplate","type":"text/vnd.tiddlywiki","text":"\n\n"},"$:/core/modules/widgets/classictransclude.js":{"title":"$:/core/modules/widgets/classictransclude.js","text":"/*\\\r\ntitle: $:/core/modules/widgets/classictransclude.js\r\ntype: application/javascript\r\nmodule-type: widget\r\n\r\nTransclude widget\r\n\r\n\\*/\r\n(function(){\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\nvar sliceSeparator = \"::\";\r\nvar sectionSeparator = \"##\";\r\n\r\nfunction getsectionname(title) {\r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sectionSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(pos + sectionSeparator.length);\r\n\t}\r\n\treturn \"\";\r\n}\r\nfunction getslicename(title) { \r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sliceSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(pos + sliceSeparator.length);\r\n\t}\r\n\treturn \"\";\r\n};\r\nfunction gettiddlername(title) {\r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sectionSeparator);\r\n\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(0,pos);\r\n\t}\r\n\tpos = title.indexOf(sliceSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(0,pos);\r\n\t}\r\n\treturn title;\r\n}\r\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\r\n\r\nvar TranscludeWidget = function(parseTreeNode,options) {\r\n\tthis.initialise(parseTreeNode,options);\r\n};\r\n\r\n/*\r\nInherit from the base widget class\r\n*/\r\nTranscludeWidget.prototype = new Widget();\r\n\r\n/*\r\nRender this widget into the DOM\r\n*/\r\nTranscludeWidget.prototype.render = function(parent,nextSibling) {\r\n\tthis.parentDomNode = parent;\r\n\tthis.computeAttributes();\r\n\tthis.execute();\r\n\tthis.renderChildren(parent,nextSibling);\r\n};\r\n\r\n/*\r\nCompute the internal state of the widget\r\n*/\r\nTranscludeWidget.prototype.execute = function() {\r\n\t// Get our parameters\r\n\tthis.rawTitle = this.getAttribute(\"tiddler\",this.getVariable(\"currentTiddler\"));\r\n\tthis.transcludeTitle = gettiddlername(this.rawTitle);\r\n\tthis.section = getsectionname(this.rawTitle);\r\n\tthis.slice = getslicename(this.rawTitle);\r\n\t// Check for recursion\r\n\tvar recursionMarker = this.makeRecursionMarker();\r\n\tif(this.parentWidget && this.parentWidget.hasVariable(\"transclusion\",recursionMarker)) {\r\n\t\tthis.makeChildWidgets([{type: \"text\", text: $tw.language.getString(\"Error/RecursiveTransclusion\")}]);\r\n\t\treturn;\r\n\t}\r\n\t// Check for correct type\r\n\tvar existingTiddler = this.wiki.getTiddler(this.transcludeTitle);\r\n\t// Check if we're dealing with a classic tiddler\r\n\tif(existingTiddler && existingTiddler.hasField(\"type\") && existingTiddler.fields.type !== \"text/x-tiddlywiki\") {\r\n\t\tthis.makeChildWidgets([{type: \"text\", text: \"Tiddler not of type 'text/x-tiddlywiki'\"}]);\r\n\t\treturn;\r\n\t}\r\n\tif(existingTiddler && !existingTiddler.hasField(\"type\")) {\r\n\t\tthis.makeChildWidgets([{type: \"text\", text: \"Tiddler not of type 'text/x-tiddlywiki'\"}]);\r\n\t\treturn;\r\n\t}\t\t\r\n\t// Set context variables for recursion detection\r\n\tthis.setVariable(\"transclusion\",recursionMarker);\r\n\t// Parse \r\n\tvar text = this.wiki.getTiddlerText(this.transcludeTitle);\r\n\tif (!!this.section||!!this.slice) {\r\n\t\ttext =this.refineTiddlerText(text, this.section, this.slice);\r\n\t}\r\n\r\n\tthis.options  ={};\r\n\tthis.options.parseAsInline = false;\r\n\tvar parser = this.wiki.parseText(\"text/x-tiddlywiki\",text,{});\r\n\tvar\tparseTreeNodes = parser ? parser.tree : this.parseTreeNode.children;\r\n\t// Construct the child widgets\r\n\tthis.makeChildWidgets(parseTreeNodes);\r\n};\r\n/*\r\nCompose a string comprising the title, field and/or index to identify this transclusion for recursion detection\r\n*/\r\nTranscludeWidget.prototype.makeRecursionMarker = function() {\r\n\tvar output = [];\r\n\toutput.push(\"{\");\r\n\toutput.push(this.getVariable(\"currentTiddler\",{defaultValue: \"\"}));\r\n\toutput.push(\"|\");\r\n\toutput.push(this.transcludeTitle || \"\");\r\n\toutput.push(\"|\");\r\n\toutput.push(this.transcludeField || \"\");\r\n\toutput.push(\"|\");\r\n\toutput.push(this.transcludeIndex || \"\");\r\n\toutput.push(\"|\");\r\n\toutput.push(this.section || \"\");\r\n\toutput.push(\"|\");\r\n\toutput.push(this.slice || \"\");\r\n\toutput.push(\"}\");\r\n\treturn output.join(\"\");\r\n};\r\n\r\nTranscludeWidget.prototype.slicesRE = /(?:^([\\'\\/]{0,2})~?([\\.\\w]+)\\:\\1[\\t\\x20]*([^\\n]*)[\\t\\x20]*$)|(?:^\\|([\\'\\/]{0,2})~?([\\.\\w]+)\\:?\\4\\|[\\t\\x20]*([^\\|\\n]*)[\\t\\x20]*\\|$)/gm;\r\n\r\nTranscludeWidget.prototype.calcAllSlices = function(text)\r\n{\r\n\tvar slices = {};\r\n\tthis.slicesRE.lastIndex = 0;\r\n\tvar m = this.slicesRE.exec(text);\r\n\twhile(m) {\r\n\t\tif(m[2])\r\n\t\t\tslices[m[2]] = m[3];\r\n\t\telse\r\n\t\t\tslices[m[5]] = m[6];\r\n\t\tm = this.slicesRE.exec(text);\r\n\t}\r\n\treturn slices;\r\n};\r\n\r\n// Returns the slice of text of the given name\r\nTranscludeWidget.prototype.getTextSlice = function(text,sliceName)\r\n{\r\n\treturn (this.calcAllSlices(text))[sliceName];\r\n};\r\n\r\nTranscludeWidget.prototype.refineTiddlerText = function(text,section,slice)\r\n{\r\n\tvar textsection = null;\r\n\tif (slice) {\r\n\t\tvar textslice = this.getTextSlice(text,slice);\r\n\t\tif(textslice)\r\n\t\t\treturn textslice;\r\n\t}\r\n\tif(!section)\r\n\t\treturn text;\r\n\tvar re = new RegExp(\"(^!{1,6}[ \\t]*\" + $tw.utils.escapeRegExp(section) + \"[ \\t]*\\n)\",\"mg\");\r\n\tre.lastIndex = 0;\r\n\tvar match = re.exec(text);\r\n\tif(match) {\r\n\t\tvar t = text.substr(match.index+match[1].length);\r\n\t\tvar re2 = /^!/mg;\r\n\t\tre2.lastIndex = 0;\r\n\t\tmatch = re2.exec(t); //# search for the next heading\r\n\t\tif(match)\r\n\t\t\tt = t.substr(0,match.index-1);//# don't include final \\n\r\n\t\treturn t;\r\n\t}\r\n\treturn \"\";\r\n}\r\n\r\n/*\r\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\r\n*/\r\nTranscludeWidget.prototype.refresh = function(changedTiddlers) {\r\n\tvar changedAttributes = this.computeAttributes();\r\n\tif(changedAttributes.tiddler ||changedTiddlers[this.transcludeTitle]) {\r\n\t\tthis.refreshSelf();\r\n\t\treturn true;\r\n\t} else {\r\n\t\treturn this.refreshChildren(changedTiddlers);\t\t\r\n\t}\r\n};\r\n\r\nexports.classictransclude = TranscludeWidget;\r\n\r\n})();\r\n","type":"application/javascript","module-type":"widget"},"$:/macros/tiddlywiki/entry.js":{"title":"$:/macros/tiddlywiki/entry.js","text":"/*\\\r\ntitle: $:/macros/tiddlywiki/entry.js\r\ntype: application/javascript\r\nmodule-type: macro\r\n\\*/\r\n(function(){\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n/*\r\nInformation about this macro\r\nreturns value of key in a data json tiddler\r\nnote that macros are not connected with the refresh mechanism -use with caution.\r\n*/\r\nexports.name = \"entryof\";\r\n\r\nexports.params = [\r\n\t{ name: \"key\" }, { name: \"map\" }\r\n];\r\n/*\r\nRun the macro\r\n*/\r\nexports.run = function(key,map) {\r\n\ttry{\r\n\t\treturn  JSON.parse(map)[key];\r\n\t} catch(e) {\r\n\t\treturn \"\";\r\n\t}\r\n}\r\n})();\r\n","type":"application/javascript","module-type":"macro"},"$:/plugins/tiddlywiki/tw2parser/image-css":{"title":"$:/plugins/tiddlywiki/tw2parser/image-css","tags":"$:/tags/Stylesheet","type":"text/plain","text":".classic-image-left{\r\n     float: left;\r\n}\n\n.classic-image-right{\r\n     float: right;\r\n}\r\n"},"$:/plugins/tiddlywiki/tw2parser/macrodefs":{"title":"$:/plugins/tiddlywiki/tw2parser/macrodefs","text":"\\define tiddler(tiddler)\r\n<$classictransclude tiddler = \"$tiddler$\"/>\r\n\\end\n\n\\define slider(chkUniqueCookieName tiddler label tooltip)\r\n<span title=$tooltip$><$button popup=\"$chkUniqueCookieName$\" class=\"tc-btn-invisible tc-slider\">$label$</$button>\r\n<$reveal type=\"nomatch\" text=\"\" default=\"\" state=\"$chkUniqueCookieName$\" animate=\"yes\">\r\n<$classictransclude tiddler = \"$tiddler$\"/>\r\n</$reveal></span>\r\n\\end\n\n\\define __system_tabinstance(state, currentTab, prompts, labels)\r\n\t\t<span title=<<entryof \"$currentTab$\" \"\"\"$prompts$\"\"\">> ><$button set=<<qualify \"$state$\">> setTo=\"$currentTab$\" selectedClass=\"tc-tab-selected\">\r\n\t\t<<entryof \"$currentTab$\" \"\"\"$labels$\"\"\" >>\r\n\t\t</$button></span>\r\n\\end\n\n\\define __system_tabs(tabsList,prompts,labels,state:\"$:/state/tab\")\r\n<div class=\"tc-tab-buttons\">\r\n\t<$list filter=\"$tabsList$\" variable=\"currentTab\">\r\n\t\t<$macrocall $name=\"__system_tabinstance\" state=\"$state$\" prompts=\"\"\"$prompts$\"\"\" labels=\"\"\"$labels$\"\"\" currentTab=<<currentTab>>/>\r\n\t</$list>\r\n</div>\r\n<div class=\"tc-tab-divider\"/>\r\n<div class=\"tc-tab-content\">\r\n\t<$list filter=\"$tabsList$\" variable=\"currentTab\">\r\n\t\t<$reveal type=\"match\" state=<<qualify \"$state$\">> text=<<currentTab>> default=\"$default$\">\r\n\t\t\t<$classictransclude tiddler=<<currentTab>> />\r\n\t\t</$reveal>\r\n\t</$list>\r\n</div>\r\n\\end\r\n"},"$:/macros/classic/macroadapter.js":{"title":"$:/macros/classic/macroadapter.js","text":"/*\\\r\ntitle: $:/macros/classic/macroadapter.js\r\ntype: application/javascript\r\nmodule-type: module\r\n\\*/\r\n(function(){\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n/*\r\nInformation about this module:\r\nrename macros and\r\nre-jig macro params from tw2 to tw5 style\r\nnew macros created as a result of adapting tw2 should be \r\nprepended \"__system\" to distinguish them from the actual used name\r\n*/\r\nvar sliceSeparator = \"::\";\r\nvar sectionSeparator = \"##\";\r\n\r\nfunction getsectionname(title) {\r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sectionSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(pos + sectionSeparator.length);\r\n\t}\r\n\treturn \"\";\r\n}\r\nfunction getslicename(title) { \r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sliceSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(pos + sliceSeparator.length);\r\n\t}\r\n\treturn \"\";\r\n};\r\nfunction gettiddlername(title) {\r\n\tif(!title)\r\n\t\treturn \"\";\r\n\tvar pos = title.indexOf(sectionSeparator);\r\n\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(0,pos);\r\n\t}\r\n\tpos = title.indexOf(sliceSeparator);\r\n\tif(pos != -1) {\r\n\t\treturn title.substr(0,pos);\r\n\t}\r\n\treturn title;\r\n}\r\n\r\nvar parserparams = function(paramString) {\r\n\tvar params = [],\r\n\t\treParam = /\\s*(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\"'\\s]+)))/mg,\r\n\t\tparamMatch = reParam.exec(paramString);\r\n\twhile(paramMatch) {\r\n\t\t// Process this parameter\r\n\t\tvar paramInfo = {\r\n\t\t\tvalue: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]\r\n\t\t};\r\n\t\tif(paramMatch[1]) {\r\n\t\t\tparamInfo.name = paramMatch[1];\r\n\t\t}\r\n\t\tparams.push(paramInfo);\r\n\t\t// Find the next match\r\n\t\tparamMatch = reParam.exec(paramString);\r\n\t}\r\n\treturn params;\r\n}\r\nvar tabshandler = function(paramstring) {\r\n\tvar params = parserparams(paramstring);\r\n\tvar cookie = params[0].value;\r\n\tvar numTabs = (params.length-1)/3;\r\n\tvar t;\r\n\tvar tabslist = \"\";\r\n\tvar labelarray = {};\r\n    var promptarray = {};\r\n\tfor(t=0; t<numTabs; t++) {\r\n\t\tvar contentName = params[t*3+3].value;\r\n\t\ttabslist = tabslist+\" \" + contentName;\r\n\t\tlabelarray[contentName] = params[t*3+1].value;\r\n\t\tpromptarray[contentName] = params[t*3+2].value;\r\n\t} \r\n\t//Create a list of names (tiddlers, tiddler/sections, tiddler/slices), and create maps from name -> label and name -> prompt\r\n\t//Use json to implement maps \r\n\treturn '\"\"\"'+tabslist +'\"\"\" \"\"\"'+JSON.stringify(promptarray)+'\"\"\" \"\"\"'+JSON.stringify(labelarray)+'\"\"\" \"\"\"'+cookie+'\"\"\"';\r\n};\r\nvar namedapter = {tabs:'__system_tabs'};\r\nvar paramadapter = {\r\n\ttabs: tabshandler\r\n}\r\nexports.name = 'macroadapter';\r\nexports.namedapter = namedapter;\r\nexports.paramadapter = paramadapter;\r\n})();\r\n","type":"application/javascript","module-type":"module"},"$:/plugins/tiddlywiki/tw2parser/readme":{"title":"$:/plugins/tiddlywiki/tw2parser/readme","text":"This experimental plugin provides support for parsing and rendering tiddlers written in TiddlyWiki Classic format (`text/x-tiddlywiki`).\n\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/tw2parser]]\r\n"},"$:/plugins/tiddlywiki/tw2parser/wikitextparser.js":{"title":"$:/plugins/tiddlywiki/tw2parser/wikitextparser.js","text":"/*\\\r\ntitle: $:/plugins/tiddlywiki/tw2parser/wikitextparser.js\r\ntype: application/javascript\r\nmodule-type: parser\r\n\r\nParses a block of tiddlywiki-format wiki text into a parse tree object. This is a transliterated version of the old TiddlyWiki code. The plan is to replace it with a new, mostly backwards compatible parser built in PEGJS.\r\n\r\nA wikitext parse tree is an array of objects with a `type` field that can be `text`,`macro` or the name of an HTML element.\r\n\r\nText nodes are represented as `{type: \"text\", value: \"A string of text\"}`.\r\n\r\nMacro nodes look like this:\r\n`\r\n{type: \"macro\", name: \"view\", params: {\r\n\tone: {type: \"eval\", value: \"2+2\"},\r\n\ttwo: {type: \"string\", value: \"twenty two\"}\r\n}}\r\n`\r\nHTML nodes look like this:\r\n`\r\n{type: \"div\", attributes: {\r\n\tsrc: \"one\"\r\n\tstyles: {\r\n\t\t\"background-color\": \"#fff\",\r\n\t\t\"color\": \"#000\"\r\n\t}\r\n}}\r\n`\r\n\r\n\\*/\r\n(function(){\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\n\r\n/*\r\nCreates a new instance of the wiki text parser with the specified options. The\r\noptions are a hashmap of mandatory members as follows:\r\n\r\n\twiki: The wiki object to use to parse any cascaded content (eg transclusion)\r\n\r\nPlanned:\r\n\r\n\tenableRules: An array of names of wiki text rules to enable. If not specified, all rules are available\r\n\textraRules: An array of additional rule handlers to add\r\n\tenableMacros: An array of names of macros to enable. If not specified, all macros are available\r\n\textraMacros: An array of additional macro handlers to add\r\n*/\r\n\r\nvar WikiTextParser = function(type,text,options) {\r\n\tthis.wiki = options.wiki;\r\n\tthis.autoLinkWikiWords = true;\r\n\tthis.installRules();\r\n\ttext = text || \"no text\";\r\n\tthis.source = text;\r\n\tthis.nextMatch = 0;\r\n\tthis.children = [];\r\n\tthis.tree =[];\r\n\tthis.output = null;\r\n\tthis.subWikify(this.children);\r\n\t// prepend tw2 macros locally to the content\r\n\tvar parser = $tw.wiki.parseTiddler(\"$:/plugins/tiddlywiki/tw2parser/macrodefs\",{parseAsInline:false});\r\n\tthis.tree = [{\r\n\t\ttype: \"element\",\r\n\t\ttag: \"div\",\r\n\t\tchildren:this.children\r\n\t}];\r\n\t// clone the output of parser \r\n\tvar root = JSON.parse(JSON.stringify(parser.tree));\r\n\t// macros are defined in a linear tree; walk down the tree and append the source's parsed content \r\n\tvar baseroot = root;\r\n\twhile (root[0] && root[0].children && root[0].children.length !== 0 ){ \r\n\t\troot = root[0].children;\r\n\t}\r\n\troot[0].children[0] = this.tree[0];\r\n\tthis.tree = baseroot;\r\n};\r\n\r\n\r\nWikiTextParser.prototype.installRules = function() {\r\n\tvar rules = require(\"./wikitextrules.js\").rules,\r\n\t\tpattern = [];\r\n\tfor(var n=0; n<rules.length; n++) {\r\n\t\tpattern.push(\"(\" + rules[n].match + \")\");\r\n\t}\r\n\tthis.rules = rules;\r\n\tthis.rulesRegExp = new RegExp(pattern.join(\"|\"),\"mg\");\r\n};\r\n\r\n\r\nWikiTextParser.prototype.outputText = function(place,startPos,endPos) {\r\n\tif(startPos < endPos) {\r\n\t\tplace.push({type: \"text\",text:this.source.substring(startPos,endPos)});\r\n\t}\r\n};\r\n\r\nWikiTextParser.prototype.subWikify = function(output,terminator) {\r\n\t// Handle the terminated and unterminated cases separately, this speeds up wikifikation by about 30%\r\n\tif(terminator)\r\n\t\tthis.subWikifyTerm(output,new RegExp(\"(\" + terminator + \")\",\"mg\"));\r\n\telse\r\n\t\tthis.subWikifyUnterm(output);\r\n};\r\n\r\nWikiTextParser.prototype.subWikifyUnterm = function(output) {\r\n\t// subWikify can be indirectly recursive, so we need to save the old output pointer\r\n\tvar oldOutput = this.output;\r\n\tthis.output = output;\r\n\t// Get the first match\r\n\tthis.rulesRegExp.lastIndex = this.nextMatch;\r\n\tvar ruleMatch = this.rulesRegExp.exec(this.source);\r\n\twhile(ruleMatch) {\r\n\t\t// Output any text before the match\r\n\t\tif(ruleMatch.index > this.nextMatch)\r\n\t\t\tthis.outputText(this.output,this.nextMatch,ruleMatch.index);\r\n\t\t// Set the match parameters for the handler\r\n\t\tthis.matchStart = ruleMatch.index;\r\n\t\tthis.matchLength = ruleMatch[0].length;\r\n\t\tthis.matchText = ruleMatch[0];\r\n\t\tthis.nextMatch = this.rulesRegExp.lastIndex;\r\n\t\t// Figure out which rule matched and call its handler\r\n\t\tvar t;\r\n\t\tfor(t=1; t<ruleMatch.length; t++) {\r\n\t\t\tif(ruleMatch[t]) {\r\n\t\t\t\tthis.rules[t-1].handler(this);\r\n\t\t\t\tthis.rulesRegExp.lastIndex = this.nextMatch;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Get the next match\r\n\t\truleMatch = this.rulesRegExp.exec(this.source);\r\n\t}\r\n\t// Output any text after the last match\r\n\tif(this.nextMatch < this.source.length) {\r\n\t\tthis.outputText(this.output,this.nextMatch,this.source.length);\r\n\t\tthis.nextMatch = this.source.length;\r\n\t}\r\n\t// Restore the output pointer\r\n\tthis.output = oldOutput;\r\n};\r\n\r\nWikiTextParser.prototype.subWikifyTerm = function(output,terminatorRegExp) {\r\n\t// subWikify can be indirectly recursive, so we need to save the old output pointer\r\n\tvar oldOutput = this.output;\r\n\tthis.output = output;\r\n\t// Get the first matches for the rule and terminator RegExps\r\n\tterminatorRegExp.lastIndex = this.nextMatch;\r\n\tvar terminatorMatch = terminatorRegExp.exec(this.source);\r\n\tthis.rulesRegExp.lastIndex = this.nextMatch;\r\n\tvar ruleMatch = this.rulesRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);\r\n\twhile(terminatorMatch || ruleMatch) {\r\n\t\t// Check for a terminator match before the next rule match\r\n\t\tif(terminatorMatch && (!ruleMatch || terminatorMatch.index <= ruleMatch.index)) {\r\n\t\t\t// Output any text before the match\r\n\t\t\tif(terminatorMatch.index > this.nextMatch)\r\n\t\t\t\tthis.outputText(this.output,this.nextMatch,terminatorMatch.index);\r\n\t\t\t// Set the match parameters\r\n\t\t\tthis.matchText = terminatorMatch[1];\r\n\t\t\tthis.matchLength = terminatorMatch[1].length;\r\n\t\t\tthis.matchStart = terminatorMatch.index;\r\n\t\t\tthis.nextMatch = this.matchStart + this.matchLength;\r\n\t\t\t// Restore the output pointer\r\n\t\t\tthis.output = oldOutput;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// It must be a rule match; output any text before the match\r\n\t\tif(ruleMatch.index > this.nextMatch)\r\n\t\t\tthis.outputText(this.output,this.nextMatch,ruleMatch.index);\r\n\t\t// Set the match parameters\r\n\t\tthis.matchStart = ruleMatch.index;\r\n\t\tthis.matchLength = ruleMatch[0].length;\r\n\t\tthis.matchText = ruleMatch[0];\r\n\t\tthis.nextMatch = this.rulesRegExp.lastIndex;\r\n\t\t// Figure out which rule matched and call its handler\r\n\t\tvar t;\r\n\t\tfor(t=1; t<ruleMatch.length; t++) {\r\n\t\t\tif(ruleMatch[t]) {\r\n\t\t\t\tthis.rules[t-1].handler(this);\r\n\t\t\t\tthis.rulesRegExp.lastIndex = this.nextMatch;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Get the next match\r\n\t\tterminatorRegExp.lastIndex = this.nextMatch;\r\n\t\tterminatorMatch = terminatorRegExp.exec(this.source);\r\n\t\truleMatch = this.rulesRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);\r\n\t}\r\n\t// Output any text after the last match\r\n\tif(this.nextMatch < this.source.length) {\r\n\t\tthis.outputText(this.output,this.nextMatch,this.source.length);\r\n\t\tthis.nextMatch = this.source.length;\r\n\t}\r\n\t// Restore the output pointer\r\n\tthis.output = oldOutput;\r\n};\r\n\r\nexports[\"text/x-tiddlywiki\"] = WikiTextParser;\r\n\r\n})();\r\n","type":"application/javascript","module-type":"parser"},"$:/plugins/tiddlywiki/tw2parser/wikitextrules.js":{"title":"$:/plugins/tiddlywiki/tw2parser/wikitextrules.js","text":"/*\\\r\ntitle: $:/plugins/tiddlywiki/tw2parser/wikitextrules.js\r\ntype: application/javascript\r\nmodule-type: module\r\n\r\nRule modules for the wikitext parser\r\n\r\n\\*/\r\n(function(){\r\n\r\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\r\nvar macroadapter = require(\"$:/macros/classic/macroadapter.js\");\r\nvar textPrimitives = {\r\n\tupperLetter: \"[A-Z\\u00c0-\\u00de\\u0150\\u0170]\",\r\n\tlowerLetter: \"[a-z0-9_\\\\-\\u00df-\\u00ff\\u0151\\u0171]\",\r\n\tanyLetter:   \"[A-Za-z0-9_\\\\-\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\r\n\tanyLetterStrict: \"[A-Za-z0-9\\u00c0-\\u00de\\u00df-\\u00ff\\u0150\\u0170\\u0151\\u0171]\",\r\n\tsliceSeparator: \"::\",\r\n\tsectionSeparator: \"##\",\r\n\turlPattern: \"(?:file|http|https|mailto|ftp|irc|news|data):[^\\\\s'\\\"]+(?:/|\\\\b)\",\r\n\tunWikiLink: \"~\",\r\n\tbrackettedLink: \"\\\\[\\\\[([^\\\\]]+)\\\\]\\\\]\",\r\n\ttitledBrackettedLink: \"\\\\[\\\\[([^\\\\[\\\\]\\\\|]+)\\\\|([^\\\\[\\\\]\\\\|]+)\\\\]\\\\]\"\r\n};\r\n\r\ntextPrimitives.wikiLink = \"(?:(?:\" + textPrimitives.upperLetter + \"+\" +\r\n\t\t\t\t\t\t\ttextPrimitives.lowerLetter + \"+\" +\r\n\t\t\t\t\t\t\ttextPrimitives.upperLetter +\r\n\t\t\t\t\t\t\ttextPrimitives.anyLetter + \"*)|(?:\" +\r\n\t\t\t\t\t\t\ttextPrimitives.upperLetter + \"{2,}\" +\r\n\t\t\t\t\t\t\ttextPrimitives.lowerLetter + \"+))\";\r\n\r\ntextPrimitives.cssLookahead = \"(?:(\" + textPrimitives.anyLetter +\r\n\t\"+)\\\\(([^\\\\)\\\\|\\\\n]+)(?:\\\\):))|(?:(\" + textPrimitives.anyLetter + \"+):([^;\\\\|\\\\n]+);)\";\r\n\r\ntextPrimitives.cssLookaheadRegExp = new RegExp(textPrimitives.cssLookahead,\"mg\");\r\n\r\ntextPrimitives.tiddlerForcedLinkRegExp = new RegExp(\"(?:\" + textPrimitives.titledBrackettedLink + \")|(?:\" +\r\n\ttextPrimitives.brackettedLink + \")|(?:\" +\r\n\ttextPrimitives.urlPattern + \")\",\"mg\");\r\n\r\ntextPrimitives.tiddlerAnyLinkRegExp = new RegExp(\"(\"+ textPrimitives.wikiLink + \")|(?:\" +\r\n\ttextPrimitives.titledBrackettedLink + \")|(?:\" +\r\n\ttextPrimitives.brackettedLink + \")|(?:\" +\r\n\ttextPrimitives.urlPattern + \")\",\"mg\");\r\n\r\n// Helper to add an attribute to an HTML node\r\nvar setAttr = function(node,attr,value) {\r\n\tif(!node.attributes) {\r\n\t\tnode.attributes = {};\r\n\t}\r\n\tnode.attributes[attr] ={type: \"string\", value:value} ;\r\n};\r\n\r\nvar inlineCssHelper = function(w) {\r\n\tvar styles = [];\r\n\ttextPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;\r\n\tvar lookaheadMatch = textPrimitives.cssLookaheadRegExp.exec(w.source);\r\n\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\r\n\t\tvar s,v;\r\n\t\tif(lookaheadMatch[1]) {\r\n\t\t\ts = lookaheadMatch[1];\r\n\t\t\tv = lookaheadMatch[2];\r\n\t\t} else {\r\n\t\t\ts = lookaheadMatch[3];\r\n\t\t\tv = lookaheadMatch[4];\r\n\t\t}\r\n\t\tif(s==\"bgcolor\")\r\n\t\t\ts = \"backgroundColor\";\r\n\t\tif(s==\"float\")\r\n\t\t\ts = \"cssFloat\";\r\n\t\tstyles.push({style: s, value: v});\r\n\t\tw.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;\r\n\t\ttextPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\tlookaheadMatch = textPrimitives.cssLookaheadRegExp.exec(w.source);\r\n\t}\r\n\treturn styles;\r\n};\r\n\r\nvar applyCssHelper = function(e,styles) {\r\n\r\n\tif(styles.length > 0) {\r\n\r\n\t\tfor(var t=0; t< styles.length; t++) {\r\n\t\t\t$tw.utils.addStyleToParseTreeNode(e,$tw.utils.roundTripPropertyName(styles[t].style),styles[t].value);\r\n\t\t}\r\n\t}\r\n\t\r\n};\r\n\r\nvar enclosedTextHelper = function(w) {\r\n\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\tvar text = lookaheadMatch[1];\r\n\t\tw.output.push({type:\"element\",tag:this.element,\r\n\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\r\n\t\tw.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;\r\n\t}\r\n};\r\n\r\nvar insertMacroCall = function(w,output,macroName,paramString) {\r\n\tvar params = [],\r\n\t\treParam = /\\s*(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\"'\\s]+)))/mg,\r\n\t\tparamMatch = reParam.exec(paramString);\r\n\twhile(paramMatch) {\r\n\t\t// Process this parameter\r\n\t\tvar paramInfo = {\r\n\t\t\tvalue: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]\r\n\t\t};\r\n\t\tif(paramMatch[1]) {\r\n\t\t\tparamInfo.name = paramMatch[1];\r\n\t\t}\r\n\t\tparams.push(paramInfo);\r\n\t\t// Find the next match\r\n\t\tparamMatch = reParam.exec(paramString);\r\n\t}\r\n\toutput.push({\r\n\t\ttype: \"macrocall\",\r\n\t\tname: macroName,\r\n\t\tparams: params,\r\n\t\tisBlock: false\r\n\t});\r\n}\r\n\r\n\r\nvar isLinkExternal = function(to) {\r\n\tvar externalRegExp = /(?:file|http|https|mailto|ftp|irc|news|data|skype):[^\\s'\"]+(?:\\/|\\b)/i;\r\n\treturn externalRegExp.test(to);\r\n};\r\nvar rules = [\r\n{\r\n\tname: \"table\",\r\n\tmatch: \"^\\\\|(?:[^\\\\n]*)\\\\|(?:[fhck]?)$\",\r\n\tlookaheadRegExp: /^\\|([^\\n]*)\\|([fhck]?)$/mg,\r\n\trowTermRegExp: /(\\|(?:[fhck]?)$\\n?)/mg,\r\n\tcellRegExp: /(?:\\|([^\\n\\|]*)\\|)|(\\|[fhck]?$\\n?)/mg,\r\n\tcellTermRegExp: /((?:\\x20*)\\|)/mg,\r\n\trowTypes: {\"c\":\"caption\", \"h\":\"thead\", \"\":\"tbody\", \"f\":\"tfoot\"},\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar table = {type:\"element\",tag:\"table\",attributes: {\"class\": {type: \"string\", value:\"table\"}},\r\n\t\t\t\t\tchildren: []};\r\n\t\t\r\n\t\tw.output.push(table);\r\n\t\tvar prevColumns = [];\r\n\t\tvar currRowType = null;\r\n\t\tvar rowContainer;\r\n\t\tvar rowCount = 0;\r\n\t\tw.nextMatch = w.matchStart;\r\n\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\r\n\t\t\tvar nextRowType = lookaheadMatch[2];\r\n\t\t\tif(nextRowType == \"k\") {\r\n\t\t\t\ttable.attributes[\"class\"] = lookaheadMatch[1];\r\n\t\t\t\tw.nextMatch += lookaheadMatch[0].length+1;\r\n\t\t\t} else {\r\n\t\t\t\tif(nextRowType != currRowType) {\r\n\t\t\t\t\trowContainer = {type:\"element\",tag:this.rowTypes[nextRowType],children: []};\r\n\t\t\t\t\ttable.children.push(rowContainer);\r\n\t\t\t\t\tcurrRowType = nextRowType;\r\n\t\t\t\t}\r\n\t\t\t\tif(currRowType == \"c\") {\r\n\t\t\t\t\t// Caption\r\n\t\t\t\t\tw.nextMatch++;\r\n\t\t\t\t\t// Move the caption to the first row if it isn't already\r\n\t\t\t\t\tif(table.children.length !== 1) {\r\n\t\t\t\t\t\ttable.children.pop(); // Take rowContainer out of the children array\r\n\t\t\t\t\t\ttable.children.splice(0,0,rowContainer); // Insert it at the bottom\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\trowContainer.attributes={};\r\n\t\t\t\t\trowContainer.attributes.align = rowCount === 0 ? \"top\" : \"bottom\";\r\n\t\t\t\t\tw.subWikifyTerm(rowContainer.children,this.rowTermRegExp);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar theRow = {type:\"element\",tag:\"tr\",\r\n\t\t\t\t\t\tattributes: {\"class\": {type: \"string\", value:rowCount%2 ? \"oddRow\" : \"evenRow\"}},\r\n\t\t\t\t\t\tchildren: []};\r\n\t\t\t\t\t\r\n\t\t\t\t\trowContainer.children.push(theRow);\r\n\t\t\t\t\tthis.rowHandler(w,theRow.children,prevColumns);\r\n\t\t\t\t\trowCount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\t\tlookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\t}\r\n\t},\r\n\trowHandler: function(w,e,prevColumns)\r\n\t{\r\n\t\tvar col = 0;\r\n\t\tvar colSpanCount = 1;\r\n\t\tvar prevCell = null;\r\n\t\tthis.cellRegExp.lastIndex = w.nextMatch;\r\n\t\tvar cellMatch = this.cellRegExp.exec(w.source);\r\n\t\twhile(cellMatch && cellMatch.index == w.nextMatch) {\r\n\t\t\tif(cellMatch[1] == \"~\") {\r\n\t\t\t\t// Rowspan\r\n\t\t\t\tvar last = prevColumns[col];\r\n\t\t\tif(last) {\r\n\t\t\t\tlast.rowSpanCount++;\r\n\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"rowspan\",last.rowSpanCount);\r\n\t\t\t\tvar vAlign = $tw.utils.getAttributeValueFromParseTreeNode(last.element,\"valign\",\"center\");\r\n\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"valign\",vAlign);\r\n\t\t\t\tif(colSpanCount > 1) {\r\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(last.element,\"colspan\",colSpanCount);\r\n\t\t\t\t\tcolSpanCount = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex-1;\r\n\t\t\t} else if(cellMatch[1] == \">\") {\r\n\t\t\t\t// Colspan\r\n\t\t\t\tcolSpanCount++;\r\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex-1;\r\n\t\t\t} else if(cellMatch[2]) {\r\n\t\t\t\t// End of row\r\n\t\t\t\tif(prevCell && colSpanCount > 1) {\r\n\t\t\t\t\tprevCell.attributes.colspan = colSpanCount;\r\n\t\t\t\t}\r\n\t\t\t\tw.nextMatch = this.cellRegExp.lastIndex;\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\t// Cell\r\n\t\t\t\tw.nextMatch++;\r\n\t\t\t\tvar styles = inlineCssHelper(w);\r\n\t\t\t\tvar spaceLeft = false;\r\n\t\t\t\tvar chr = w.source.substr(w.nextMatch,1);\r\n\t\t\t\twhile(chr == \" \") {\r\n\t\t\t\t\tspaceLeft = true;\r\n\t\t\t\t\tw.nextMatch++;\r\n\t\t\t\t\tchr = w.source.substr(w.nextMatch,1);\r\n\t\t\t\t}\r\n\t\t\t\tvar cell;\r\n\t\t\t\tif(chr == \"!\") {\r\n\t\t\t\t\tcell = {type:\"element\",tag:\"th\",children: []};\r\n\t\t\t\t\te.push(cell);\r\n\t\t\t\t\tw.nextMatch++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcell = {type:\"element\",tag:\"td\",children: []};\r\n\t\t\t\t\te.push(cell);\r\n\t\t\t\t}\r\n\t\t\t\tprevCell = cell;\r\n\t\t\t\tprevColumns[col] = {rowSpanCount:1,element:cell};\r\n\t\t\t\tif(colSpanCount > 1) {\r\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"colspan\",colSpanCount);\r\n\t\t\t\t\tcolSpanCount = 1;\r\n\t\t\t\t}\r\n\t\t\t\tapplyCssHelper(cell,styles);\r\n\t\t\t\tw.subWikifyTerm(cell.children,this.cellTermRegExp);\r\n\t\t\t\tif (!cell.attributes) cell.attributes ={};\r\n\t\t\t\tif(w.matchText.substr(w.matchText.length-2,1) == \" \") // spaceRight\r\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"align\",spaceLeft ? \"center\" : \"left\");\r\n\t\t\t\telse if(spaceLeft)\r\n\t\t\t\t\t$tw.utils.addAttributeToParseTreeNode(cell,\"align\",\"right\");\r\n\t\t\t\tw.nextMatch--;\r\n\t\t\t}\r\n\t\t\tcol++;\r\n\t\t\tthis.cellRegExp.lastIndex = w.nextMatch;\r\n\t\t\tcellMatch = this.cellRegExp.exec(w.source);\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"heading\",\r\n\tmatch: \"^!{1,6}\",\r\n\ttermRegExp: /(\\n)/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar e = {type:\"element\",tag:\"h\" + w.matchLength,children: []};\r\n\t\tw.output.push(e);\r\n\t\tw.subWikifyTerm(e.children,this.termRegExp);\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"list\",\r\n\tmatch: \"^(?:[\\\\*#;:]+)\",\r\n\tlookaheadRegExp: /^(?:(?:(\\*)|(#)|(;)|(:))+)/mg,\r\n\ttermRegExp: /(\\n)/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar stack = [w.output];\r\n\t\tvar currLevel = 0, currType = null;\r\n\t\tvar listLevel, listType, itemType, baseType;\r\n\t\tw.nextMatch = w.matchStart;\r\n\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\twhile(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {\r\n\t\t\tif(lookaheadMatch[1]) {\r\n\t\t\t\tlistType = \"ul\";\r\n\t\t\t\titemType = \"li\";\r\n\t\t\t} else if(lookaheadMatch[2]) {\r\n\t\t\t\tlistType = \"ol\";\r\n\t\t\t\titemType = \"li\";\r\n\t\t\t} else if(lookaheadMatch[3]) {\r\n\t\t\t\tlistType = \"dl\";\r\n\t\t\t\titemType = \"dt\";\r\n\t\t\t} else if(lookaheadMatch[4]) {\r\n\t\t\t\tlistType = \"dl\";\r\n\t\t\t\titemType = \"dd\";\r\n\t\t\t}\r\n\t\t\tif(!baseType)\r\n\t\t\t\tbaseType = listType;\r\n\t\t\tlistLevel = lookaheadMatch[0].length;\r\n\t\t\tw.nextMatch += lookaheadMatch[0].length;\r\n\t\t\tvar t,e;\r\n\t\t\tif(listLevel > currLevel) {\r\n\t\t\t\tfor(t=currLevel; t<listLevel; t++) {\r\n\t\t\t\t\tvar target = stack[stack.length-1];\r\n\t\t\t\t\tif(currLevel !== 0 && target.children) {\r\n\t\t\t\t\t\ttarget = target.children[target.children.length-1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\te = {type:\"element\",tag:listType,children: []};\r\n\t\t\t\t\ttarget.push(e);\r\n\t\t\t\t\tstack.push(e.children);\r\n\t\t\t\t}\r\n\t\t\t} else if(listType!=baseType && listLevel==1) {\r\n\t\t\t\tw.nextMatch -= lookaheadMatch[0].length;\r\n\t\t\t\treturn;\r\n\t\t\t} else if(listLevel < currLevel) {\r\n\t\t\t\tfor(t=currLevel; t>listLevel; t--)\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t} else if(listLevel == currLevel && listType != currType) {\r\n\t\t\t\tstack.pop();\r\n\t\t\t\te = {type:\"element\",tag:listType,children: []};\r\n\t\t\t\tstack[stack.length-1].push(e);\r\n\t\t\t\tstack.push(e.children);\r\n\t\t\t}\r\n\t\t\tcurrLevel = listLevel;\r\n\t\t\tcurrType = listType;\r\n\t\t\te = {type:\"element\",tag:itemType,children: []};\r\n\t\t\tstack[stack.length-1].push(e);\r\n\t\t\tw.subWikifyTerm(e.children,this.termRegExp);\r\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\t\tlookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"quoteByBlock\",\r\n\tmatch: \"^<<<\\\\n\",\r\n\ttermRegExp: /(^<<<(\\n|$))/mg,\r\n\telement: \"blockquote\",\r\n\thandler:  function(w) {\r\n\t\tvar e = {type:\"element\",tag:this.element,children: []};\r\n\t\tw.output.push(e);\r\n\t\tw.subWikifyTerm(e.children,this.termRegExp);\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"quoteByLine\",\r\n\tmatch: \"^>+\",\r\n\tlookaheadRegExp: /^>+/mg,\r\n\ttermRegExp: /(\\n)/mg,\r\n\telement: \"blockquote\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar stack = [];\r\n\t\tvar currLevel = 0;\r\n\t\tvar newLevel = w.matchLength;\r\n\t\tvar t,matched,e;\r\n\t\tdo {\r\n\t\t\tif(newLevel > currLevel) {\r\n\t\t\t\tfor(t=currLevel; t<newLevel; t++) {\r\n\t\t\t\t\tvar f = stack[stack.length-1];\r\n\t\t\t\t\te = {type:\"element\",tag:this.element,children: []};\r\n\t\t\t\t\tstack.push(e);\r\n\t\t\t\t\tif (t ===0){\r\n\t\t\t\t\t\tw.output.push(e);\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tf.children.push(e);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if(newLevel < currLevel) {\r\n\t\t\t\tfor(t=currLevel; t>newLevel; t--)\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t}\r\n\t\t\tcurrLevel = newLevel;\r\n\t\t\tw.subWikifyTerm(stack[stack.length-1].children,this.termRegExp);\r\n\t\t\tstack[stack.length-1].children.push({type:\"element\",tag:\"br\"});\r\n\t\t\t//e.push({type:\"element\",tag:\"br\"});\r\n\r\n\t\t\tthis.lookaheadRegExp.lastIndex = w.nextMatch;\r\n\t\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\t\tmatched = lookaheadMatch && lookaheadMatch.index == w.nextMatch;\r\n\t\t\tif(matched) {\r\n\t\t\t\tnewLevel = lookaheadMatch[0].length;\r\n\t\t\t\tw.nextMatch += lookaheadMatch[0].length;\r\n\t\t\t}\r\n\t\t} while(matched);\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"rule\",\r\n\tmatch: \"^----+$\\\\n?|<hr ?/?>\\\\n?\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tw.output.push({type:\"element\",tag:\"hr\"});\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"monospacedByLine\",\r\n\tmatch: \"^(?:/\\\\*\\\\{\\\\{\\\\{\\\\*/|\\\\{\\\\{\\\\{|//\\\\{\\\\{\\\\{|<!--\\\\{\\\\{\\\\{-->)\\\\n\",\r\n\telement: \"pre\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tswitch(w.matchText) {\r\n\t\tcase \"/*{{{*/\\n\": // CSS\r\n\t\t\tthis.lookaheadRegExp = /\\/\\*\\{\\{\\{\\*\\/\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*\\/\\*\\}\\}\\}\\*\\/$\\n?)/mg;\r\n\t\t\tbreak;\r\n\t\tcase \"{{{\\n\": // monospaced block\r\n\t\t\tthis.lookaheadRegExp = /^\\{\\{\\{\\n((?:^[^\\n]*\\n)+?)(^\\f*\\}\\}\\}$\\n?)/mg;\r\n\t\t\tbreak;\r\n\t\tcase \"//{{{\\n\": // plugin\r\n\t\t\tthis.lookaheadRegExp = /^\\/\\/\\{\\{\\{\\n\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*\\/\\/\\}\\}\\}$\\n?)/mg;\r\n\t\t\tbreak;\r\n\t\tcase \"<!--{{{-->\\n\": //template\r\n\t\t\tthis.lookaheadRegExp = /<!--\\{\\{\\{-->\\n*((?:^[^\\n]*\\n)+?)(\\n*^\\f*<!--\\}\\}\\}-->$\\n?)/mg;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tenclosedTextHelper.call(this,w);\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"typedBlock\",\r\n\t\tmatch: \"^\\\\$\\\\$\\\\$(?:[^ >\\\\r\\\\n]*)\\\\r?\\\\n\",\r\n\tlookaheadRegExp: /^\\$\\$\\$([^ >\\r\\n]*)\\n((?:^[^\\n]*\\r?\\n)+?)(^\\f*\\$\\$\\$\\r?\\n?)/mg,\r\n\t//match: \"^\\\\$\\\\$\\\\$(?:[^ >\\\\r\\\\n]*)(?: *> *([^ \\\\r\\\\n]+))?\\\\r?\\\\n\",\r\n\t//lookaheadRegExp: /^\\$\\$\\$([^ >\\r\\n]*)(?: *> *([^ \\r\\n]+))\\n((?:^[^\\n]*\\n)+?)(^\\f*\\$\\$\\$$\\n?)/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\t// The wikitext parsing infrastructure is horribly unre-entrant\r\n\t\t\tvar parseType = lookaheadMatch[1],\r\n\t\t\t\trenderType ,//= this.match[2],\r\n\t\t\t\ttext = lookaheadMatch[2],\r\n\t\t\t\toldOutput = w.output,\r\n\t\t\t\toldSource = w.source,\r\n\t\t\t\toldNextMatch = w.nextMatch,\r\n\t\t\t\toldChildren = w.children;\r\n\t\t\t// Parse the block according to the specified type\r\n\t\t\tvar parser = $tw.wiki.parseText(parseType,text.toString(),{defaultType: \"text/plain\"});\r\n\r\n\t\t\tw.output = oldOutput;\r\n\t\t\tw.source = oldSource;\r\n\t\t\tw.nextMatch = oldNextMatch;\r\n\t\t\tw.children = oldChildren;\r\n\t\t\tfor (var i=0; i<parser.tree.length; i++) {\r\n\t\t\t\tw.output.push(parser.tree[i]);\r\n\t\t\t}\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"wikifyComment\",\r\n\tmatch: \"^(?:/\\\\*\\\\*\\\\*|<!---)\\\\n\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar termRegExp = (w.matchText == \"/***\\n\") ? (/(^\\*\\*\\*\\/\\n)/mg) : (/(^--->\\n)/mg);\r\n\t\tw.subWikifyTerm(w.output,termRegExp);\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"macro\",\r\n\tmatch: \"<<\",\r\n\tlookaheadRegExp: /<<(?:([!@Â£\\$%\\^\\&\\*\\(\\)`\\~'\"\\|\\\\\\/;\\:\\.\\,\\+\\=\\-\\_\\{\\}])|([^>\\s]+))(?:\\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source),\r\n\t\t\tname;\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\tname = lookaheadMatch[1] || lookaheadMatch[2];\r\n\t\t\tvar params = lookaheadMatch[3], nameold =name;\r\n\t\t\tif (name) {\r\n\t\t\t\tif (!!macroadapter.paramadapter[name]) {\r\n\t\t\t\t\tparams=macroadapter.paramadapter[name](params);\r\n\t\t\t\t\t//alert(\"going out as \"+params);\r\n\t\t\t\t}\r\n\t\t\t\tif (!!macroadapter.namedapter[name]) {\r\n\t\t\t\t\tname=macroadapter.namedapter[name];\r\n\t\t\t\t}\r\n\t\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t\t\tinsertMacroCall(w,w.output,name,params);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n},\r\n\r\n\r\n{\r\n\tname: \"prettyLink\",\r\n\tmatch: \"\\\\[\\\\[\",\r\n\tlookaheadRegExp: /\\[\\[(.*?)(?:\\|(~)?(.*?))?\\]\\]/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\tvar text = lookaheadMatch[1],\r\n\t\t\t\tlink = text;\r\n\t\t\tif(lookaheadMatch[3]) {\r\n\t\t\t\t// Pretty bracketted link\r\n\t\t\t\tlink = lookaheadMatch[3];\r\n\t\t\t}\r\n\tif(isLinkExternal(link)) {\r\n\t\tw.output.push({\r\n\t\t\ttype: \"element\",\r\n\t\t\ttag: \"a\",\r\n\t\t\tattributes: {\r\n\t\t\t\thref: {type: \"string\", value: link},\r\n\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\r\n\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\r\n\t\t\t},\r\n\t\t\tchildren: [{\r\n\t\t\t\ttype: \"text\", text: text\r\n\t\t\t}]\r\n\t\t});\r\n\t} else {\r\n\t\tw.output.push({\r\n\t\t\ttype: \"link\",\r\n\t\t\tattributes: {\r\n\t\t\t\tto: {type: \"string\", value: link}\r\n\t\t\t},\r\n\t\t\tchildren: [{\r\n\t\t\t\ttype: \"text\", text: text\r\n\t\t\t}]\r\n\t\t});\r\n\t}\r\n\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t}\r\n\t}\r\n},\r\n{\r\n\tname: \"wikiLink\",\r\n\tmatch: textPrimitives.unWikiLink+\"?\"+textPrimitives.wikiLink,\r\n\thandler: function(w)\r\n\t{\r\n\t\tif(w.matchText.substr(0,1) == textPrimitives.unWikiLink) {\r\n\t\t\tw.outputText(w.output,w.matchStart+1,w.nextMatch);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(w.matchStart > 0) {\r\n\t\t\tvar preRegExp = new RegExp(textPrimitives.anyLetterStrict,\"mg\");\r\n\t\t\tpreRegExp.lastIndex = w.matchStart-1;\r\n\t\t\tvar preMatch = preRegExp.exec(w.source);\r\n\t\t\tif(preMatch.index == w.matchStart-1) {\r\n\t\t\t\tw.outputText(w.output,w.matchStart,w.nextMatch);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(w.autoLinkWikiWords) {\r\n\t\t\tw.output.push({\r\n\t\t\t\ttype: \"link\",\r\n\t\t\t\tattributes: {\r\n\t\t\t\t\tto: {type: \"string\", value: w.matchText}\r\n\t\t\t\t},\r\n\t\t\t\tchildren: [{\r\n\t\t\t\t\ttype: \"text\",\r\n\t\t\t\t\ttext: w.source.substring(w.matchStart,w.nextMatch)\r\n\t\t\t\t}]\r\n\t\t\t});\r\n\t\t} else {\t\r\n\t\t\tw.outputText(w.output,w.matchStart,w.nextMatch);\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"urlLink\",\r\n\tmatch: textPrimitives.urlPattern,\r\n\thandler: function(w)\r\n\t{\r\n\t\t\tw.output.push({\r\n\t\t\ttype: \"element\",\r\n\t\t\ttag: \"a\",\r\n\t\t\tattributes: {\r\n\t\t\t\thref: {type: \"string\", value: w.matchText},\r\n\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\r\n\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\r\n\t\t\t},\r\n\t\t\tchildren: [{\r\n\t\t\t\ttype: \"text\", text: w.source.substring(w.matchStart,w.nextMatch)\r\n\t\t\t}]\r\n\t\t});\r\n\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"image\",\r\n\tmatch: \"\\\\[[<>]?[Ii][Mm][Gg]\\\\[\",\r\n\t// [<] sequence below is to avoid lessThan-questionMark sequence so TiddlyWikis can be included in PHP files\r\n\tlookaheadRegExp: /\\[([<]?)(>?)[Ii][Mm][Gg]\\[(?:([^\\|\\]]+)\\|)?([^\\[\\]\\|]+)\\](?:\\[([^\\]]*)\\])?\\]/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar node = {\r\n\t\t\ttype: \"image\",\r\n\t\t\tattributes: {}\r\n\t\t};\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source),\r\n\t\t\timageParams = {},\r\n\t\t\tlinkParams = {};\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\tif(lookaheadMatch[1]) {\r\n\t\t\t\tnode.attributes.class = {type: \"string\", value: \"classic-image-left\"};\r\n\t\t\t} else if(lookaheadMatch[2]) {\r\n\t\t\t\tnode.attributes.class  = {type: \"string\", value: \"classic-image-right\"};\r\n\t\t\t}\r\n\t\t\tif(lookaheadMatch[3]) {\r\n\t\t\t\tnode.attributes.tooltip = {type: \"string\", value: lookaheadMatch[3]};\r\n\t\t\t}\r\n\t\t\tnode.attributes.source = {type: \"string\", value: lookaheadMatch[4]};\r\n\t\t\tif(lookaheadMatch[5]) {\r\n\t\t\t\tif(isLinkExternal(lookaheadMatch[5])) {\r\n\t\t\t\t\tw.output.push({\r\n\t\t\t\t\t\ttype: \"element\",\r\n\t\t\t\t\t\ttag: \"a\",\r\n\t\t\t\t\t\tattributes: {\r\n\t\t\t\t\t\t\thref: {type: \"string\", value:lookaheadMatch[5]},\r\n\t\t\t\t\t\t\t\"class\": {type: \"string\", value: \"tc-tiddlylink-external\"},\r\n\t\t\t\t\t\t\ttarget: {type: \"string\", value: \"_blank\"}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tchildren: [node]\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tw.output.push({\r\n\t\t\t\t\t\ttype: \"link\",\r\n\t\t\t\t\t\tattributes: {\r\n\t\t\t\t\t\t\tto: {type: \"string\", value: lookaheadMatch[5]}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tchildren: [node]\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tw.output.push(node);\r\n\t\t\t}\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"html\",\r\n\tmatch: \"<[Hh][Tt][Mm][Ll]>\",\r\n\tlookaheadRegExp: /<[Hh][Tt][Mm][Ll]>((?:.|\\n)*?)<\\/[Hh][Tt][Mm][Ll]>/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\tw.output.push({\ttype:\"raw\", html:lookaheadMatch[1]});\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"commentByBlock\",\r\n\tmatch: \"/%\",\r\n\tlookaheadRegExp: /\\/%((?:.|\\n)*?)%\\//mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart)\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"characterFormat\",\r\n\tmatch: \"''|//|__|\\\\^\\\\^|~~|--(?!\\\\s|$)|\\\\{\\\\{\\\\{|`\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tvar e,lookaheadRegExp,lookaheadMatch;\r\n\t\tswitch(w.matchText) {\r\n\t\tcase \"''\":\r\n\t\t\te = {type:\"element\",tag:\"strong\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/('')/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"//\":\r\n\t\t\te = {type:\"element\",tag:\"em\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/(\\/\\/)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"__\":\r\n\t\t\te = {type:\"element\",tag:\"u\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/(__)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"^^\":\r\n\t\t\te = {type:\"element\",tag:\"sup\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/(\\^\\^)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"~~\":\r\n\t\t\te = {type:\"element\",tag:\"sub\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/(~~)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"--\":\r\n\t\t\te = {type:\"element\",tag:\"strike\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tw.subWikifyTerm(e.children,/(--)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"`\":\r\n\t\t\tlookaheadRegExp = /`((?:.|\\n)*?)`/mg;\r\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\r\n\t\t\tlookaheadMatch = lookaheadRegExp.exec(w.source);\r\n\t\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\t\tw.output.push({type:\"element\",tag:\"code\",\r\n\t\t\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"{{{\":\r\n\t\t\tlookaheadRegExp = /\\{\\{\\{((?:.|\\n)*?)\\}\\}\\}/mg;\r\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\r\n\t\t\tlookaheadMatch = lookaheadRegExp.exec(w.source);\r\n\t\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\t\tw.output.push({type:\"element\",tag:\"code\",\r\n\t\t\t\t\tchildren:[{type: \"text\",text: lookaheadMatch[1]}]});\r\n\t\t\t\tw.nextMatch = lookaheadRegExp.lastIndex;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"customFormat\",\r\n\tmatch: \"@@|\\\\{\\\\{\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tswitch(w.matchText) {\r\n\t\tcase \"@@\":\r\n\t\t\tvar e = {type:\"element\",tag:\"span\",children: []};\r\n\t\t\tw.output.push(e);\r\n\t\t\tvar styles = inlineCssHelper(w);\r\n\t\t\tif(styles.length === 0)\r\n\t\t\t\tsetAttr(e,\"class\",\"marked\");\r\n\t\t\telse\r\n\t\t\t\tapplyCssHelper(e,styles);\r\n\t\t\tw.subWikifyTerm(e.children,/(@@)/mg);\r\n\t\t\tbreak;\r\n\t\tcase \"{{\":\r\n\t\t\tvar lookaheadRegExp = /\\{\\{[\\s]*([\\-\\w]+[\\-\\s\\w]*)[\\s]*\\{(\\n?)/mg;\r\n\t\t\tlookaheadRegExp.lastIndex = w.matchStart;\r\n\t\t\tvar lookaheadMatch = lookaheadRegExp.exec(w.source);\r\n\t\t\tif(lookaheadMatch) {\r\n\t\t\t\tw.nextMatch = lookaheadRegExp.lastIndex;\r\n\t\t\t\te = {type:\"element\",tag:lookaheadMatch[2] == \"\\n\" ? \"div\" : \"span\",\r\n\t\t\t\t\tattributes: {\"class\": {type: \"string\", value:lookaheadMatch[1]}},children: []};\r\n\t\t\t\tw.output.push(e);\r\n\t\t\t\tw.subWikifyTerm(e.children,/(\\}\\}\\})/mg);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"mdash\",\r\n\tmatch: \"--\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tw.output.push({type: \"entity\", entity: \"&mdash;\"});\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"lineBreak\",\r\n\tmatch: \"\\\\n|<br ?/?>\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tw.output.push({type:\"element\",tag:\"br\"});\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"rawText\",\r\n\tmatch: \"\\\"{3}|<nowiki>\",\r\n\tlookaheadRegExp: /(?:\\\"{3}|<nowiki>)((?:.|\\n)*?)(?:\\\"{3}|<\\/nowiki>)/mg,\r\n\thandler: function(w)\r\n\t{\r\n\t\tthis.lookaheadRegExp.lastIndex = w.matchStart;\r\n\t\tvar lookaheadMatch = this.lookaheadRegExp.exec(w.source);\r\n\t\tif(lookaheadMatch && lookaheadMatch.index == w.matchStart) {\r\n\t\t\tw.output.push({type: \"text\",text: lookaheadMatch[1]\r\n\t\t\t});\r\n\t\t\tw.nextMatch = this.lookaheadRegExp.lastIndex;\r\n\t\t}\r\n\t}\r\n},\r\n\r\n{\r\n\tname: \"htmlEntitiesEncoding\",\r\n\tmatch: \"&#?[a-zA-Z0-9]{2,8};\",\r\n\thandler: function(w)\r\n\t{\r\n\t\tw.output.push({type: \"entity\", entity: w.matchText});\r\n\t}\r\n}\r\n\r\n];\r\n\r\nexports.rules = rules;\r\n\r\n})();\r\n","type":"application/javascript","module-type":"module"}}}